<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-IOC/DI</title>
    <url>/2023/04/05/01-IOC_DI/</url>
    <content><![CDATA[<p>Spring框架主要的优势是在<strong>简化开发</strong>和<strong>框架整合</strong>上，针对特点Spring的学习主线就是IOC、AOP、声明式事务和整合MyBais框架。Part1主要学习IOC容器中的bean、依赖注入以及核心容器。</p>
<span id="more"></span>

<h1 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h1><h2 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h2><p>在 <a href="https://spring.io/">Spring官网 </a>中提供了所有项目统称为Spring全家桶，我们主要需要掌握以下比较流行的技术：</p>
<img src="image-20230402153559808.png" alt="image-20230402153559808" style="zoom:50%;" />

<ul>
<li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li>
<li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li>
<li>SpringCloud：这个是用来做分布式微服务架构的相关开发。</li>
</ul>
<h2 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h2><p>至今Spring已经更新到6.x版本，而下面的是4.x版本的架构图。Spring Framework 的系统架构图只是一种概念上的表示，具体实现和细节可能会根据具体应用场景进行调整和优化，所以我们以4.x版本为例来研究。</p>
<img src="image-20230402153914329.png" alt="image-20230402153914329" style="zoom:67%;" />

<p>（1）核心层</p>
<ul>
<li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块；</li>
</ul>
<p>（2）AOP层</p>
<ul>
<li>AOP：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强；</li>
<li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现；</li>
</ul>
<p>（3）数据层</p>
<ul>
<li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术；</li>
<li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis；</li>
<li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容；</li>
</ul>
<p>（4）Web层</p>
<ul>
<li>这一层的内容将在SpringMVC框架具体学习；</li>
</ul>
<p>（5）Test层</p>
<ul>
<li>Spring主要整合了Junit来完成单元测试和集成测试。</li>
</ul>
<h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><p>这部分内容中主要包含 <code>IOC/DI</code> 、<code>IOC容器</code> 和 <code>Bean</code>。</p>
<h3 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h3><p>业务层需要调用数据层的方法，就需要在业务层new数据层的对象；如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署，导致项目代码的<strong>耦合度偏高</strong>。</p>
<img src="image-20230402154840495.png" alt="image-20230402154840495" style="zoom: 67%;" />

<p>从上图我们也可以看到，业务层是通过new数据层的对象调用数据层的方法，从而造成耦合度高的问题。如果能把框中的内容给去掉，不就可以降低依赖了，但是如果直接去掉不做任何改动，会造成对象的NullPointer报错 。针对这个问题，Spring就提出了一个解决方案：在使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象，这种实现思想就是Spring的一个核心概念。</p>
<h3 id="IOC、IOC容器、Bean、DI"><a href="#IOC、IOC容器、Bean、DI" class="headerlink" title="IOC、IOC容器、Bean、DI"></a>IOC、IOC容器、Bean、DI</h3><p>1、IOC（Inversion of Control）控制反转</p>
<p>（1）控制反转：使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</p>
<p>（2）Spring和IOC的关系：Spring提供了一个容器，称为IOC容器，IOC思想中的“提供对象的外部”指的就是Spring的IOC容器。</p>
<p>（3）IOC容器：</p>
<ul>
<li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象；</li>
<li>被创建或被管理的对象在IOC容器中统称为Bean，IOC容器中放的就是一个个的Bean对象；</li>
</ul>
<p>（4）在IOC容器中创建好service对象和dao对象后，要将service对象建立对dao对象的依赖关系，在容器中建立对象与对象之间的绑定关系就要用到 <strong>DI</strong>。</p>
<p>2、DI（Dependency Injection）依赖注入</p>
<img src="image-20230402155903628.png" alt="image-20230402155903628" style="zoom:67%;" />

<p>依赖注入：在容器中建立bean与bean之间的依赖关系的整个过程称为依赖注入。如业务层需要依赖数据层，service就要和dao建立依赖关系。</p>
<p>使用<code>IOC</code>和<code>DI</code>到达最终解耦的目的，最终结果是使用对象可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。</p>
<h2 id="IOC、DI入门案例"><a href="#IOC、DI入门案例" class="headerlink" title="IOC、DI入门案例"></a>IOC、DI入门案例</h2><p> 步骤1：在pom.xml导入<code>spring</code>依赖坐标；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤1.5：创建数据层和业务层代码</p>
<p>步骤2：在<code>resource</code>目录下创建spring的配置文件——<code>applicationContext.xml</code>，配置对应类作为Spring管理的Bean；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bean定义时，id属性在同一个配置文件中不能重复。</p>
</blockquote>
<p>步骤3：使用Spring提供的接口<code>ApplicationContext</code>完成IOC容器的创建；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>步骤4：从IOC容器中获取对象进行方法调用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">userDao.save();</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.save();</span><br></pre></td></tr></table></figure>

<p>p.s. 标准的项目架构如下：</p>
<img src="image-20230402161011022.png" alt="image-20230402161011022" style="zoom:50%;" />

<p>这时候在业务层仍然是用new创建了数据层的<code>UserDaoImpl</code>对象，为了实现IOC，还需要用到DI依赖注入。</p>
<p>步骤5：删除业务层中通过new方式创建的dao对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private UserDao userDao = new UserDaoImpl();</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<p>步骤6：提供对应的setter方法<em>（快捷键：Fn+Alt+Insert）</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为不再程序中使用new对对象<code>UserDao</code>进行赋值操作，所以要为<code>UserDao</code>对象提供一个赋值的入口，就是setter方法，什么时候调用，谁来调用它会在后续提到。</p>
<p>步骤7：修改配置完成DI注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 7.配置service与dao的关系--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">               property标签表示配置当前的bean属性</span></span><br><span class="line"><span class="comment">               name属性表示配置的是哪一个具体的属性</span></span><br><span class="line"><span class="comment">               ref属性表示参照的是哪一个bean</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230402163443276.png" alt="image-20230402163443276"></p>
<h1 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h1><p>前面的入门案例尝试了bean如何定义配置、DI如何定义配置以及容器对象如何获取，接下来主要是把这三块内容展开进行详细的讲解。</p>
<h2 id="Bean基础配置"><a href="#Bean基础配置" class="headerlink" title="Bean基础配置"></a>Bean基础配置</h2><ul>
<li><p>Bean基础配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>id：使用id可以获取对应的bean，在一个容器中id值是唯一的</li>
<li>class：bean的类型，配置的bean的全路径类名</li>
</ul>
</li>
<li><p>Bean别名配置：<code>name</code>属性</p>
<p>为bean指定别名，别名可以有多个，可以使用逗号、分号、空格进行分隔。这样从容器中获取bean对象时就可以使用name里的别名了（<code>ref</code>属性里指定的bean也可以使用别名，但正规写法是使用id属性）。</p>
<blockquote>
<p>如果抛出NoSuchBeanDefinitionException的异常，表示从IOC容器中找不到该bean，这时候要去检查配置文件bean中的id属性和name属性，是否和getbean中的参数对应一致。    </p>
</blockquote>
</li>
<li><p>Bean作用范围配置：<code>scope</code>属性</p>
<ul>
<li><code>singleton</code>：单例（默认）</li>
<li><code>prototype</code>：非单例</li>
</ul>
<p>将同一个bean获取两次，打印看地址输出是否一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230402170626816.png" alt="image-20230402170626816"></p>
<p>将<code>UserDao</code>这个bean配置为非单例模式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230402170741177.png" alt="image-20230402170741177"></p>
<blockquote>
<p>① bean默认为单例是在Spring的IOC容器中只会有该类的一个对象，避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高。</p>
<p>② 单例模式的bean：如果对象是有状态对象，即该对象有成员变量可以用来存储数据的；因为所有请求线程共用一个bean对象，所以会存在线程安全问题。反之则不存在线程安全问题。</p>
<p>③ 像表现层、业务层、数据层、工具类对象，这样的bean对象适合交给容器进行管理，它们在单例模式下不会存在线程安全问题，且对bean对象进行复用；而示例对象则不适合交给容器进行管理。</p>
</blockquote>
</li>
</ul>
<h2 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><p>现在bean已经放在了IOC容器中，那容器是如何进行bean的创建的呢？bean本质上是对象，通过new创建对象是调用类的构造方法，所以创建bean也是通过构造方法来完成的。</p>
<h3 id="构造方法实例化"><a href="#构造方法实例化" class="headerlink" title="构造方法实例化"></a>构造方法实例化</h3><p>在<code>UserDaoImpl</code>类中创建一个无参构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userDaoImpl Constructor is running...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数：</p>
<img src="image-20230402190214395.png" alt="image-20230402190214395" style="zoom:80%;" />

<p>每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做，这也是我们以后比较常用的一种方式。</p>
<h3 id="静态工厂实例化"><a href="#静态工厂实例化" class="headerlink" title="静态工厂实例化"></a>静态工厂实例化</h3><p>1、工厂方式创建bean</p>
<p>（1）准备一个OrderDao和OrderDaoImpl类</p>
<p>（2）创建一个工厂类OrderDaoFactory并提供一个静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p>
<p>2、静态工厂实例化</p>
<p>现在bean对象已经创建好了，如何将bean交给Spring来管理呢？</p>
<p>（1）在spring的配置文件applicationContext.properties中添加以下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>class：工厂类的类全名；</li>
<li>factory-mehod：具体工厂类中创建对象的方法名；</li>
</ul>
<p>（2）在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试（跟前面一致）。</p>
<blockquote>
<p>这种方式一般是用来兼容早期的一些老系统，过去使用工厂类创建对象，是为了在new基础上添加一些其他的业务内容。</p>
</blockquote>
<h3 id="实例工厂与FactoryBean"><a href="#实例工厂与FactoryBean" class="headerlink" title="实例工厂与FactoryBean"></a>实例工厂与FactoryBean</h3><p>1、实例工厂方式创建bean</p>
<p>（1）准备一个BookDao和BookDaoImpl类</p>
<p>（2）创建一个工厂类OrderDaoFactory并提供一个普通方法（注意此处和静态工厂的工厂类不同之处是方法不是静态方法）</p>
<p>（3）编写AppForInstanceBook运行类，在类中通过工厂获取对象</p>
<p>2、实例工厂实例化</p>
<p>（1）在spring的配置文件中添加以下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.factory.BookDaoFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例化工厂的运行顺序：</p>
<ul>
<li><p>创建实例化工厂对象，对应的是第一行配置；</p>
</li>
<li><p>调用对象中的方法来创建bean，对应的是第二行配置：</p>
<ul>
<li><p>factory-bean：工厂的实例对象（对应bean的id属性）</p>
</li>
<li><p>factory-method：工厂对象中的具体创建对象的方法名，对应关系如下:</p>
<img src="image-20230402194515616.png" alt="image-20230402194515616" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<p>（2）在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试。</p>
<p>3、FactoryBean</p>
<p>Spring为了简化实例工厂进行bean实例化的配置方式就提供了<code>FactoryBean</code>来简化开发。</p>
<p>（1）创建一个BookDaoFactoryBean的类，实现<code>FactoryBean</code>接口，重写接口的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;BookDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BookDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> BookDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>FactoryBean</code>接口中还有一个方法，默认是不需要重写的，就是<code>isSingleton()</code>，默认是单例模式<code>return true</code>.</p>
</blockquote>
<p>（2）在Spring的配置文件中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.factory.BookDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Bean实例化 小结</strong></p>
<ul>
<li>bean本质是对象，所以它是通过构造方法来创建的；</li>
<li>Spring的IOC实例化对象的三种方式分别是：构造方法、静态工厂、实例工厂，这些方式中主要掌握构造方法和实例工厂中的<code>FactoryBean</code>方法即可；</li>
<li>在使用构造方法实例化对象时，如果重写了构造方法，建议把无参默认构造方法也重写。</li>
</ul>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>bean的生命周期就是bean对象从创建到销毁的整体过程。</p>
<h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><ul>
<li>bean创建之后添加内容，比如用来初始化需要用到资源</li>
<li>bean销毁之前添加内容，比如用来释放用到的资源</li>
</ul>
<p>1、在配置文件添加method方式进行生命周期设置</p>
<p><strong>步骤1：</strong>添加初始化和销毁的方法（方法名任意）</p>
<p><strong>步骤2：</strong>配置生命周期</p>
<p>在配置文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>从执行结果来看，init方法执行了，但destroy方法没有执行。</p>
<blockquote>
<p>因为Spring的IOC容器是运行在JVM中，运行main方法后，JVM启动，Spring加载配置文件生成IOC容器，从容器获取bean对象，然后调方法执行main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了，所以没有调用对应的destroy方法。</p>
</blockquote>
<p>所以我们需要手动关闭容器来销毁bean。</p>
<ul>
<li><p>方式1：close关闭容器</p>
<p>ApplicationContext中没有close方法，需要把ApplicationContext换成它是实现类ClassPathXmlApplicationContext，再调用<code>close()</code>方法即可。</p>
</li>
<li><p>方式2：注册钩子关闭容器</p>
<p>提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.registerShutdownHook();  <span class="comment">// JVM退出前调用关闭，可以放在任意位置</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>2、实现接口方式进行生命周期设置</p>
<p>添加初始化和销毁方法，既需要编码也需要配置，实现起来步骤比较多也比较乱，Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code>。</p>
<p>修改UserServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230402203450419.png" alt="image-20230402203450419" style="zoom:80%;" />

<blockquote>
<p>Bean的声明周期和是否<code>getBean</code>没有关系，bean随着加载配置文件生成IOC容器而被创建出来，随着IOC的关闭而销毁。</p>
</blockquote>
<p>对于业务层的UserServiceImpl来说，userDao是它的一个属性，setUserDao方法是Spring的IOC容器为其注入属性的方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- setter为其注入name属性 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>而<code>afterPropertiesSet()</code>意为”属性创建之后“，所以bean的初始化方法会在类中属性设置之后执行。</p>
<img src="image-20230402204437779.png" alt="image-20230402204437779" style="zoom:67%;" />

<p><strong>bean的生命周期 小结</strong></p>
<p>（1）关于Spring中对bean生命周期控制提供了两种方式：</p>
<ul>
<li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性；</li>
<li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口（了解即可）。</li>
</ul>
<p>（2）bean的生命周期</p>
<ul>
<li>初始化容器<ul>
<li>创建对象（new内存分配）</li>
<li>执行构造方法</li>
<li>执行属性注入（setter操作）</li>
<li>执行bean初始化方法（init操作，生命周期开启）</li>
</ul>
</li>
<li>使用bean：执行业务操作</li>
<li>关闭/销毁容器：执行bean销毁方法（destroy）</li>
</ul>
<p>（3）关闭容器的两种方式：</p>
<ul>
<li><code>close()</code> 方法</li>
<li><code>registerShutdownHook()</code> 方法</li>
</ul>
<h1 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h1><p>向一个类中传递数据有2种方式：普通set方法、构造方法；依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，但有时bean运行需要的是数字或字符串。Spring基于上述为我们提供了2种注入方式：</p>
<ul>
<li>setter注入：引用类型、简单类型（这里将String归类到基本类型的注入中，但实际上String是个类，是引用数据类型）</li>
<li>构造器注入：引用类型、简单类型</li>
</ul>
<h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><h3 id="setter注入引用类型"><a href="#setter注入引用类型" class="headerlink" title="setter注入引用类型"></a>setter注入引用类型</h3><ul>
<li><p>在bean中声明引用类型属性，并提供可访问的set方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置中使用<code>property</code>标签<code>ref</code>属性注入引用类型对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<img src="image-20230403094212301.png" alt="image-20230403094212301" style="zoom:80%;" />

<p>现在userDao、userService、bookDao对象都已经被注入成功。</p>
<h3 id="setter注入简单类型"><a href="#setter注入简单类型" class="headerlink" title="setter注入简单类型"></a>setter注入简单类型</h3><ul>
<li><p>在bean中声明简单类型属性，并提供可访问的set方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String databaseName;  <span class="comment">// 注入时把String看作简单类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置中使用<code>property</code>标签注入简单类型对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="image-20230403095128187.png" alt="image-20230403095128187" style="zoom:80%;" /></li>
</ul>
<h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><ul>
<li><p>删除属性的setter方法并提供构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置中使用<code>constructor-arg</code>标签注入引用类型对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>constructor-arg</code>标签中，name属性对应的值为<strong>构造函数中方法形参</strong>的参数名，必须要保持一致。</p>
</li>
</ul>
<img src="image-20230403101307018.png" alt="image-20230403101307018" style="zoom:80%;" />

<h3 id="构造器注入简单数据类型"><a href="#构造器注入简单数据类型" class="headerlink" title="构造器注入简单数据类型"></a>构造器注入简单数据类型</h3><ul>
<li><p>删除属性的setter方法并提供构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String databaseName;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：添加完构造方法后在配置文件中出现bean中class属性的报错：</p>
<p><img src="image-20230403103009826.png" alt="image-20230403103009826"></p>
<p>意思是找不到匹配的构造函数，说明在使用构造函数创建bean的时候，默认的无参构造被覆盖了，只要重写一遍无参构造即可。</p>
</blockquote>
<ul>
<li><p>配置中使用<code>constructor-arg</code>标签注入简单类型对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="image-20230403103438223.png" alt="image-20230403103438223" style="zoom:80%;" /></li>
</ul>
<p><strong>依赖注入 小结</strong></p>
<ul>
<li><p>强制依赖（强制依赖指对象在创建的过程中必须要注入指定的参数）使用构造器进行；可选依赖（可选依赖指对象在创建过程中注入的参数可有可无）使用setter注入进行，灵活性强。</p>
</li>
<li><p>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨；实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入。</p>
</li>
<li><p>自己开发的模块推荐使用setter注入（推荐setter）。</p>
</li>
</ul>
<h2 id="依赖自动装配"><a href="#依赖自动装配" class="headerlink" title="依赖自动装配"></a>依赖自动装配</h2><p>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配，从而简化配置文件的配置编写。</p>
<p>自动装配只需要修改applicationContext.xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- autowire属性：开启自动装配，通常使用按类型装配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用自动装配需要注意的点：① 需要注入属性的类中对应属性的setter方法不能省略；② 被注入的对象必须要被Spring的IOC容器管理；③ 按照类型装配在Spring的IOC容器中只能有该类型的唯一对象。</p>
</blockquote>
<p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入：<code>autowire=&quot;byName&quot;</code>.</p>
<p><strong>自动装配</strong></p>
<ul>
<li><p>自动装配用于引用类型依赖注入，不能对简单类型进行操作。</p>
</li>
<li><p>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用；使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用。</p>
</li>
<li><p>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效。</p>
</li>
</ul>
<h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型集合，集合中既可以装简单数据类型也可以装引用数据类型，在Spring中该如何注入呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的所以配置方式，都是在userDao的bean标签中使用<property>进行注入：</p>
<p>注入数组类型数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注入List类型数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhongguo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>shandong<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qingdao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注入Set类型数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhongguo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>shandong<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qingdao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qingdao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注入Map类型数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注入Properties类型数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="image-20230403112041440.png" alt="image-20230403112041440" style="zoom:80%;" />

<blockquote>
<ul>
<li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li>
<li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li>
</ul>
</blockquote>
<h1 id="IOC-DI配置管理第三方bean"><a href="#IOC-DI配置管理第三方bean" class="headerlink" title="IOC/DI配置管理第三方bean"></a>IOC/DI配置管理第三方bean</h1><p>前面的配置都是基于我们自己写的类，那么该如何管理第三方jar包中的类？</p>
<h2 id="数据源对象管理"><a href="#数据源对象管理" class="headerlink" title="数据源对象管理"></a>数据源对象管理</h2><p>以后我们会用到很多第三方的bean，下面将使用数据源Druid和C3P0来学习配置。</p>
<h3 id="实现Druid管理"><a href="#实现Druid管理" class="headerlink" title="实现Druid管理"></a>实现Druid管理</h3><ul>
<li><p>导入最新版的Druid依赖坐标和mysql坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在配置文件中配置第三方bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 管理Druid对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- setter配置属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Druid对象通过setter注入依赖，是因为在对象的上层类DruidDataSource中提供了属性的set方法。</p>
</blockquote>
<ul>
<li>从IOC容器中获取对应的bean对象(DruidDataSource)</li>
</ul>
<h3 id="实现C3P0管理"><a href="#实现C3P0管理" class="headerlink" title="实现C3P0管理"></a>实现C3P0管理</h3><ul>
<li><p>导入最新版的C3P0坐标和mysql坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在配置文件中配置第三方bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 管理c3p0对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Druid和C3P0在没有导入mysql驱动包的前提下虽然没有报错，说明在初始化的时候没有去加载驱动，但是在获取数据库连接的时候，也会报找不到驱动类的错误，所以在导入依赖坐标的时候除了导入数据库连接池的坐标外还要导入mysql的坐标。</p>
</blockquote>
<h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护，需要将这些值提取到一个外部的properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。</p>
<ul>
<li><p>resources下创建一个<code>jdbc.properties</code>文件（名字任意），并添加对应的属性键值对：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">12345</span></span><br></pre></td></tr></table></figure></li>
<li><p>开启 <code>context</code> 命名空间</p>
<img src="image-20230404102716578.png" alt="image-20230404102716578" style="zoom:67%;" />

<p>直接copy配置文件中bean的命名空间并修改这5处为：<code>context</code>即可。</p>
</li>
<li><p>加载properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用context命名空间下的标签来加载properties配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>完成属性注入</p>
<img src="image-20230404103018660.png" alt="image-20230404103018660" style="zoom: 50%;" />

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><code>&lt;context:property-placeholder/&gt;</code>标签会加载系统的环境变量，而且环境变量的值会被优先加载，可以在该标签上增添属性<code>system-properties-mode=&quot;NEVER&quot;</code>避免加载系统环境变量。</p>
</blockquote>
<p><strong>加载多个properties文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式三是标准的写法，<code>classpath:</code>代表的是从根路径下开始查找，但是只能查询当前项目的根路径；方式四不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件。</p>
<h1 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h1><p>讲完bean与依赖注入，接下来我们主要学习的是IOC容器中的核心容器。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="创建核心容器"><a href="#创建核心容器" class="headerlink" title="创建核心容器"></a>创建核心容器</h3><ul>
<li><p>类路径下的XML配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>文件系统下的XML配置文件（从项目路径下开始查找，不推荐使用）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;applicationContext.xml的绝对路径&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="获取Bean的三种方式"><a href="#获取Bean的三种方式" class="headerlink" title="获取Bean的三种方式"></a>获取Bean的三种方式</h3><ul>
<li><p>方式1：每次获取的时候都需要进行类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;UserDao&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>方式2：可以解决类型强转问题，但是加了一个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;UserDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure></li>
<li><p>方式3：按class类型获取bean，必须要确保IOC容器中该类型对应的bean对象只能有一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>容器的最上级的父接口为<code>BeanFactory</code>，可以使用BeanFactory来创建IOC容器。</p>
<p>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建；ApplicationContext是立即加载，容器加载的时候就会创建bean对象。ApplicationContext要想成为延迟加载，只需要在配置文件中配置<code>lazy-init=&quot;true&quot;</code>。</p>
<h2 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h2><p><strong>容器</strong></p>
<ul>
<li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载；ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载。</li>
<li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li>
<li>ApplicationContext接口常用初始化类：<code>ClassPathXmlApplicationContext</code></li>
</ul>
<p><strong>bean</strong></p>
<img src="image-20230404113815759.png" alt="image-20230404113815759" style="zoom: 50%;" />

<p>整个配置最常用的就两个属性：<code>id</code>和<code>class</code>。</p>
<p><strong>依赖注入</strong></p>
<img src="image-20230404113923632.png" alt="image-20230404113923632" style="zoom: 67%;" />
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>01_JDBC</title>
    <url>/2023/03/28/01-JDBC/</url>
    <content><![CDATA[<p>​        现在企业早就不使用这种繁琐的技术了，但是学过了<code>JDBC</code>才能更好的理解后面的开发框架。</p>
<span id="more"></span>

<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>​        JDBC是一款使用 Java语言赖操作关系型数据库的一套API；它为不同的关系型数据库提供了一套标准的API接口。</p>
<img src="image-20230325094653057.png" alt="image-20230325094653057" style="zoom:50%;" />

<h2 id="JDBC快速入门"><a href="#JDBC快速入门" class="headerlink" title="JDBC快速入门"></a>JDBC快速入门</h2><p>（1）导入驱动包：操作哪个关系型数据库就需要导入该数据库的驱动包。将mysql驱动包放在模块的<code>lib</code>目录下，并添加为库文件；</p>
<blockquote>
<p>mysql驱动jar包下载地址：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a></p>
</blockquote>
<p>（2）代码步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">// 注册驱动(可省略)</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">// 定义mysql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update tb_user set password = &#x27;20221&#x27; where username=&#x27;ljc&#x27;;&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取执行sql对象Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// statement执行sql语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> statement.executeUpdate(sql);  <span class="comment">// 数据库增删改操作返回的都是受影响的行数，int类型</span></span><br><span class="line">        <span class="comment">// 返回处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>1、<code>DriverManager</code>驱动管理类</p>
<ul>
<li><p>注册驱动 （mysql5自动注册）</p>
</li>
<li><p>获取数据库的连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2、<code>Connection</code>数据库连接对象</p>
<ul>
<li><p>获取执行sql的statement对象</p>
<ul>
<li><p>普通执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure></li>
<li><p>预编译执行 – 防止sql注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.prepareStatement(sql);  <span class="comment">// 预编译直接将sql语句传进来</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>事务管理</p>
<blockquote>
<p>Mysql事务管理(mysql中默认自动提交): ①开启事务：Begin; 或 Transaction;  ②提交事务：Commit;   ③回滚事务：Rollback;</p>
</blockquote>
<p><code>Connection</code>中定义了3个对应的方法：</p>
<ul>
<li><p>开启事务：true表示自动提交事务，false表示手动提交事务，而开启事务需要将该参数设为为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn.commit();</span><br></pre></td></tr></table></figure></li>
<li><p>回滚事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>事务管理的意义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ============开启事务==========</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> stmt.executeUpdate(sql1);</span><br><span class="line">        <span class="comment">//6. 处理结果</span></span><br><span class="line">        System.out.println(count1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> stmt.executeUpdate(sql2);</span><br><span class="line">        <span class="comment">//6. 处理结果</span></span><br><span class="line">        System.out.println(count2);    </span><br><span class="line">        <span class="comment">// ============提交事务==========</span></span><br><span class="line">        <span class="comment">//程序运行到此处，说明没有出现任何问题，则需求提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ============回滚事务==========</span></span><br><span class="line">        <span class="comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span></span><br><span class="line">        conn.rollback();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、<code>Statement</code>对象</p>
<p>​        用来执行sql代码。</p>
<ul>
<li><p>执行数据增删改以及数据库、表、列的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> statement.excuteUpdate(sql);</span><br></pre></td></tr></table></figure></li>
<li><p>表中查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4、<code>ResultSet</code>结果集对象</p>
<p>​        封装了sql查询语句的结果。</p>
<p>​        遍历查询结果中所有数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line">   <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">       <span class="comment">// 2 获取数据  getXxx()</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">       System.out.println(id);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       System.out.println(money);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>5、<code>PreparedStatement</code>对象</p>
<p>​        预编译sql语句并执行，防止sql注入。</p>
<blockquote>
<p>sql注入：通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p>
</blockquote>
<ul>
<li><p>模拟sql注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xxxxxx&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的sql代码是将name和pwd拼接而成的，拼接后的sql代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from tb_user <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&#x27;xxxxxx&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>PreparedStatement</code></p>
<p>先前使用<code>Statement</code>对象执行sql代码的步骤：</p>
<p> ① 定义参数以及sql语句</p>
<p> ② <code>statement.executeUpdate(sql)</code>执行</p>
<p><strong>使用<code>PreparedStatement</code>预编译执行步骤：</strong></p>
<p> ① 定义sql语句，占位符用 ‘?’代替</p>
<p> ② <code>pstmt</code>对象设置 ‘?’ 参数指代的值： <code>pstmt.setString(index,参数);</code></p>
<p> ③ <code>pstmt.executeUpdate();</code>执行，这里注意不需要传入sql语句了，因为在定义<code>pstmt</code>对象的时候已经传入sql语句进行预编译了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">textPreparedStatement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册驱动(可省略)</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line">        pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>,pwd);</span><br><span class="line">  </span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        resultSet.close();</span><br><span class="line">        pstmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>6、<code>PreparedStatement</code>原理</p>
<p>​    开启预编译：在url中加入参数：<code>useServerPrepStmts=true</code>;</p>
<p>​    好处：① 预编译，性能更高； ② 防止sql注入</p>
<img src="image-20230325160120135.png" alt="image-20230325160120135" style="zoom:50%;" />

<p>​        在获取<code>PreparedStatement</code>对象时，将sql语句发送给mysql服务器进行检查、编译（这些步骤很耗时），执行时就不用再进行这些步骤了，速度更快。</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>​        数据库连接池（Connection Pool）是一种复用 Connection 的组件，它可以避免反复创建新连接，提高JDBC代码的运行效率。</p>
<p>​        在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池复用已经创建好的连接。</p>
<p>​                                               <img src="image-20230325160719950.png" alt="image-20230325160719950" style="zoom:50%;" /></p>
<h3 id="数据库连接池的实现"><a href="#数据库连接池的实现" class="headerlink" title="数据库连接池的实现"></a>数据库连接池的实现</h3><p>​        标准接口：<code>DataSource</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">datasource</span> <span class="operator">=</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>​        不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p>
<p><code>Druid</code>数据连接池 – alibaba</p>
<ul>
<li><p>导入jar包：下载地址 <a href="https://repo1.maven.org/maven2/com/alibaba/druid/">https://repo1.maven.org/maven2/com/alibaba/druid/</a></p>
</li>
<li><p>编写配置文件<code>druid.properties</code></p>
</li>
</ul>
<img src="image-20230325162515349.png" alt="image-20230325162515349" style="zoom:50%;" />

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testDruid</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定义配置文件</span></span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/druid.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据库连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection); <span class="comment">//获取到了连接后就可以继续做其他操作了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(System.getProperty(&quot;user.dir&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Druid</code>连接池配置成功：</p>
<img src="image-20230325162717690.png" alt="image-20230325162717690" style="zoom:67%;" />
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>01-MySQL基础</title>
    <url>/2023/07/07/01-MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Mysql是一种关系型数据库，这篇博客作为数据库的基础篇主要讲解操作关系型数据的SQL编程语言。</p>
<span id="more"></span>

<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><img src="image-20230708120214301.png" alt="image-20230708120214301"></p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是数据库中数据的存储方式，是数据库系统的基础。</p>
<img src="image-20230708120103005.png" alt="image-20230708120103005" style="zoom:77%;" />

<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><ul>
<li><p>数据库操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">create</span> database 数据库名;</span><br><span class="line">use 数据库名;</span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br></pre></td></tr></table></figure></li>
<li><p>表操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (字段 字段类型, 字段 字段类型...);</span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="operator">/</span> modify <span class="operator">/</span> change <span class="operator">/</span> <span class="keyword">drop</span> <span class="operator">/</span> rename <span class="keyword">to</span> ...;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>

<p>创建数据表时要指定字段的数据类型，SQL的<strong>数据类型</strong>是很重要的知识点：</p>
<ul>
<li><p>数值类型</p>
<p><img src="image-20230708115522222.png" alt="image-20230708115522222"></p>
</li>
<li><p>字符串类型</p>
<p><img src="image-20230708115834511.png" alt="image-20230708115834511"></p>
<p><code>varchar</code>类型会先计算数据所占用的存储空间，所以性能相对<code>char</code>会差一些。<code>varchar</code>用来存储变长字符串，<code>char</code>用来存储定长字符串。</p>
</li>
<li><p>日期时间类型</p>
<p><img src="image-20230708120001012.png" alt="image-20230708120001012"></p>
</li>
</ul>
</li>
</ul>
<h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><ul>
<li><p>添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)[, (值<span class="number">1</span>, 值<span class="number">2</span>, ...),...];</span><br></pre></td></tr></table></figure></li>
<li><p>修改数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 字段<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2.</span>.. [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名列表 <span class="keyword">where</span> 条件列表 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段列表 <span class="keyword">having</span> 分组后条件列表 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段列表 limit 分页参数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基本查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> [<span class="keyword">as</span> 别名], 字段<span class="number">2</span> [<span class="keyword">as</span> 别名]... <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li><p>条件查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20230707182551496.png" alt="image-20230707182551496"></p>
<ul>
<li><p>聚合函数</p>
<p>将一列数据作为一个整体，进行纵向计算。</p>
<blockquote>
<p>null值不参与所有聚合函数运算。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数(字段列表) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure>

<img src="image-20230707182712652.png" alt="image-20230707182712652" style="zoom:87%;" /></li>
<li><p>分组查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组过滤后的条件];</span><br></pre></td></tr></table></figure>

<p>where 与 having 的区别：</p>
<p>① 执行时机不同：where 是分组之前进行过滤，不满足 where 条件是不参与 group by 分组的；而 having 是分组之后的条件对结果进行过滤；</p>
<p>② 判断条件不同：where 是不能对聚合函数进行判断，而 having 可以。</p>
<blockquote>
<p>执行顺序：where &gt; 聚合函数 &gt; having</p>
<p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 </p>
</blockquote>
</li>
<li><p>排序查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span> ...;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ASC</code>：升序（默认值）</li>
<li><code>DESC</code>：降序</li>
</ul>
</li>
<li><p>分页查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 limit 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>起始索引从0开始，<code>起始索引 = (查询页码 - 1) * 每页显示记录数</code>；</p>
</li>
<li><p>分页查询是数据库的“方言”；</p>
</li>
<li><p>如果查询的是第一页的数据，起始索引可以省略，直接简写为<code>limit 10</code>。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>DQL语句执行顺序</strong></p>
<p>可以通过起别名的方式验证sql的执行顺序。</p>
<img src="image-20230707184905294.png" alt="image-20230707184905294" style="zoom:87%;" />

<h3 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h3><p>用来管理数据库用户，控制数据库的访问权限等。这类 SQL 开发人员操作较少，主要是 DBA 数据库管理员使用。</p>
<ul>
<li><p>管理用户</p>
<ul>
<li><p>查询用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
<li><p> 创建用户</p>
</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改用户密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>删除用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>权限控制</p>
<img src="image-20230707190503318.png" alt="image-20230707190503318" style="zoom:87%;" />

<ul>
<li><p>查询权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>授予权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>撤销权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><img src="image-20230707212720328.png" alt="image-20230707212720328" style="zoom:77%;" />

<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p><img src="image-20230707213014115.png" alt="image-20230707213014115"></p>
<p>练习：通过数据库内置函数，生成6位验证码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>, <span class="number">0</span>), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><img src="image-20230707213605363.png" alt="image-20230707213605363" style="zoom:87%;" />

<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>在sql语句中实现条件筛选，提高语句的效率。</p>
<img src="image-20230707214051312.png" alt="image-20230707214051312" style="zoom:87%;" />

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束是作用于表中字段的规则，用于限制存储在表中的数据，可以在创建表或修改表的时候添加约束。目的是保证数据库中数据的正确、有效性和完整性。</p>
<h3 id="约束分类"><a href="#约束分类" class="headerlink" title="约束分类"></a>约束分类</h3><img src="image-20230707214947434.png" alt="image-20230707214947434" style="zoom:87%;" />

<blockquote>
<p>自增：<code>auto_increment</code> . 当插入一条数据失败时，这时候这条未插入的数据已经向数据库申请了自增的字段值。</p>
</blockquote>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键是用来让两张表的数据相互建立连接，从而保证数据的一致性和完整性的。</p>
<p>下面的两张表，仅存在逻辑上的关系，在数据库层面并未建立外键关联，所以是无法保证数据的一致性和完整性的。</p>
<p><img src="image-20230707220102885.png" alt="image-20230707220102885"></p>
<p>添加外键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br></pre></td></tr></table></figure>

<p>删除外键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 外键名称;</span><br></pre></td></tr></table></figure>

<p>删除/更新行为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(主表列名) <span class="keyword">on</span> <span class="keyword">update</span> 行为 <span class="keyword">on</span> <span class="keyword">delete</span> 行为;</span><br></pre></td></tr></table></figure>

<img src="image-20230707223539126.png" alt="image-20230707223539126" style="zoom:87%;" />

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul>
<li>一对多</li>
</ul>
<p>一个部门对应多个员工，一个员工对应一个部门。<strong>在多的一方建立外键，指向一的一方的主键。</strong></p>
<img src="image-20230708095445790.png" alt="image-20230708095445790" style="zoom:87%;" />

<ul>
<li>多对多</li>
</ul>
<p>一个学生可以选修多门课程，一门课程可以被多个学生选择。<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。</strong></p>
<img src="image-20230708095651147.png" alt="image-20230708095651147" style="zoom:87%;" />

<ul>
<li>一对一</li>
</ul>
<p>用户与用户详情的关系。多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率。<strong>在任意一方加入外键，关联另一方的主键，并且设置外键是唯一的(UNIQUE) – 保证一对一。</strong></p>
<img src="image-20230708100105054.png" alt="image-20230708100105054" style="zoom:87%;" />

<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>查询的是两张表交集的部分。</p>
<ul>
<li><p>隐式内连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">where</span> 条件...;</span><br></pre></td></tr></table></figure></li>
<li><p>显式内连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件...;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul>
<li><p>左外连接：相当于查询表1（左表）的所有数据（包含表1和表2交集部分）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure></li>
<li><p>右外连接：相当于查询表2（右表）的所有数据（包含表1和表2交集部分）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>可以是内连接查询，也可以是外连接查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表A 别名B <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>

<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>把多次查询的结果合并起来，形成一个新的查询结果集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A <span class="keyword">union</span> [<span class="keyword">all</span>] <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B;</span><br></pre></td></tr></table></figure>

<p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致；<code>union</code>是将结果合并后去重，<code>union all</code>是只将结果合并。</p>
<h4 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> column1 <span class="operator">=</span> (<span class="keyword">select</span> column1 <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure>

<p>根据子查询的结果不同分为：标量子查询、列子查询、行子查询、表子查询。</p>
<ul>
<li><p>标量子查询：<code>&gt;</code>, <code>&lt;</code>, <code>=</code>…</p>
</li>
<li><p>列子查询：<code>in</code>, <code>all</code>, <code>any</code>…</p>
</li>
<li><p>行子查询：<code>in</code>, <code>not in</code>, <code>=</code>, <code>&lt;&gt;</code></p>
</li>
<li><p>表子查询：<code>in</code></p>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功、要么同时失败。<strong>保证数据的正确性和完整性。</strong></p>
<p><font color="blue">默认MySQL的事务是自动提交的，也就是说当执行一条DML语句后，MySQL会立即隐式的提交事务。</font>（开启事务 → 提交/回滚事务）</p>
<h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><ul>
<li><p>方式一</p>
<ul>
<li><p>查看/设置事务提交方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>提交事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>回滚事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p> 方式二</p>
</li>
</ul>
<p>  开启事务后，必须手动<code>commit</code>提交事务（否则数据是不会在表中变化的），或者<code>rollback</code>回滚事务，才能结束这个事务。一旦事务提交，则其所做的修改就会永久保存到数据库中。</p>
<ul>
<li><p>开启事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>提交事务</p>
</li>
<li><p>回滚事务</p>
</li>
</ul>
<h3 id="事务四大特性（面试题）"><a href="#事务四大特性（面试题）" class="headerlink" title="事务四大特性（面试题）"></a>事务四大特性（面试题）</h3><p><img src="image-20230708112047747.png" alt="image-20230708112047747"></p>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul>
<li><p>脏读</p>
<p>一个事务读到另一个事务还没有提交的数据。</p>
<p><font color="red">Question：在事务没提交前更改的数据信息，保存在数据库的什么位置？</font></p>
<img src="image-20230708112301432.png" alt="image-20230708112301432" style="zoom:87%;" /></li>
<li><p>不可重复读</p>
<p>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p>
<img src="image-20230708112746185.png" alt="image-20230708112746185" style="zoom:87%;" /></li>
<li><p>幻读</p>
<p>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了。</p>
<img src="image-20230708112946935.png" alt="image-20230708112946935" style="zoom:87%;" /></li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务的隔离级别是为了解决并发事务问题。设计数据库时需要衡量数据库的安全级别和并发性能。</p>
<img src="image-20230708113411288.png" alt="image-20230708113411288" style="zoom:87%;" />
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>02_Maven</title>
    <url>/2023/03/28/02-Maven/</url>
    <content><![CDATA[<p>Maven是专门用于管理和构建Java项目的工具。</p>
<span id="more"></span>

<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>他的主要功能有：</p>
<p>提供一套<strong>标准化的项目结构：</strong></p>
<p>​        所有的IDE使用Maven构建的项目完全一样，IDE创建的Maven项目可以通用。如下图就是Maven构建的项目结构：</p>
<img src="image-20230325163946659.png" alt="image-20230325163946659" style="zoom: 50%;" />

<p><strong>标准化的构建流程：</strong></p>
<img src="image-20230325164020995.png" alt="image-20230325164020995" style="zoom: 67%;" />

<p>​        代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p>
<p><strong>依赖管理：</strong></p>
<p>​        依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。</p>
<p>​        而Maven使用标准的 <strong>坐标</strong> 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p>
<h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="Maven模型"><a href="#Maven模型" class="headerlink" title="Maven模型"></a>Maven模型</h3><img src="image-20230325165659563.png" alt="image-20230325165659563" style="zoom:67%;" />

<p>​        紫色框框起来的部分，他就是用来完成<strong>标准化构建流程</strong> 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。</p>
<p>​                                           <img src="image-20230325165737480.png" alt="image-20230325165737480" style="zoom: 67%;" /></p>
<p>​        上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标。依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>​        我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p>
<p><strong>仓库分类：</strong></p>
<ul>
<li><p>本地仓库：自己计算机上的一个目录</p>
</li>
<li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p>
<ul>
<li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li>
</ul>
</li>
<li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p>
<p>​        我们在使用坐标指定项目依赖时，如果是之前使用过的依赖，那么它在本地仓库中（你电脑上设置的maven本地仓库目录）就存在，直接从本地拿；如果是第一次导入该依赖，会先从远程仓库中找，再从中央仓库中找，把相应的jar包下载到本地仓库中，再导入maven项目中。</p>
</li>
</ul>
<img src="image-20230328095806245.png" alt="image-20230328095806245" style="zoom: 67%;" />

<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>1、配置本地仓库</p>
<p>​        修改 conf/settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。        </p>
<p><img src="image-20230325170948329.png" alt="image-20230325170948329"></p>
<p>2、配置私服</p>
<p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p>
<p>修改 conf/settings.xml 中的 <mirrors>标签。</p>
<img src="image-20230325171049898.png" alt="image-20230325171049898" style="zoom: 67%;" />

<h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。</p>
<p>Maven 对项目构建的生命周期划分为3套，默认(default)生命周期如下：</p>
<img src="image-20230325171645821.png" alt="image-20230325171645821" style="zoom: 67%;" />

<p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。</p>
<h2 id="Maven使用"><a href="#Maven使用" class="headerlink" title="Maven使用"></a>Maven使用</h2><h3 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h3><p>坐标是Maven项目资源的唯一标识，用坐标来定义项目或引入项目中需要的依赖。</p>
<p>Maven坐标组成：</p>
<ul>
<li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写）</li>
<li>artifactId：定义当前Maven项目名称</li>
<li>version：定义当前项目版本号</li>
</ul>
<img src="image-20230325172258113.png" alt="image-20230325172258113" style="zoom:67%;" />

<blockquote>
<p>上述的资源坐标可以指项目、依赖、插件。当我们的项目被作为其他项目的依赖时，也是需要坐标来导入的。</p>
</blockquote>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在项目的 pom.xml 中编写 <dependencies> 标签，在子标签 <dependencie> 中定义坐标的 groupId，artifactId，version。具体的坐标可以在<a href="https://mvnrepository.com/%E4%B8%8A%E6%9F%A5%E6%89%BE%E3%80%82">https://mvnrepository.com/上查找。</a></p>
<blockquote>
<p>快捷方式：Alt+Fn+Insert导入常用依赖。</p>
</blockquote>
<p>​                                                                        <font color="blue">（我的评价是不如Springboot！！！）</font></p>
<p><strong>依赖范围：</strong> </p>
<p>通过设置坐标的依赖范围<scope>，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p>
<table>
<thead>
<tr>
<th><strong>依赖范围</strong></th>
<th>编译classpath</th>
<th>测试classpath</th>
<th>运行classpath</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><strong>compile</strong></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>logback</td>
</tr>
<tr>
<td><strong>test</strong></td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td><strong>provided</strong></td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td><strong>runtime</strong></td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>jdbc驱动</td>
</tr>
<tr>
<td><strong>system</strong></td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>存储在本地的jar包</td>
</tr>
</tbody></table>
<blockquote>
<p>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>02_Mybatis</title>
    <url>/2023/03/28/02-Mybatis/</url>
    <content><![CDATA[<p>Mybatis是一款很重要的开发框架！</p>
<span id="more"></span>

<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>​        MyBatis 是一款优秀的<strong>持久层框架</strong>，用于简化 JDBC 开发。</p>
<blockquote>
<p><strong>持久层：</strong>负责将数据到保存到数据库的那一层代码。开发中我们会将操作数据库的Java代码作为持久层，而Mybatis就是对jdbc代码进行了封装。（JavaEE三层架构：表现层、业务层、持久层）</p>
</blockquote>
<h3 id="JDBC缺点"><a href="#JDBC缺点" class="headerlink" title="JDBC缺点"></a>JDBC缺点</h3><img src="image-20230325185145333.png" alt="image-20230325185145333" style="zoom:67%;" />

<ul>
<li><p>硬编码</p>
<ul>
<li><p>注册驱动、获取连接</p>
<p>上图①的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</p>
</li>
<li><p>SQL语句</p>
<p>上图②的代码。如果表结构发生变化，SQL语句就要进行更改，这也不方便后期的维护。</p>
</li>
</ul>
</li>
<li><p>操作繁琐</p>
<ul>
<li><p>手动设置参数</p>
</li>
<li><p>手动封装结果集</p>
<p>上图④的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Mybatis的优化"><a href="#Mybatis的优化" class="headerlink" title="Mybatis的优化"></a>Mybatis的优化</h3><ul>
<li>硬编码可以配置到配置文件</li>
<li>操作繁琐的地方mybatis都自动完成</li>
</ul>
<h2 id="Mybatis快速入门"><a href="#Mybatis快速入门" class="headerlink" title="Mybatis快速入门"></a>Mybatis快速入门</h2><p>1、在<code>pom.xml</code>中导入依赖坐标</p>
<p>至少需要：Mybatis、Mysql依赖</p>
<p>直接去找：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<p>2、编写<code>Mybatis</code>核心配置文件</p>
<p>在模块下的<code> resources</code> 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、编写sql映射文件（统一管理sql语句，解决硬编码问题）</p>
<p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;usermapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.Lijiacheng.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、编码</p>
<ul>
<li><p>在<code>pojo</code>包下创建<code>User</code>的javaBean类。</p>
</li>
<li><p>创建测试类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//2. 获取sqlSession对象，用来执行sql语句</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;usermapper.selectAll&quot;</span>);  <span class="comment">//该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Mybatis的硬编码配置都可以在官方文档中找到：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p>
</blockquote>
<h2 id="Mybatis代理开发"><a href="#Mybatis代理开发" class="headerlink" title="Mybatis代理开发"></a>Mybatis代理开发</h2><h3 id="代理开发概述"><a href="#代理开发概述" class="headerlink" title="代理开发概述"></a>代理开发概述</h3><p>之前使用Mybatis的时候也存在硬编码问题：</p>
<p><img src="image-20230325192705282.png" alt="image-20230325192705282"></p>
<p>这里调用 <code>selectList()</code> 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式则不存在硬编码问题：</p>
<img src="image-20230326141250750.png" alt="image-20230326141250750" style="zoom:67%;" />

<p>通过上面的描述可以看出 Mapper 代理方式的目的：</p>
<ul>
<li>解决原生方式中的硬编码</li>
<li>简化后期执行SQL</li>
</ul>
<h3 id="使用Mapper代理开发"><a href="#使用Mapper代理开发" class="headerlink" title="使用Mapper代理开发"></a>使用Mapper代理开发</h3><ul>
<li>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</li>
</ul>
<img src="image-20230326133634591.png" alt="image-20230326133634591" style="zoom: 67%;" />

<ul>
<li>设置SQL映射文件的namespace属性为<strong>Mapper接口全限定名</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.Lijiacheng.mapper.UserMapper&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 Mapper 接口中定义方法，方法名就是<strong>SQL映射文件中sql语句的id</strong>，并保持参数类型和返回值类型一致</li>
</ul>
<img src="image-20230325194636891.png" alt="image-20230325194636891" style="zoom:67%;" />

<p>​    在接口声明相应函数后，点击左侧<code>mapper</code>小图标可以跳转到xml映射文件相应id的sql语句上。</p>
<img src="image-20230326133752273.png" alt="image-20230326133752273" style="zoom:67%;" />

<ul>
<li>测试类中内容：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo_Mapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//2. 获取sqlSession对象，用来执行sql语句</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 获取接口代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">usermapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = usermapper.selectAll();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，使用Mapper代理的方法，在<code>mapper</code>接口和<code>sql映射文件</code>同名的前提下，可以在<code>mybatis</code>核心配置文件中通过包扫描的方式简化sql映射文件的加载。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;mapper resource=&quot;com/Lijiacheng/mapper/UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Mapper代理方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h2><p><strong>类型别名</strong></p>
<p>在sql映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p>
<p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），<font color="red">不区分大小写</font>。内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name属性的值是实体类所在包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.pojo&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 如果没配置&lt;typeAliases&gt;的话，必须是类的全限定名 --&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后我们总结一下<code>Mybatis</code>进行代理开发的流程：</p>
<p>1、首先和入门的开发流程相同，需要进行核心配置文件的配置、以及在<code>resource</code>目录下创建sql映射文件。</p>
<p>核心配置文件可以从mybatis官网上直接copy：<a href="https://mybatis.org/mybatis-3/zh/%EF%BC%88%E6%88%91%E5%B1%85%E7%84%B6%E5%9C%A8%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%8A%E6%89%BE%E4%B8%8D%E5%88%B0%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%EF%BC%89">https://mybatis.org/mybatis-3/zh/（我居然在谷歌搜索引擎上找不到，这里记录一下）</a></p>
<p>配置文件需要注意的两个点，如下图：</p>
<p><img src="image-20230326142309667.png" alt="image-20230326142309667"></p>
<ul>
<li><p>配置类型别名，简化sql映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.pojo&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>加载sql映射配置时进行包扫描（特别是在以后开发中有多个sql映射文件时）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--Mapper代理方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.mapper&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>sql映射文件需要注意的几个点：</p>
<p><img src="image-20230326143114568.png" alt="image-20230326143114568"></p>
<ul>
<li><p><code>namespace</code>属性对应的是<code>mapper</code>目录下的mapper接口</p>
</li>
<li><p><code>id</code>属性对应的是接口中声明的方法，这里的<font color='red'><code>id</code>属性要和<code>接口方法名</code>一致！</font></p>
</li>
<li><p><code>resultType</code>属性可以直接使用别名，习惯上直接用实体类名即可（前提要配置类型别名）</p>
</li>
</ul>
<p>2、在<code>mapper</code>目录下创建和sql映射文件同名的mapper接口，声明方法</p>
<p>3、实体类一定要有啊，这个不用说了</p>
<p>4、测试类前面也是一样的，唯一不同的就是需要获取一个接口代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">usermapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure>

<p>通过这个对象可以调用接口中声明的函数，接口中的函数和sql映射文件中的id值相同，这样就找到了需要执行的sql语句，这样就可以操作数据库了，并通过你调用的函数返回结果。</p>
<blockquote>
<p>还有一个比较重要的点：</p>
<p>当你Bean类中的成员变量和操作数据库的数据名不同时，如何产生映射关系。这个放在后面的帖子里记录会比较容易懂。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>02-RESTful开发</title>
    <url>/2023/06/13/02-RESTful%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>REST（Representational State Transfer），表现形式状态转换，它是一种软件架构风格，听不懂很正常。说通俗点就是用URL定位资源，用HTTP动词（GET, POST, DELETE, PUT）描述操作的一种开发方式。</p>
<span id="more"></span>

<h2 id="REST简介"><a href="#REST简介" class="headerlink" title="REST简介"></a>REST简介</h2><p>当我们想表示一个网络资源的时候，可以使用两种方式：</p>
<p>（1）传统风格资源描述形式</p>
<p>​    ① <a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a> 查询id为1的用户信息</p>
<p>​    ② <a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a> 保存用户信息</p>
<p>（2）REST风格描述形式</p>
<p>​    ① <a href="http://localhost/users/1">http://localhost/users/1</a> </p>
<p>​    ② <a href="http://localhost/users">http://localhost/users</a></p>
<p>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全，因为会程序的人读取了你的请求url地址，就大概知道该url实现的是一个什么样的操作。</p>
<p>所以REST的优点有:</p>
<ul>
<li><p>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</p>
</li>
<li><p>书写简化</p>
</li>
</ul>
<p>那么对于REST来说，一个相同的url地址即可以是新增也可以是修改或者查询，那么到底我们该如何区分该请求到底是什么操作呢?</p>
<p>按照REST风格访问资源时使用的<strong>行为动作</strong>（一共有8种，常用的只有以下4种）区分对资源进行了何种操作：</p>
<ul>
<li><p><a href="http://localhost/users">http://localhost/users</a> 查询全部用户信息 <code>GET</code>（查询）</p>
</li>
<li><p><a href="http://localhost/users/1">http://localhost/users/1</a> 查询指定用户信息 <code>GET</code>（查询）</p>
</li>
<li><p><a href="http://localhost/users">http://localhost/users</a> 添加用户信息 <code>POST</code>（新增/保存）</p>
</li>
<li><p><a href="http://localhost/users">http://localhost/users</a> 修改用户信息 <code>PUT</code>（修改/更新）</p>
</li>
<li><p><a href="http://localhost/users/1">http://localhost/users/1</a> 删除用户信息 <code>DELETE</code>（删除）</p>
</li>
</ul>
<p>按照不同的请求方式代表不同的操作类型：发送GET请求是用来做查询；发送POST请求是用来做新增；发送PUT请求是用来做修改；发送DELETE请求是用来做删除。</p>
<blockquote>
<p>REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性。</p>
<p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范。REST中规定GET/POST/PUT/DELETE针对的是查询/新增/修改/删除，但是我们如果非要用GET请求做删除，这点在程序上运行是可以实现的，但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。</p>
</blockquote>
<p>根据REST风格对资源进行访问称为<strong>RESTful</strong>，所以可以说以后都是基于RESTful来进行开发的。</p>
<h2 id="RESTful入门案例"><a href="#RESTful入门案例" class="headerlink" title="RESTful入门案例"></a>RESTful入门案例</h2><p><strong>环境准备</strong></p>
<img src="image-20230618093614185.png" alt="image-20230618093614185" style="zoom:87%;" />

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>将之前的增删改查替换成RESTful开发方式：</p>
<ul>
<li><p>之前不同的请求有不同的路径，现在要将其修改成统一的请求路径</p>
<p>修改前：新增: /save ，修改: /update，删除 /delete …</p>
<p>修改后：增删改查: /users</p>
</li>
<li><p>根据GET查询、POST新增、PUT修改、DELETE删除对方法的请求方式进行限定</p>
</li>
</ul>
<h3 id="修改RESTful风格"><a href="#修改RESTful风格" class="headerlink" title="修改RESTful风格"></a>修改RESTful风格</h3><p><strong>新增</strong></p>
<p>请求路径更改为<code>/users</code>，并且使用method属性限定该方法的访问方式为POST：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前请求方法为POST，表示REST风格中的添加操作</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user save...&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<p>对于RESTful开发，如何携带数据参数？</p>
<p>前端发送请求的时候使用：<a href="http://localhost/users/1">http://localhost/users/1</a> ，路径中的1就是我们想要传递的参数。</p>
<p>后端获取参数，需要做如下修改：① 修改<code>@RequestMapping</code>的value属性，将其中修改为<code>/users/&#123;id&#125;</code>，目的是和路径匹配；② 在方法的形参前添加<code>@PathVariable</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前请求方法为DELETE，表示REST风格中的删除操作</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//    public String delete(@PathVariable(&quot;id&quot;) Integer userid)&#123;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果方法形参的名称和路径{}中的值不一致：</p>
<img src="image-20230618112603915.png" alt="image-20230618112603915" style="zoom:67%;" />

<p>如果有多个参数需要传递该如何编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,<span class="meta">@PathVariable</span> String name)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前请求方法为PUT，表示REST风格中的修改操作</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user update...&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user update&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复习一下：<font color="red">只有在请求参数是json格式的时候，才需要在control方法的形参前加<code>@RequestBody</code>注解。</font></p>
</blockquote>
<img src="image-20230618113323094.png" alt="image-20230618113323094" style="zoom:77%;" />

<p><strong>根据ID查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前请求方法为GET，表示REST风格中的查询操作</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user getById...&quot;</span> + id);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getById&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询全部</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.GET)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user getAll...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RESTful入门开发总结"><a href="#RESTful入门开发总结" class="headerlink" title="RESTful入门开发总结"></a>RESTful入门开发总结</h3><ul>
<li>设定Http请求动作(method动词)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;&quot;,method = RequestMethod.POST|GET|PUT|DELETE)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设定请求参数(路径变量)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ReponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三大接收参数<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>：</strong></p>
<p>区别：</p>
<p>(1) <code>@RequestParam</code>用于接收url地址传参或表单传参；</p>
<p>(2) <code>@RequestBody</code>用于接收json数据；</p>
<p>(3) <code>@PathVariable</code>用于接收路径参数，使用参数名称描述路径参数；</p>
<p>应用：</p>
<p>(1) 如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数；</p>
<p>(2) 后期开发中，发送请求参数超过1个时，以json格式为主，<code>@RequestBody</code>应用较广；</p>
<p>(3) 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用<code>@PathVariable</code>接收请求路径变量，通常用于传递id值；</p>
<h2 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h2><p>简化前面RESTful入门开发的繁琐流程：</p>
<img src="image-20230618150323271.png" alt="image-20230618150323271" style="zoom:67%;" />

<ul>
<li><p>每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高：将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</p>
</li>
<li><p>每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高：使用<code>@GetMapping</code> <code>@PostMapping</code> <code>@PutMapping</code> <code>@DeleteMapping</code>代替。 </p>
</li>
<li><p>每个方法响应json都需要加上@ResponseBody注解，重复性太高：将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能；使用<code>@RestController</code>注解替换@Controller与@ResponseBody注解，简化书写。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save...&quot;</span> + book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book delete...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book update...&quot;</span> + book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book getById...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book getAll...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RESTful案例"><a href="#RESTful案例" class="headerlink" title="RESTful案例"></a>RESTful案例</h2><p>此次案例的重点是在SpringMVC中如何使用RESTful实现前后台交互，所以本案例并没有和数据库进行交互，所有数据使用假数据来完成开发。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求一：图书列表查询，从后台返回数据，将数据展示在页面上。</p>
<p>需求二：新增图书，将新增图书的数据传递到后台，并在控制台打印。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><img src="image-20230618161050752.png" alt="image-20230618161050752" style="zoom:77%;" />

<h3 id="后台接口开发"><a href="#后台接口开发" class="headerlink" title="后台接口开发"></a>后台接口开发</h3><p>步骤1：编写Controller类并使用RESTful进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="comment">// 查询全部</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 不与数据库进行交互，这里使用假数据</span></span><br><span class="line">        ArrayList&lt;Book&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book1.setName(<span class="string">&quot;C# primer&quot;</span>);</span><br><span class="line">        book1.setType(<span class="string">&quot;编程图书&quot;</span>);</span><br><span class="line">        book1.setDescription(<span class="string">&quot;C语言入门图书&quot;</span>);</span><br><span class="line">        bookList.add(book1);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book2.setName(<span class="string">&quot;计算机网络：自顶向下&quot;</span>);</span><br><span class="line">        book2.setType(<span class="string">&quot;计算机网络&quot;</span>);</span><br><span class="line">        book2.setDescription(<span class="string">&quot;计算机四大件之计算机网络&quot;</span>);</span><br><span class="line">        bookList.add(book2);</span><br><span class="line">        <span class="keyword">return</span> bookList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save =====&gt; &quot;</span> + book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27;module&#x27;:&#x27;Book save successfully...&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：使用PostMan进行测试</p>
<ul>
<li>测试新增</li>
</ul>
<img src="image-20230618163951612.png" alt="image-20230618163951612" style="zoom:87%;" />

<ul>
<li>测试查询全部</li>
</ul>
<img src="image-20230618164145531.png" alt="image-20230618164145531" style="zoom:87%;" />

<h3 id="页面访问处理"><a href="#页面访问处理" class="headerlink" title="页面访问处理"></a>页面访问处理</h3><p>步骤1：拷贝静态页面</p>
<p><img src="image-20230618165134339.png" alt="image-20230618165134339"></p>
<p>步骤2：访问pages目录下的books.html</p>
<p><img src="image-20230618165232338.png" alt="image-20230618165232338"></p>
<p>报错的原因是：<font color="blue">SpringMVC拦截了静态资源，根据/pages/books.html去controller找对应的方法，找不到所以会报404的错误。</font></p>
<p>因为在ServletInitConfig配置文件中<strong>拦截了静态资源</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以必须将静态资源在ServletInitConfig中进行放行：创建一个新的SpringMvcSupport配置类！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span>&#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.Lijiacheng.controller&quot;,&quot;com.Lijiacheng.config&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>步骤3：修改books.html页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//添加</span><br><span class="line">  saveBook () &#123;</span><br><span class="line">  	axios.post(&quot;/books&quot;,this.formData).then((res)=&gt;&#123;</span><br><span class="line"> 	&#125;);</span><br><span class="line"> &#125;,</span><br><span class="line">//主页列表查询</span><br><span class="line">  getAll() &#123;</span><br><span class="line">    axios.get(&quot;/books&quot;).then((res)=&gt;&#123;</span><br><span class="line">    this.dataList = res.data;</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p><img src="image-20230618170855805.png" alt="image-20230618170855805"></p>
<img src="image-20230618171004140.png" alt="image-20230618171004140" style="zoom:77%;" />

<p>前端的新增图书请求到后端来接收：</p>
<p><img src="image-20230618171022178.png" alt="image-20230618171022178"></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>02_Mybatis练习</title>
    <url>/2023/03/28/02-Mybatis%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>前面记录了mybatis，它是一种简化jdbc开发操作关系型数据库的持久层框架。下面我们用mybatis进行一些简单的业务来操作mysql数据库。基础的操作和代码我就不完整的展示了，我就记录一下比较容易出错的地方和需要注意的细节了。</p>
<span id="more"></span>

<h1 id="Mybatis-CRUD"><a href="#Mybatis-CRUD" class="headerlink" title="Mybatis CRUD"></a>Mybatis CRUD</h1><h2 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h2><p><code>selectAll</code>操作很简单，但是我们发现有些数据没有被封装成功，仍然是null：</p>
<p><img src="image-20230326151900257.png" alt="image-20230326151900257"></p>
<p>这是为什么呢，原因还要从mapper代理开发的过程来说起。因为在代理开发中通过接口代理对象调用接口中的函数，再在相应的sql映射文件中找sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_brand;</span><br></pre></td></tr></table></figure>

<p>找到的sql语句没问题，而它在编译的时候是变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,brand_name,company_name,ordered,description,status from tb_brand;</span><br></pre></td></tr></table></figure>

<p>sql语句执行后会从数据库中select出满足条件的数据，将其封装成定义的<code>Brand</code>类的对象并通过<code>List</code>集合的形式返回。但是在mapper代理开发的过程中封装成Brand对象的过程是自动进行的，那么mybatis并不知道<code>brand_name</code>数据应该被set成Brand对象中的<code>brandName</code>属性，这就是问题的关键。</p>
<p>要解决这个问题的思路就是将二者形成映射关系，让<code>mybatis</code>在封装的时候能将其对应上。目前在mybatis上有两种解决的方案：</p>
<ul>
<li><p>给字段起别名</p>
<ul>
<li><p>直接在sql语句中用<code>AS</code>起别名即可，但是这样操作非常麻烦！</p>
</li>
<li><p>还有一种方法，mybatis提供了sql片段可以提高sql语句的复用性，但仍然非常麻烦而且不灵活：将需要复用的sql片段抽取到<sql>标签中，在sql语句中使用<include refid="sql的id"/>引用即可。</p>
</li>
</ul>
</li>
<li><p>使用<code>resultMap</code>映射</p>
<p>在<code>sql映射配置文件</code>中使用<code>resultMap</code>定义属性和字段的映射关系：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           id：完成主键字段的映射</span></span><br><span class="line"><span class="comment">               column：表的列名</span></span><br><span class="line"><span class="comment">               property：实体类的属性名</span></span><br><span class="line"><span class="comment">           result：完成一般字段的映射</span></span><br><span class="line"><span class="comment">               column：表的列名</span></span><br><span class="line"><span class="comment">               property：实体类的属性名</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><resultMap>标签的<code>id</code>属性，要在下面sql映射文件的sql语句标签中引用，表示在这段sql代码中使用了如上的resultMap映射关系以自动封装数据；而<code>type</code>属性则和sql语句中的<code>type</code>一致即可，都指向pojo中的某个实体类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">       select * from tb_brand;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>现在再看从封装到Brand对象中的数据就没问题了：</p>
<p><img src="image-20230326154957319.png" alt="image-20230326154957319"></p>
<h2 id="按照id查询"><a href="#按照id查询" class="headerlink" title="按照id查询"></a>按照id查询</h2><p>在这里记录一下如何在映射配置文件的sql语句中使用<strong>参数占位符</strong>。</p>
<p>这是在映射文件中的sql语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">       select * from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mybatis中提供了两种参数占位符：</p>
<ul>
<li><p>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值，可以看出使用#{} 底层使用的是 <code>PreparedStatement</code></p>
</li>
<li><p>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题，所以不使用它。</p>
</li>
</ul>
<img src="image-20230326160640669.png" alt="image-20230326160640669" style="zoom: 50%;" />

<blockquote>
<p>对于有参数的mapper接口方法，我们在sql映射配置文件中应该配置 <code>ParameterType</code> 来指定参数类型。只不过该属性都可以省略。</p>
</blockquote>
<p>还需要注意的一点是可能会在sql映射文件中的sql语句中用到一些特殊字符，比方说：</p>
<img src="image-20230326160952157.png" alt="image-20230326160952157" style="zoom:67%;" />

<p>xml文件会将sql中的”&lt;”、”&gt;”识别成标签符号，所以需要用相应的转义字符替代，这个用到的时候网上一搜就行了。</p>
<h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p><strong>如何编写接口方法：</strong></p>
<ul>
<li>使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName,<span class="meta">@Param(&quot;brandName&quot;)</span> String brandName)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和实体类属性名保持一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和map集合中Key的名称一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如何使用动态SQL：</strong>用户在输入条件时，肯定不会所有的条件都填写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">       select * from tb_brand</span><br><span class="line">       <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">               and brand_name like #&#123;brandName&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">               and company_name like #&#123;companyName&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">               and status = #&#123;status&#125;;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>单个条件的动态sql：</p>
<p>用<choose></choose>里面<when test="条件"></when>标签，相当于<code>switch</code>和<code>case</code>。</p>
</blockquote>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul>
<li><p><font color="red">注意1：</font>如果要通过add、update等对数据库里的数据进行改动，那需要在测试类中手动使用<code>sqlSession.commit()</code>提交事务。</p>
</li>
<li><p><font color="red">注意2：</font>主键返回——在数据添加成功后，有时候需要获取插入数据库数据的主键。</p>
<ul>
<li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li>
<li>keyProperty  ：指定将获取到的主键值封装到哪儿个属性里</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>修改肯定不会修改数据所有的属性，&lt;*set*&gt; 标签可以用于动态包含需要更新的列，忽略其它不更新的列。</p>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>编写SQL时需要遍历数组来拼接SQL语句，Mybatis 提供了 <code>foreach</code> 标签供我们使用。</p>
<p><strong>foreach 标签</strong></p>
<p>用来迭代任何可迭代的对象（如数组，集合）。</p>
<ul>
<li>collection 属性：<ul>
<li>mybatis会将数组参数，封装为一个Map集合。<ul>
<li>默认：array = 数组</li>
<li>使用@Param注解改变map集合的默认key的名称</li>
</ul>
</li>
</ul>
</li>
<li>item 属性：本次迭代获取到的元素。</li>
<li>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。</li>
<li>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次</li>
<li>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">        delete from tb_brand where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        ;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。这样代码的可读性更高。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username,<span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="注解开发CRUD"><a href="#注解开发CRUD" class="headerlink" title="注解开发CRUD"></a>注解开发CRUD</h2><p>使用注解开发会比使用sql配置文件开发更加方便，使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code>。</p>
<p>官方文档是这么说的：</p>
<p><img src="image-20230327154233410.png" alt="image-20230327154233410"></p>
<p>所以给出的结论是：简单sql用注解开发，复杂sql仍然用sql映射配置文件。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Delete(&quot;delete from tb_brand where id = #&#123;id&#125;;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>02-Spring注解开发</title>
    <url>/2023/04/05/02-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>Part1记录了关于IOC/DI的配置开发，但是使用起来相对来说还是比较复杂的，要想真正简化开发，就需要用到Spring的注解开发。</p>
<span id="more"></span>

<p>关于Spring的注解开发，从Spring2.0开始支持注解，Spring3.0已经支持纯注解开发。关于注解开发，主要学习两块内容：注解开发定义bean和纯注解开发。</p>
<h2 id="IOC-DI注解开发"><a href="#IOC-DI注解开发" class="headerlink" title="IOC/DI注解开发"></a>IOC/DI注解开发</h2><p>使用注解开发，也就意味着我们需要通过注解的方式，来取代Spring配置文件中的内容。</p>
<h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><p>注解定义bean和纯注解开发是有本质区别的，后者完全摒弃了Spring配置文件，而注解定义bean还需要配置文件来做一些工作（包扫描）。</p>
<ul>
<li><p>步骤1：配置Spring的注解包扫描</p>
<p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描（在配置文件中定义<code>context</code>的命名空间）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.Lijiacheng&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>步骤2：在Dao类和Service类上添加<code>@Component</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一行注解取代了在配置文件中通过<code>&lt;bean&gt;</code>中的<code>id</code>和<code>class</code>属性定义bean。</p>
<blockquote>
<p>@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p>
</blockquote>
</li>
<li><p>步骤3：在App类中，从IOC容器中获取对应的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao);</span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> ctx.getBean(UserServiceImpl.class);  <span class="comment">// 按类型获取bean</span></span><br><span class="line">System.out.println(userService);</span><br></pre></td></tr></table></figure>

<p><code>@Component</code>注解如果不起名称，要么通过类型获取bean；要么有一个默认值就是当前类名首字母小写，所以也可以按照名称获取。</p>
</li>
</ul>
<p><strong>@Component的作用是设置该类为spring管理的bean。</strong>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>，这三个注解和@Component注解的作用是一样的，只是方便我们后期在编写类的时候能很好的区分出这个类是属于表现层、业务层、数据层的类。</p>
<h3 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h3><p>Spring3.0开启了纯注解开发模式，使用Java类替代Spring配置文件。</p>
<ul>
<li><p>创建一个类，并将其用注解配置为配置类：替换<code>applicationContext.xml</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用注解替换包扫描配置：<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code>（多个数据用数组格式）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建运行类并执行：new一个<code>AnnotationConfigApplicationContext</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>@Configuration作用是设置该类为spring配置类；@ComponentScan作用是设置spring配置类扫描路径，用于加载使用注解格式定义的bean。</strong></p>
<h3 id="注解开发Bean作用范围与生命周期管理"><a href="#注解开发Bean作用范围与生命周期管理" class="headerlink" title="注解开发Bean作用范围与生命周期管理"></a>注解开发Bean作用范围与生命周期管理</h3><h4 id="Bean作用范围"><a href="#Bean作用范围" class="headerlink" title="Bean作用范围"></a>Bean作用范围</h4><p>要想将UserDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>  <span class="comment">// //@Scope设置bean的作用范围</span></span><br></pre></td></tr></table></figure>

<p>设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象。默认值singleton（单例），可选值prototype（非单例）。</p>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><ul>
<li><p>为了使用@PostConstruct和@PreDestroy注解，导入<code>annotation</code>的坐标依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在响应bean类中添加初始化和销毁方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注解开发 小结</strong></p>
<img src="image-20230404162053485.png" alt="image-20230404162053485" style="zoom: 50%;" />

<h3 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h3><p>Spring为了使用注解简化开发，并没有提供构造函数注入、setter注入对应的注解，只提供了自动装配的注解实现。</p>
<h4 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h4><p>在UserServiceImpl类的userDao属性上添加<code>@Autowired</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Autowired写在属性上，并将setter方法删除掉。</p>
<p>由于@Autowired是按照类型注入，那么对应UserDao接口如果有多个实现类，这时候运行类就会报错，因为按类型注入就不知道注入哪个对象了，所以要用按名称注入。</p>
<p>还一种解决方案是可以给两个Dao实现类分别起名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br><span class="line"><span class="meta">@Component(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>此时就可以注入成功！@Autowired是按照类型注入的，尽管它还是有两个bean对象，但是由于：@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫userDao而容器中也有一个userDao，所以可以成功注入。</p>
<p>但是这种情况就找不到响应的Bean对象，因为容器中没有名称为userDao1或者userDao2的对象：</p>
<img src="image-20230404172257071.png" alt="image-20230404172257071" style="zoom:67%;" />

<h4 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h4><p>当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致（如上图情况），这个时候该如何解决？就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在依赖注入自动装配时，在属性名上用<code>@Qualifier</code>来指定注入名称为 UserDao2 的bean对象（一定要配合<code>Autowired</code>注解使用）。</p>
<h4 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h4><p>因为Spring只提供了自动装配注入的注解，而自动装配只能注入引用类型的数据。简单类型注入的是基本数据类型或者字符串类型，下面在<code>UserDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;lijiacheng&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<p>注释从<code>@Autowire</code>换成了<code>@Value()</code>，在括号内对属性进行赋值，注意数据格式要匹配。</p>
<h4 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h4><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用.</p>
<ul>
<li><p>使用注解加载properties配置文件：在配置类上添加<code>@PropertySource</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>@Value</code>读取配置文件中的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上，代表从当前项目的根路径找文件（但不支持使用通配符<code>*</code>）。</p>
</blockquote>
<p><strong>注解开发依赖注入 小结</strong></p>
<ul>
<li><p><code>@Autowired</code>：为引用类型属性设置值；</p>
</li>
<li><p><code>@Qualifier</code>：为引用类型属性指定注入的bean id；</p>
</li>
<li><p><code>@Value</code>：为基本数据类型或字符串类型属性依赖注入并设置值；</p>
</li>
<li><p><code>@PropertySource</code>：加载properties文件中的属性值。</p>
</li>
</ul>
<h2 id="IOC-DI注解开发管理第三方Bean"><a href="#IOC-DI注解开发管理第三方Bean" class="headerlink" title="IOC/DI注解开发管理第三方Bean"></a>IOC/DI注解开发管理第三方Bean</h2><h3 id="注解开发管理第三方Bean"><a href="#注解开发管理第三方Bean" class="headerlink" title="注解开发管理第三方Bean"></a>注解开发管理第三方Bean</h3><p>前面定义Bean的时候都是在自己开发的类上面写个注解就完事，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解，第三方的Bean该如何管理？下面以Druid数据源来举例。</p>
<ul>
<li><p>导入对应的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在SpringConfig配置类中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的返回值就是要创建的Bean对象类型；但new的时候不能new这个<code>DataSource</code>类型，因为DataSource接口中没有对应的setter方法来设置属性。</p>
</li>
<li><p>在方法上添加<code>@Bean</code>注解</p>
</li>
<li><p>从IOC容器中获取对象并打印：按类型获取bean对象</p>
</li>
</ul>
<blockquote>
<p>如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。</p>
</blockquote>
<h3 id="引入外部配置类"><a href="#引入外部配置类" class="headerlink" title="引入外部配置类"></a>引入外部配置类</h3><p>如果把所有的第三方bean都配置到Spring的配置类SpringConfig中，虽然可以，但是不利于代码阅读和分类管理，所以我们就想能不能按照类别将这些bean配置到不同的配置类中?</p>
<p>对于数据源的bean,我们新建一个<code>JdbcConfig</code>配置类，并把数据源配置到该类下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置类如何能被Spring配置类加载到，并在IOC容器中创建DataSource对象？对此有两个解决方案。</p>
<h4 id="使用包扫描引入"><a href="#使用包扫描引入" class="headerlink" title="使用包扫描引入"></a>使用包扫描引入</h4><p>使用包扫描引入的两个关键点，如果前面书写的代码规范，则这里不需要添加或修改代码：① 在每一个bean的配置类上加注释将其配置为配置类<code>@Configuration</code>； ② 在<code>SpringConfig</code>配置类中添加包扫描<code>@ComponentScan(&quot;com.itheima.config&quot;)</code>.</p>
<p>这种方式虽然能够扫描到，但是不能很快的知道都引入了哪些配置类，所以这种方式不推荐使用。</p>
<h4 id="使用-Import引入"><a href="#使用-Import引入" class="headerlink" title="使用@Import引入"></a>使用<code>@Import</code>引入</h4><p>这种方案可以不用在每一个bean的配置类加<code>@Configuration</code>注解，但是必须在<code>SpringConfig</code>配置类上使用<code>@Import</code>注解手动引入需要加载的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>通过@Import引入配置类，不需要在每一个bean配置类加配置注解，而且Spring配置类中的扫描注解可以移除；</li>
<li>@Import参数需要的是一个数组，可以引入多个配置类。</li>
</ul>
</blockquote>
<p><strong>引入外部配置类 小结</strong></p>
<ul>
<li><code>@Bean</code>是一种方法注解，作用是设置该方法的返回值作为spring管理的bean；</li>
<li><code>@Import</code>是一种类注解，作用是在SpringConfig配置类中定义导入的配置类类名。</li>
</ul>
<h3 id="注解开发为第三方Bean注入资源"><a href="#注解开发为第三方Bean注入资源" class="headerlink" title="注解开发为第三方Bean注入资源"></a>注解开发为第三方Bean注入资源</h3><p>在使用<code>@Bean</code>创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办？这些资源分为简单数据类型和引用数据类型。</p>
<h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><p>对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改JdbcConfig配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc.url&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc.username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc.password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将连接数据库的四要素定义成属性，并通过<code>@Value()</code>设置值注入简单数据类型的依赖，并从<code>jdbc.properties</code>配置中读取相应的属性值进行设置（配置类需要使用<code>@PropertySource(&quot;properties配置文件&quot;)</code>注解）。</p>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>假设在构建DataSource对象的时候，需要用到UserDao对象，该如何把BookDao对象注入进方法内让其使用呢？</p>
<ul>
<li><p>在SpringConfig中扫描UserDao（扫描Dao包）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.dao&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>在JdbcConfig类的方法上添加形参参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。</p>
</blockquote>
</li>
</ul>
<h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><p>前面我们已经完成了XML配置和注解的开发实现，至于两者之间的差异，咱们放在一块去对比回顾下：</p>
<img src="image-20230404194721834.png" alt="image-20230404194721834" style="zoom:67%;" />
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>01-SpringMVC入门</title>
    <url>/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。</p>
<span id="more"></span>

<h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><h3 id="Web架构"><a href="#Web架构" class="headerlink" title="Web架构"></a>Web架构</h3><p>现在web程序大都基于三层架构来实现：</p>
<img src="image-20230605105629968.png" alt="image-20230605105629968" style="zoom:67%;" />

<ul>
<li><p>浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据；</p>
</li>
<li><p>如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利；将后端服务器Servlet拆分成三层，分别是web、service和dao；</p>
<ul>
<li>web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端；</li>
<li>service层主要负责业务逻辑的处理；</li>
<li>dao层主要负责连接数据库，进行数据的增删改查操作；</li>
</ul>
</li>
<li><p>servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求；针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和model：</p>
<img src="image-20230605110015709.png" alt="image-20230605110015709" style="zoom:67%;" />

<ul>
<li><p>controller负责请求和数据的接收，接收后将其转发给service进行业务处理；</p>
</li>
<li><p>service根据需要调用dao对数据进行增删改查；</p>
</li>
<li><p>dao把数据处理完后将结果交给service，service再交给controller；</p>
</li>
<li><p><font color="red"><strong>同步请求：</strong></font>controller根据需求组装成Model和View，Model和View组合起来生成页面转发给前端浏览器（这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作）；</p>
<p>现在更多使用的是<font color="red"><strong>异步请求</strong></font>方式，后端不需要返回view视图，而是将数据以json格式返回</p>
</li>
</ul>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架，相比于Servlet使用更加简单、开发更加便捷。</p>
<p>SpringMVC主要负责的就是：① controller如何接收请求和数据；② 如何将请求和数据转发给业务层；③ 如何将响应数据转换成json发回到前端。</p>
<h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>SpringMVC是一个Web框架，是用来替换Servlet的，在JavaWeb中如何使用Servlet进行开发呢？忘记的话看前面的文章【<a href="https://kicheng.github.io/2023/03/28/03-Servlet/">JavaWeb_Servlet</a>】</p>
<p>SpringMVC的制作流程与Servlet几乎一致：</p>
<p>1、创建Maven结构的web工程</p>
<p>2、设置tomcat服务器：tomcat插件</p>
<p>3、导入坐标（SpringMVC+Servlet）</p>
<p>4、定义处理请求的功能类（Controller）</p>
<p>5、设置请求映射</p>
<p>6、将SpringMVC设定加载到tomcat容器中</p>
<h3 id="SpringMVC实现流程"><a href="#SpringMVC实现流程" class="headerlink" title="SpringMVC实现流程"></a>SpringMVC实现流程</h3><p>步骤1：创建webapp内核的Maven项目</p>
<p>步骤2：导入依赖坐标（Servlet、SpringMVC）</p>
<p>​    注意导入的版本，建议使用JDK8以及5.3.0以下的SpringMVC版本配置，否则后面会出现奇奇怪怪的bug…到现在不知道如何解决jdk17不兼容的问题，后面做大项目的时候一定解决这个问题！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果不设置默认是compile在编译、运行、测试时均有效；如果运行有效的话就会和tomcat中的servlet-api包发生冲突 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤3：创建SpringMvcConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：创建Controller类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    Controller要注意的点有如下几个：</p>
<p>（1）<code>@Controller</code>将其作为Bean交给Spring管理；</p>
<p>（2）<code>@RequestMapping(&quot;/save&quot;)</code>指定request请求访问的地址，相当于Servlet中的<code>WebServlet</code>；</p>
<p>（3）<code>@ResponseBody</code>指定后端返回的response响应是json数据；</p>
<p>步骤5：使用Servlet容器启动配置类替换web.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载springmvc配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//加载指定配置类</span></span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置由springmvc控制器处理的请求映射路径(设置为接收所有路径)</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    配置类要继承这个<code>AbstractDispatcherServletInitializer</code>类；并且初始化时所需的对象和前面的不同，是<code>AnnotationConfigWebApplicationContext</code>。</p>
<p>步骤6：配置Tomcat环境</p>
<p>我一般是习惯用IDEA自带的Tomcat插件，唯一的缺点是只能用Tomcat7，但是Tomcat7和JDK17已经不兼容了，所以我这里降低版本到JDK8了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤7：运行Tomcat服务器，在浏览器访问<code>/save</code></p>
<p><img src="image-20230605164950934.png" alt="image-20230605164950934"></p>
<h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><p>将SpringMVC的使用过程总共分两个阶段来分析，分别是启动服务器初始化过程和单次请求过程。</p>
<img src="image-20230605165432219.png" alt="image-20230605165432219" style="zoom: 50%;" />

<h4 id="启动服务器初始化"><a href="#启动服务器初始化" class="headerlink" title="启动服务器初始化"></a>启动服务器初始化</h4><p>1、服务器启动，执行ServletInitConfig类，初始化web容器（功能类似于以前的web.xml）</p>
<p>2、执行createServletApplicationContext方法，创建了WebApplicationContext对象，加载SpringMvcConfig配置类来初始化SpringMVC的容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line"><span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line"><span class="comment">//加载指定配置类</span></span><br><span class="line">ctx.register(SpringMvcConfig.class);</span><br></pre></td></tr></table></figure>

<p>3、加载SpringMvcConfig配置类，执行@ComponentScan加载对应的bean，扫描指定包及其子包下所有类上的注解，这里是<code>@Controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br></pre></td></tr></table></figure>

<p>4、加载Controller类，每个@RequestMapping的名称对应一个具体的方法：建立了<code>/save</code>和save方法的对应关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、执行getServletMappings方法，设定SpringMVC拦截请求的路径规则：<code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h4><p>1、发送请求 <a href="http://localhost:8080/springmvc_01_quickstart/save">http://localhost:8080/springmvc_01_quickstart/save</a></p>
<p>2、web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</p>
<p>3、解析请求路径<code>/save</code>，由<code>/save</code>匹配执行对应的方法save()</p>
<p>4、检测到有<code>@ResponseBody</code>直接将save()方法的返回值作为响应体返回给请求方</p>
<h3 id="Bean加载控制"><a href="#Bean加载控制" class="headerlink" title="Bean加载控制"></a>Bean加载控制</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>之前我们创建过SpringConfig配置类，在MVC中也创建了SpringMvcConfig配置类，它们都需要加载资源，它们分别都加载哪些内容呢？</p>
<blockquote>
<p>我们目前写过的Config配置类有：ServletInitConfig, SpringConfig, SpringMvcConfig, JdbcConfig, MybatisConfig。</p>
</blockquote>
<p>controller目录存放的是SpringMVC的controller类、service目录存放的是service接口和实现类、dao目录存放的是dao/Mapper接口。controller、service和dao这些类都需要被容器管理成bean对象，SpringMVC加载表现层bean，也就是controller包下的类；Spring控制业务层service的bean和功能bean（DataSource, SqlSessionFactoryBean, MapperScannerConfigurer等），我们需要让Spring和SpringMVC分开加载各自的内容。</p>
<p>在SpringMVC的配置类SpringMvcConfig中使用注解<code>@ComponentScan</code>，我们只需要将其扫描范围设置到controller即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring的配置类SpringConfig中使用注解<code>@ComponentScan </code>，当时扫描的范围中其实是已经包含了controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为功能不同，所以我们需要避免Spring错误加载到SpringMVC的bean。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230605192715499.png" alt="image-20230605192715499" style="zoom:67%;" />

<h4 id="设置Bean加载控制"><a href="#设置Bean加载控制" class="headerlink" title="设置Bean加载控制"></a>设置Bean加载控制</h4><p>方式一：修改Spring配置类，设定扫描范围为精准范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给MapperScannerConfigurer对象来进行扫描处理的，我们只需要将其扫描到service包即可。</p>
</blockquote>
<p>方式二：修改Spring配置类，排除掉controller包中的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.Lijiacheng&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(  // 设置扫描加载bean时，排除的过滤规则</span></span><br><span class="line"><span class="meta">                type = FilterType.ANNOTATION,  // 设置排除规则，当前使用按照bean定义时的注解类型进行排除</span></span><br><span class="line"><span class="meta">                classes = Controller.class  // 设置具体排除的注解类</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过getBean获取Controller类，如果获取不到就说明在SpringConfig配置类中排除成功了。</p>
<blockquote>
<p>需要把SpringMvcConfig配置类上的<code>@ComponentScan</code>注解注释掉才可以测试成功。因为SpringConfig类中扫描的包是com.Lijiacheng下除了controller包，config中的SpringMvcConfig就会被扫描到，里面又有一个<code>@ComponentScan</code>又将controller类扫描进来了。</p>
</blockquote>
<p>最后一点也很重要，有了SpringConfig配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletInitConfig配置类中的最后一个函数，将Spring配置也加载进来，很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">      ctx.register(SpringConfig.class);</span><br><span class="line">      <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>简化ServletInitConfig配置类开发</strong>（以后用它更简单，不过上面的是老母子）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bean加载控制总结</strong></p>
<p><code>@ComponentScan</code>有个很重要的属性：<code>excludeFilters</code>排除扫描路径中加载的bean，需要指定类别（type）和具体项（classes）；<code>includeFilter</code>相反。</p>
<h2 id="SpringMVC的请求与响应"><a href="#SpringMVC的请求与响应" class="headerlink" title="SpringMVC的请求与响应"></a>SpringMVC的请求与响应</h2><p>SpringMVC是web层的框架，主要的作用是接收请求、响应结果，所以这一部分是学习SpringMVC的重点内容。</p>
<h3 id="设置请求映射路径"><a href="#设置请求映射路径" class="headerlink" title="设置请求映射路径"></a>设置请求映射路径</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230606101301421.png" alt="image-20230606101301421" style="zoom:77%;" />

<p>开启Tomcat服务器，发生报错：</p>
<p><img src="image-20230606102344014.png" alt="image-20230606102344014"></p>
<p>意思是<code>/save</code>已经是bookController这个bean的方法进行匹配了，而另一个UserController这个bean也有一个<code>/save</code>，出现了request请求的匹配模糊。</p>
<h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>前面说到报错，是因为两个Controller中出现了重复的请求路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User delete...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决思路其实也很好想到：为不同模块设置模块名作为请求路径前缀。</p>
<p>对于BookController的save，将其访问路径设置 <a href="http://localhost:8080/springmvc_03_request_mapping/book/save%EF%BC%9B%E5%AF%B9%E4%BA%8EUserController%E7%9A%84save%EF%BC%8C%E5%B0%86%E5%85%B6%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE">http://localhost:8080/springmvc_03_request_mapping/book/save；对于UserController的save，将其访问路径设置</a> <a href="http://localhost:8080/springmvc_03_request_mapping/User/save%E3%80%82">http://localhost:8080/springmvc_03_request_mapping/User/save。</a></p>
<h4 id="设置映射路径"><a href="#设置映射路径" class="headerlink" title="设置映射路径"></a>设置映射路径</h4><p>类上也可以添加<code>@RequestMapping</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User delete...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606105142414.png" alt="image-20230606105142414"></p>
<blockquote>
<p><code>@RequestMapping</code>注解value属性前面加不加<code>/</code>都可以，这一点和Servlet有所不同！</p>
</blockquote>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>请求路径设置好后，只要确保页面发送请求地址和后台Controller类中配置的路径一致，就可以接收到前端的请求，接收到请求后，如何接收页面传递的参数。请求参数的传递与接收是和请求方式有关系的，目前比较常见的两种请求方式POST和GET。</p>
<h4 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230606114451105.png" alt="image-20230606114451105" style="zoom:77%;" />

<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><strong>GET发送单个参数</strong></p>
<p>客户端发送请求与参数：</p>
<img src="image-20230606115900208.png" alt="image-20230606115900208" style="zoom:80%;" />

<p>服务端接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里controller方法的形参负责接收来自客户端的请求参数（<font color="blue">注意形参名要和请求参数名一致！</font>）</p>
<p><img src="image-20230606120718965.png" alt="image-20230606120718965"></p>
<p>客户端接收到的返回数据：</p>
<p><img src="image-20230606120053621.png" alt="image-20230606120053621"></p>
<p><strong>GET发送多个参数</strong></p>
<p>发送请求与参数：</p>
<img src="image-20230606122327297.png" alt="image-20230606122327297" style="zoom:80%;" />

<p>服务端接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name, Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 age =====&gt;&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606122229281.png" alt="image-20230606122229281"></p>
<p><strong>GET请求中文乱码问题</strong></p>
<p>如果我们传递的请求参数中有中文，你会发现接收到的参数会出现中文乱码问题。</p>
<p>出现乱码的原因相信大家都清楚（忘了的话回去看JavaWeb的博客），Tomcat8以后的版本已经处理了中文乱码的问题，但是IDEA中的Tomcat插件目前只更新到Tomcat7，所以需要修改pom.xml中<strong>tomcat插件的配置</strong>来解决<font color="red">GET请求</font>中文乱码问题。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span>  <span class="comment">&lt;!--访问路径编解码字符集--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230606122858098.png" alt="image-20230606122858098"></p>
<p><strong>POST发送参数</strong></p>
<p>发送请求与参数：post的请求参数在请求体上</p>
<img src="image-20230606123252732.png" alt="image-20230606123252732" style="zoom:80%;" />

<p>接收参数和GET完全一致！</p>
<p><strong>POST请求中文乱码问题</strong></p>
<p>解决方案：在ServletInitConfig中配置过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 乱码处理 */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">      <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">      filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606161430634.png" alt="image-20230606161430634"></p>
<blockquote>
<p>CharacterEncodingFilter是在spring-web包中，而spring-web包又在SpringMVC包里。</p>
</blockquote>
<h3 id="五种类型的参数传递"><a href="#五种类型的参数传递" class="headerlink" title="五种类型的参数传递"></a>五种类型的参数传递</h3><p>前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递：普通参数、POJO类型参数、嵌套POJO类型参数、数组类型参数、集合类型参数。</p>
<h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</p>
<p>能接收到参数的前提是：这两个值必须一致！</p>
<img src="image-20230606162700080.png" alt="image-20230606162700080" style="zoom:80%;" />

<p>那如果方法形参和请求参数名不一致怎么办？</p>
<p><img src="image-20230606163422184.png" alt="image-20230606163422184"></p>
<p>使用<code>@RequestParam</code>注解：写上<code>@RequestParam</code>注解框架就不需要自己去解析注入，能提升框架处理性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username, Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + username);</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 age =====&gt;&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h4><p>简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p>
<p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）。</p>
<p>先看看前面封装的pojo类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="comment">// ...后部分省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求和参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）：</p>
<img src="image-20230606164837627.png" alt="image-20230606164837627" style="zoom:80%;" />

<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的pojo参数传递 user =====&gt;&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606165101676.png" alt="image-20230606165101676"></p>
<h4 id="嵌套POJO类型参数"><a href="#嵌套POJO类型参数" class="headerlink" title="嵌套POJO类型参数"></a>嵌套POJO类型参数</h4><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数。</p>
<p>发送请求和参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）：</p>
<img src="image-20230606171638166.png" alt="image-20230606171638166" style="zoom:80%;" />

<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/containPojoParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">containPojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的嵌套pojo参数传递 user =====&gt;&quot;</span> + user.toString());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606171728620.png" alt="image-20230606171728620"></p>
<h4 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h4><p>数组参数：请求参数名与形参对象属性名<strong>相同</strong>且请求参数为多个，定义数组类型即可接收参数。</p>
<p>发送请求和参数（请求参数名必须一致才能封装到一个数组当中）：</p>
<img src="image-20230606172710261.png" alt="image-20230606172710261" style="zoom:80%;" />

<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的数组参数传递 likes =====&gt;&quot;</span> + Arrays.toString(likes));</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606172647070.png" alt="image-20230606172647070"></p>
<h4 id="集合类型数据"><a href="#集合类型数据" class="headerlink" title="集合类型数据"></a>集合类型数据</h4><p>发送请求和参数：</p>
<p><img src="image-20230606184441837.png" alt="image-20230606184441837"></p>
<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的列表参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>出现报错：</p>
<p><img src="image-20230606184417780.png" alt="image-20230606184417780"></p>
<p>错误的原因是：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p>
<p>解决方案：<code>RequestParam</code>注解（对于简单数据类型使用数组会比集合更简单些）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的列表参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p><code>RequestParam</code>注解用在SpringMVC控制器方法形参定义前面：情况1——简单数据类型参数名和请求参数名不一致时进行映射；情况2——对于List列表形参前要加该注释将其标明为非POJO对象。</p>
<h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>前面我们说过，现在比较流行的开发方式为异步调用。前后端以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收。</p>
<p>SpringMVC接收JSON数据的实现步骤为：</p>
<ul>
<li>导入jackson包；</li>
<li>客户端发送JSON数据；</li>
<li>开启SpringMVC注解驱动，在SpringMvcConfig配置类上添加<code>@EnableWebMvc</code>注解；</li>
<li>Controller方法的参数前添加<code>@RequestBody</code>注解.</li>
</ul>
<h4 id="JSON普通数组"><a href="#JSON普通数组" class="headerlink" title="JSON普通数组"></a>JSON普通数组</h4><p>步骤1：pom.xml添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">2.15</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>步骤2：PostMan发送JSON数据</p>
<img src="image-20230606201238403.png" alt="image-20230606201238403" style="zoom:80%;" />

<p>步骤3：开启SpringMVC注解支持</p>
<p>​    在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：参数前添加<code>@RequestBody</code>将外部传递的json数组数据映射到形参的集合对象中作为数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON普通数组参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listParamForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为json数据是异步请求，参数和数据在表单中，所以不能用<code>@RequestParam</code>，而用<code>@RequestBody</code>.</p>
</blockquote>
<p><img src="image-20230606201541316.png" alt="image-20230606201541316"></p>
<h4 id="JSON对象数据"><a href="#JSON对象数据" class="headerlink" title="JSON对象数据"></a>JSON对象数据</h4><p>请求和数据的发送：</p>
<img src="image-20230606202729677.png" alt="image-20230606202729677" style="zoom:80%;" />

<p>后端接收数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pojoForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON实体类对象参数传递 User =====&gt;&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="blue">这里也不要忘记在controller方法形参对象前加上<code>@RequestBody</code>进行json类型转换。</font></p>
</blockquote>
<p><img src="image-20230606202648795.png" alt="image-20230606202648795"></p>
<h4 id="JSON对象数组"><a href="#JSON对象数组" class="headerlink" title="JSON对象数组"></a>JSON对象数组</h4><p>json对象数组即为在集合中保存多个POJO。</p>
<p>请求和数据的发送：</p>
<img src="image-20230606204127055.png" alt="image-20230606204127055" style="zoom:80%;" />

<p>后端接收数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listPojoForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listPojoForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON对象数组参数传递 users =====&gt;&quot;</span> + users);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listPojoForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606204104084.png" alt="image-20230606204104084"></p>
<blockquote>
<p><strong><code>@RequestBody</code>与<code>@RequestParam</code>的区别：</strong></p>
<p><code>@RequestParam</code>用于接收url地址传参，表单传参【application/x-www-form-urlencoded】；<code>@RequestBody</code>用于接收json数据【application/json】.</p>
<p>后期开发中，发送json格式数据为主，<code>@RequestBody</code>应用较广；如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数。</p>
</blockquote>
<h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><p>前面我们处理过简单数据类型、POJO数据类型、数组和集合数据类型以及JSON数据类型，接下来我们还得处理一种开发中比较常见的一种数据类型：日期类型。</p>
<p>日期的格式有N多中输入方式，比如：2088-08-18、2088/08/18、08/18/2088……这么多日期格式，SpringMVC如何接收。</p>
<p>步骤1：编写方法接收日期数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                          <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                          <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> Date date2)</span></span><br><span class="line">  &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date =====&gt;&quot;</span> + date);</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date1(YYYY-MM-dd) =====&gt;&quot;</span> + date1);</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date2(YYYY-MM-dd HH:mm:ss)&quot;</span> + date2);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;dataParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：客户端发送请求</p>
<img src="image-20230606225853557.png" alt="image-20230606225853557" style="zoom:80%;" />

<blockquote>
<p>SpringMVC默认支持的字符串转日期的格式为yyyy/MM/dd ，而如果传递的不符合其默认格式，SpringMVC就无法进行格式转换，所以报错：<img src="image-20230606205513452.png" alt="image-20230606205513452"></p>
<p>所以使用<code>@DateTimeFormat</code>注解的<code>pattern</code>值来解决这个问题。</p>
</blockquote>
<p><img src="image-20230606225051826.png" alt="image-20230606225051826"></p>
<h3 id="参数传递的内部实现原理"><a href="#参数传递的内部实现原理" class="headerlink" title="参数传递的内部实现原理"></a>参数传递的内部实现原理</h3><p>前端传递字符串，后端使用日期Date接收；前端传递JSON数据，后端使用对象接收；前端传递字符串，后端使用Integer接收。在数据的传递过程中存在很多类型的转换，那么谁来做这个类型转换——是<strong>SpringMVC</strong>提供的很多类型转换接口和实现类。</p>
<p>在框架中，有一些类型转换接口，其中有：</p>
<ul>
<li> Converter接口：convert方法就是将从页面上接收的数据(S)转换成我们想要的数据类型(T)返回，框架中有提供很多对应Converter接口的实现类，用来实现不同数据类型之间的转换，如：请求参数年龄数据（String→Integer）、日期格式转换（String → Date）。</li>
<li>HttpMessageConverter接口：该接口是实现对象与JSON之间的转换工作（配置<code>@EnableWebMvc</code>）。</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后都需要将结果告知给用户。对于响应，主要就包含两部分内容：响应页面、响应数据（文本数据、json数据），因为异步调用是目前常用的主流方式，所以我们需要更关注的就是如何返回JSON数据。</p>
<h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230607100531074.png" alt="image-20230607100531074" style="zoom:80%;" />

<h4 id="响应页面（了解）"><a href="#响应页面（了解）" class="headerlink" title="响应页面（了解）"></a>响应页面（了解）</h4><p>响应页面时不能使用<code>@responseBody</code>注解，否则会把”page.jsp”当做字符串返回，这里需要返回页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能使用@responseBody，否则会把&quot;page.jsp&quot;当做字符串返回，这里需要返回页面</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/jumpToPage&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">jumpToPage</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;跳转页面&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230607101201195.png" alt="image-20230607101201195"></p>
<h4 id="响应文本数据"><a href="#响应文本数据" class="headerlink" title="响应文本数据"></a>响应文本数据</h4><p>响应文本时一定要使用<code>@responseBody</code>注解，返回纯文本字符串类型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回纯文本数据&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;response text&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230607101757278.png" alt="image-20230607101757278" style="zoom:80%;" />

<h4 id="响应JSON数据"><a href="#响应JSON数据" class="headerlink" title="响应JSON数据"></a>响应JSON数据</h4><p><strong>响应POJO对象</strong></p>
<p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖<code>@ResponseBody</code>注解和<code>@EnableWebMvc</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPojoJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">toPojoJson</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回json格式的对象类型&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setName(<span class="string">&quot;李嘉诚123&quot;</span>);</span><br><span class="line">      user.setAge(<span class="number">22</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230607103941400.png" alt="image-20230607103941400" style="zoom:80%;" />

<p><strong>响应POJO集合对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回json对象列表的类型&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      u1.setName(<span class="string">&quot;李嘉诚&quot;</span>);</span><br><span class="line">      u1.setAge(<span class="number">21</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      u2.setName(<span class="string">&quot;廖梓汀&quot;</span>);</span><br><span class="line">      u2.setAge(<span class="number">22</span>);</span><br><span class="line">      List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">      users.add(u1);</span><br><span class="line">      users.add(u2);</span><br><span class="line">      <span class="keyword">return</span> users;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230607104901315.png" alt="image-20230607104901315" style="zoom:80%;" />

<p> <strong><code>@ResponseBody</code>总结</strong></p>
<p>位置：SpringMVC控制器方法定义上方和控制类上，写在类上则该类的所有方法都有该注解功能；</p>
<p>作用：设置当前控制器返回值作为响应体（除了返回页面之外都要加该注释）：① 方法的返回值为字符串，会将其作为文本内容直接响应给前端；② 方法的返回值为对象，会将对象转换成JSON响应给前端（通过Converter接口）。</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>03_HTTP&amp;Tomcat</title>
    <url>/2023/03/28/03-HTTP-Tomcat/</url>
    <content><![CDATA[<p>今天记录一下HTTP协议和一种目前使用最广泛的轻量级web服务器——Tomcat！</p>
<span id="more"></span>

<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><p><strong>什么是Web</strong></p>
<p>Web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。</p>
<h2 id="JavaWeb-1"><a href="#JavaWeb-1" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B/S架构"></a>B/S架构</h3><p>Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。</p>
<img src="image-20230327160756485.png" alt="image-20230327160756485" style="zoom: 50%;" />

<blockquote>
<p>B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。</p>
</blockquote>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。</p>
<h3 id="动态资源"><a href="#动态资源" class="headerlink" title="动态资源"></a>动态资源</h3><p>在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容。动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理；动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库(DB)主要负责存储数据。</p>
<img src="image-20230327161636792.png" alt="image-20230327161636792" style="zoom: 50%;" />

<p>整个web访问过程如下图所示：</p>
<p>(1) 浏览器发送一个请求到服务端，去请求所需要的相关资源;<br>(2) 资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;<br>(3) 在Java代码可以进行业务处理也可以从数据库中读取数据;<br>(4) 拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;<br>(5) 服务端将静态资源响应给浏览器;<br>(6) 浏览器将这些资源进行解析;<br>(7) 解析后将效果展示在浏览器，用户就可以看到最终的结果。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议（HTTP）是一个<strong>用于传输超媒体文档（例如HTML）的应用层协议</strong>。 它是为Web 浏览器与Web 服务器之间的通信而设计的，但也可以用于其他目的。 HTTP 遵循经典的客户端—服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。</p>
<h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器。后续我们使用一款轻量级最popular的Tomcat服务器。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><p><strong>HyperText Transfer Protocol</strong>，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p>
<ul>
<li>数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。</li>
<li>如果想知道具体的格式，可以打开浏览器，打开开发者工具，点击<code>Network</code>来查看某一次请求的请求数据和响应数据具体的格式内容：</li>
</ul>
<img src="image-20230327171036892.png" alt="image-20230327171036892" style="zoom: 33%;" />

<p><strong>HTTP协议特点</strong></p>
<p>HTTP协议有它自己的一些特点，分别是:</p>
<ul>
<li><p>基于TCP协议: 面向连接，安全</p>
<p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。</p>
</li>
<li><p>基于请求-响应模型的:一次请求对应一次响应</p>
<p>请求和响应是一一对应关系</p>
</li>
<li><p>HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的</p>
<p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点：</p>
<ul>
<li>缺点:多次请求间不能共享数据</li>
<li>优点:速度快</li>
</ul>
<p>请求之间无法共享数据会引发的问题，如:</p>
<ul>
<li>京东购物，<code>加入购物车</code>和<code>去购物车结算</code>是两次请求，</li>
<li>HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li>
<li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li>
</ul>
</li>
</ul>
<h3 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a>请求数据格式</h3><ul>
<li><p>请求行：请求方式</p>
</li>
<li><p>请求头：key-value格式</p>
<p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求</p>
</li>
<li><p>请求体：POST请求的最后一部分，存储请求参数</p>
<ul>
<li>GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</li>
<li>GET请求请求参数大小有限制，POST没有</li>
</ul>
</li>
</ul>
<h3 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h3><ul>
<li><p>响应行：状态码、状态码描述</p>
</li>
<li><p>响应头：key-value</p>
</li>
<li><p>响应体：存放响应数据</p>
<ul>
<li>200  ok 客户端请求成功</li>
<li>404  Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务端发生不可预期的错误</li>
</ul>
</li>
</ul>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Web服务器-1"><a href="#Web服务器-1" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>Web服务器是一个应用程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。</p>
<img src="image-20230327172954741.png" alt="image-20230327172954741" style="zoom: 50%;" />

<p> Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器中的页面就可以直接通过浏览器来访问了。</p>
<blockquote>
<p>Web浏览器的作用：①封装HTTP协议操作，简化开发；②可以将Web项目部署到服务器中，对外提供网上浏览服务。</p>
</blockquote>
<p>因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>（这边暂时先省略不掌握）</p>
<h3 id="Maven创建Web项目"><a href="#Maven创建Web项目" class="headerlink" title="Maven创建Web项目"></a>Maven创建Web项目</h3><p>新创建好的Web项目结构如下：</p>
<img src="image-20230327174246976.png" alt="image-20230327174246976" style="zoom: 67%;" />

<blockquote>
<p>要注意pom.xml中的打包方式为<code>&lt;packaging&gt;war&lt;/packaging&gt;</code>，默认为jar。</p>
</blockquote>
<h3 id="IDEA使用Tomcat"><a href="#IDEA使用Tomcat" class="headerlink" title="IDEA使用Tomcat"></a>IDEA使用Tomcat</h3><p>Maven Web项目创建成功后，通过Maven的<code>package</code>命令可以将项目打包成war包，将war文件拷贝到Tomcat的<code>webapps</code>目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可，但是这种方式非常不方便。</p>
<h4 id="集成本地Tomcat"><a href="#集成本地Tomcat" class="headerlink" title="集成本地Tomcat"></a>集成本地Tomcat</h4><p><strong>配置Tomcat属性</strong></p>
<img src="image-20230327175323649.png" alt="image-20230327175323649" style="zoom:67%;" />

<blockquote>
<p> xxx.war和 xxx.war exploded这两种部署项目模式的区别：war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容；war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署。建议使用war模式进行部署。</p>
</blockquote>
<h4 id="Tomcat插件集成"><a href="#Tomcat插件集成" class="headerlink" title="Tomcat插件集成"></a>Tomcat插件集成</h4><p>还有一种更简单的方式，那就是直接使用Maven中的Tomcat插件来部署项目：</p>
<p>1、在pom.xml中添加Tomcat插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Tomcat插件 集成 Tomcat7--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven –&gt; tomcat7:run</p>
<img src="image-20230327190120842.png" alt="image-20230327190120842" style="zoom: 67%;" />
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>03_Servlet</title>
    <url>/2023/03/28/03-Servlet/</url>
    <content><![CDATA[<p>Servlet是JavaWeb最为核心的内容，它是Java提供的一门动态web资源开发技术。</p>
<span id="more"></span>

<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul>
<li><p>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容</p>
</li>
<li><p>Servlet是JavaEE规范之一，其实就是一个<strong>接口</strong>，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p>
</li>
</ul>
<img src="image-20230327190333387.png" alt="image-20230327190333387" style="zoom: 33%;" />

<h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><p>1、导入Servlet依赖坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    provided指的是在编译和测试过程中有效,最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">    因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、定义一个类，实现Servlet接口，并重写接口中所有方法</p>
<p>3、在类上使用<code>@WebServlet</code>注解，配置该Servlet的访问路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="Servlet执行流程"><a href="#Servlet执行流程" class="headerlink" title="Servlet执行流程"></a>Servlet执行流程</h2><img src="image-20230327214158461.png" alt="image-20230327214158461" style="zoom:50%;" />

<ul>
<li>浏览器发出<code>http://localhost:8080/JavaWeb_03_Servlet/demo1</code>请求，从请求中可以解析出三部分内容，分别是<code>localhost:8080</code>、<code>JavaWeb_03_Servlet</code>、<code>demo1</code><ul>
<li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li>
<li>根据<code>JavaWeb_03_Servlet</code>可以找到部署在Tomcat服务器上的JavaWeb_03_Servlet项目</li>
<li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li>
</ul>
</li>
<li>找到ServletDemo_01这个类后，Tomcat Web服务器就会<strong>为ServletDemo_01这个类创建一个对象，然后调用对象中的service方法</strong><ul>
<li>ServletDemo_01实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li>
<li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期：指一个对象从被创建到被销毁的整个过程</p>
<p>Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段：</p>
<ul>
<li><p>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</p>
<p>默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能<strong>把Servlet的创建放到服务器启动的时候来创建</strong>？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="comment">/* loadOnstartup的取值有两类情况</span></span><br><span class="line"><span class="comment">	（1）负整数:第一次访问时创建Servlet对象</span></span><br><span class="line"><span class="comment">	（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化：在Servlet实例化之后，容器将调用Servlet的<code>init()</code>方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作，该方法只调用一次</p>
</li>
<li><p>请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的<code>service()</code>方法对请求进行处理</p>
</li>
<li><p>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的<code>destroy()</code>方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收。</p>
</li>
</ul>
<h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><img src="image-20230327220008677.png" alt="image-20230327220008677" style="zoom:50%;" />

<p>我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会通过继承<code>HttpServlet</code>的方式代替实现接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo_02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送GET请求就不说了，发送POST请求需要在html页面中创建一个表单传递请求参数，举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/JavaWeb_03_Servlet/demo2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么HttpServlet中要根据请求方式的不同，调用不同的方法？</p>
<p>前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理。</p>
</blockquote>
<h2 id="urlPattern配置"><a href="#urlPattern配置" class="headerlink" title="urlPattern配置"></a>urlPattern配置</h2><p>Servlet类编写好后，要想被访问到，就需要配置其访问路径。</p>
<p><strong>urlPattern配置规则：</strong></p>
<ul>
<li>精确匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/user/select&quot;)</span></span><br></pre></td></tr></table></figure>

<p>访问路径为 <code>http://localhost:8080/JavaWeb_03_Servlet/user/select</code></p>
<ul>
<li>目录匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/user/*&quot;)</span></span><br></pre></td></tr></table></figure>

<p>访问路径 <code>http://localhost:8080/JavaWeb_03_Servlet/user/aaa </code>、<code>http://localhost:8080/JavaWeb_03_Servlet/user/bbb</code> 等等</p>
<ul>
<li>扩展名匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br></pre></td></tr></table></figure>

<p>访问路径为 <code>http://localhost:8080/JavaWeb_03_Servlet/任意.do</code></p>
<blockquote>
<p>如果路径配置的不是扩展名，那么在路径的前面就<font color="red">必须要加<code>/</code>否则会报错</font>；</p>
<p>如果路径配置的是<code>*.do</code>,那么在*.do的前面不能加<code>/</code>,否则会报错！</p>
</blockquote>
<ul>
<li>任意匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/&quot;)</span> </span><br></pre></td></tr></table></figure>

<p>访问路径为 <code>http://localhost:8080/JavaWeb_03_Servlet/任意</code></p>
<blockquote>
<p>当我们的项目中的Servlet配置了 “/“,会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet。DefaultServlet是用来处理静态资源，如果配置了”/“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终<font color="red">导致静态资源不能被访问</font>。</p>
</blockquote>
<p>上面这段话如何理解呢？我们在访问静态资源例如html静态页面时，<code>http://localhost:8080/JavaWeb_03_Servlet/a.html</code>，但是由于进行了任意匹配覆盖了DefaultServlet，在访问该路径时就会走这个任意匹配的Servlet，而a.html就访问不到啦。</p>
<h2 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h2><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。这里只需要了解一下即可，现在几乎不会在web.xml中进行配置了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Servlet 全类名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的名称，名字任意--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet的类全名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.Lijiacheng.web.ServletDemo_02<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Servlet 访问路径</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的名称，要和上面的名称一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的访问路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>03-SSM整合</title>
    <url>/2023/06/19/03-SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发。                                                             </p>
<span id="more"></span>

<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>1、创建Maven的Web工程</p>
<p>2、在pom.xml中导入SSM需要的依赖jar包：</p>
<p>​    ① SpringMVC的核心依赖<code>spring-webmvc</code></p>
<p>​    ② Spring和jdbc、mybatis的依赖<code>spring-test</code>, <code>spring-jdbc</code> , <code>mybatis-spring</code>, <code>mybatis</code></p>
<blockquote>
<p>这里要注意Spring和jdk的版本兼容问题：当使用java8时，webmvc、test、jdbc保持版本一致且5.2.x以下的版本，mybatis-spring要保持2.x的版本。</p>
</blockquote>
<p>​    ③ 数据库<code>mysql</code>和数据库连接池<code>Druid</code></p>
<p>​    ④ Servlet（使用java8时要用4.0.1以下的版本）</p>
<p>​    ⑤ 其他：<code>jackson</code>自动解析json格式数据，<code>juint</code>测试依赖</p>
<p>3、编写Web项目的入口配置类ServletInitConfig，实现AbstractAnnotationConfigDispatcherServletInitializer并重写以下方法：</p>
<p>​    ① getRootConfigClasses() ：返回Spring的配置类-&gt;需要<strong>SpringConfig</strong>配置类</p>
<p>​    ② getServletConfigClasses() ：返回SpringMVC的配置类-&gt;需要<strong>SpringMvcConfig</strong>配置类</p>
<p>​    ③ getServletMappings() : 设置SpringMVC请求拦截路径规则</p>
<p>​    ④ getServletFilters() （这个要记住函数名因为没有快捷override方式）：设置过滤器，解决POST请求中文乱码问题</p>
<h4 id="SSM整合-1"><a href="#SSM整合-1" class="headerlink" title="SSM整合"></a>SSM整合</h4><p>1、SpringConfig</p>
<p>​    ① 标识该类为配置类 <code>@Configuration</code></p>
<p>​    ② 扫描Service所在的包 <code>@ComponentScan</code></p>
<p>​    ③ 在Service层要管理事务 <code>@EnableTransactionManagement</code></p>
<p>​    ④ 读取外部的properties配置文件 <code>@PropertySource</code></p>
<p>​    ⑤ 整合Mybatis需要引入Mybatis相关配置类 <code>@Import</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.Lijiacheng.service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisConfig.class, JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        1) 第三方数据源配置类 JdbcConfig：构建DataSource数据源DruidDataSouroce，需要注入数据库连接四要素，<code>@Bean</code>和<code>@Value</code>注解。构建平台事务管理器DataSourceTransactionManager，<code>@Bean</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建jdbc事务管理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        2) Mybatis配置类 MybatisConfig：构建SqlSessionFactoryBean并设置别名扫描与数据源，<code>@Bean</code>注解。构建MapperScannerConfigurer并设置DAO层的包扫描，<code>@Bean</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">&quot;com.Lijiacheng.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.Lijiacheng.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、SpringMvcConfig</p>
<p>​    ① 标识该类为配置类 <code>@Configuration</code></p>
<p>​    ② 扫描Controller所在的包 <code>@ComponentScan</code></p>
<p>​    ③ 开启SpringMVC注解支持 <code>@EnableWebMvc</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><p>1、创建数据库表</p>
<p>2、根据数据库表创建对应的模型类</p>
<p>3、通过Dao层完成数据库表的增删改查（接口+自动代理）</p>
<p>4、编写Service层（Service接口+实现类）：<code>@Service</code>, <code>@Transactional</code>；整合Junit对业务层进行单元测试<code>@RunWith</code>, <code>@ContextConfiguration</code>, <code>@Test</code></p>
<p>5、编写Controller层：<code>@RestController</code>；接收请求(<code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>)；接收数据(<code>@RequestParam</code>, <code>@PathVariable</code>, <code>@RequestBody</code>)；转发业务层<code>@Autowired</code></p>
<h3 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h3><p>步骤1：创建项目包结构</p>
<p>​                                                             <img src="image-20230619215547658.png" alt="image-20230619215547658" style="zoom:87%;" />    </p>
<p>步骤2：创建SpringConfig配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.Lijiacheng.service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisConfig.class, JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="comment">// 创建事务管理</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建JdbcConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建jdbc事务管理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：创建MybatisConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">&quot;com.Lijiacheng.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.Lijiacheng.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤5：创建jdbc.properties</p>
<p>在resources下提供jdbc.properties，设置数据库连接四要素</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssm_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">xxxxxxx</span></span><br></pre></td></tr></table></figure>

<p>步骤6：创建SpringMvcConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤7：创建Web项目入口ServletInitConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<p>Web项目入口配置类ServletInitConfig → SpringConfig配置类：扫描Service层、导入外部properties、导入JdbcConfig、MybatisConfig等配置类</p>
<p>​                                                                  → SpringMvcConfig配置类：扫描Controller层                                                         </p>
</blockquote>
<h3 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h3><p>步骤1：编写pojo模型类</p>
<p>步骤2：编写Dao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_book values(null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_book set type = #&#123;type&#125;, name = #&#123;name&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：编写Service接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ======================================================== */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bookDao在Service中注入的会提示一个红线提示：这是因为BookDao是一个接口，没有实现类，接口是不能创建对象的，所以最终注入的应该是代理对象。而代理对象是由Spring的IOC容器来创建管理的，IOC容器又是在Web服务器启动的时候才会创建，没有找到适合的类注入所以会提示错误提示。</p>
<p><img src="image-20230619221050923.png" alt="image-20230619221050923"></p>
<p>不去理会当然可以正常运行程序，但作为追求完美的强迫症程序员，可以设置IDEA的错误提示级别：</p>
<p><img src="image-20230619221318810.png" alt="image-20230619221318810"></p>
<p>在这里取消勾选，或者将其降级为warning级别都可以：</p>
<p><img src="image-20230619221402465.png" alt="image-20230619221402465"></p>
<p>步骤4：编写Controller类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>对于图书模块的增删改查就已经完成了编写，接下来我们就先把业务层Service的代码使用Spring整合Junit进行单元测试：</p>
<p>步骤1：新建测试类</p>
<p>步骤2：注入Service类</p>
<p>步骤3：编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service层的代码测试成功，结果就不在这放嘞，接着往下看。</p>
<h3 id="PostMan测试"><a href="#PostMan测试" class="headerlink" title="PostMan测试"></a>PostMan测试</h3><p><strong>新增</strong></p>
<p>前端发送新增请求：</p>
<img src="image-20230619222757536.png" alt="image-20230619222757536" style="zoom:87%;" />

<p>后台数据库：</p>
<p><img src="image-20230619223001724.png" alt="image-20230619223001724"></p>
<p><strong>修改</strong></p>
<p>前端发送修改请求：</p>
<img src="image-20230619222849481.png" alt="image-20230619222849481" style="zoom:87%;" />

<p>后台数据库：</p>
<p><img src="image-20230619223124913.png" alt="image-20230619223124913"></p>
<p><strong>删除</strong></p>
<p>前端发送删除请求：</p>
<img src="image-20230619223213419.png" alt="image-20230619223213419" style="zoom:87%;" />

<p>后台数据库：</p>
<p><img src="image-20230619223300861.png" alt="image-20230619223300861"></p>
<p><strong>查询</strong></p>
<p>前端发送查询请求：</p>
<img src="image-20230619223340795.png" alt="image-20230619223340795" style="zoom:67%;" />

<img src="image-20230619223400561.png" alt="image-20230619223400561" style="zoom:67%;" />

<h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><h3 id="表现层与前端数据传输协议定义"><a href="#表现层与前端数据传输协议定义" class="headerlink" title="表现层与前端数据传输协议定义"></a>表现层与前端数据传输协议定义</h3><p>在Controller层增删改返回给前端的是boolean类型数据、在Controller层查询单个返回给前端的是对象、在Controller层查询所有返回给前端的是集合对象……对于前端来说，如果后台能够返回一个统一的数据结果，前端在解析的时候就可以按照一种方式进行解析，开发就会变得更加简单。</p>
<p>所以我们就想能不能将返回结果的数据进行统一，具体如何来做，大体的思路为:</p>
<ul>
<li><p>为了封装返回的结果数据：创建结果模型类，封装数据到data属性中</p>
</li>
<li><p>为了封装返回的数据是何种操作及是否操作成功：封装操作结果到code属性中</p>
</li>
<li><p>操作失败后为了封装返回的错误信息：封装特殊消息到message(msg)属性中</p>
</li>
</ul>
<img src="image-20230621101144401.png" alt="image-20230621101144401" style="zoom:77%;" />

<p>解决方案是我们可以设置统一数据返回结果类，Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作：</p>
<h3 id="表现层与前端数据传输协议实现"><a href="#表现层与前端数据传输协议实现" class="headerlink" title="表现层与前端数据传输协议实现"></a>表现层与前端数据传输协议实现</h3><p>步骤1：创建Result类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  	<span class="comment">// 描述统一格式中的数据</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">  	<span class="comment">// 描述统一格式中的编码</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">  	<span class="comment">// 描述统一格式中的消息，可选属性</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：定义返回码Code类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：修改Controller类的返回值为Result对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.save(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.update(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(id);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;未查询到信息，请重试&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, book, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> books != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> books != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;未查询到信息，请重试&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, books, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的返回结果就已经能以一种统一的格式返回给前端。前端根据返回的结果，先从中获取code，根据code判断，如果成功则取data属性的值；如果失败则取msg中的值做提示（随便举一个根据id查询的例子）：</p>
<img src="image-20230621102138599.png" alt="image-20230621102138599" style="zoom:87%;" />

<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><h3 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h3><p>当我们在表现Controller层的getById方法中手动添加一个异常，可以发现在前端发送请求时出现接收到的信息和之前约定的数据格式不一致的问题：</p>
<img src="image-20230620101102095.png" alt="image-20230620101102095" style="zoom: 77%;" />

<p>我们在开发的过程中在任何一个位置都可能会出现异常。</p>
<p>框架内部抛出的异常：因使用不合规导致</p>
<p>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</p>
<p>业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）</p>
<p>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</p>
<p>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）</p>
<blockquote>
<p>各个层级均出现异常，异常处理代码书写在哪一层？<strong>所有的异常均抛出到表现层进行处理</strong></p>
<p>异常的种类很多，表现层如何将所有的异常都处理到呢？<strong>异常分类</strong></p>
<p>表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决？<strong>AOP</strong></p>
</blockquote>
<p>针对上述的问题，SpringMVC已经为我们提供了一套<strong>异常处理器</strong>的解决方案，集中的统一的处理项目中出现的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理器的使用"><a href="#异常处理器的使用" class="headerlink" title="异常处理器的使用"></a>异常处理器的使用</h3><p>步骤1：创建异常处理器类</p>
<p><font color="blue">要确保SpringMvcConfig能够扫描到异常处理器类</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘿嘿，异常你往哪里跑！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：让程序抛出异常</p>
<p>步骤3：运行程序测试（异常已经被拦截并执行了doException方法）</p>
<p><img src="image-20230620102849723.png" alt="image-20230620102849723"></p>
<p>步骤4：异常处理器类返回结果给前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;嘿嘿，异常你往哪里跑！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>, <span class="literal">null</span>, <span class="string">&quot;呵呵，异常你往哪里跑！&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230620103149866.png" alt="image-20230620103149866"></p>
<p>就算后台执行的过程中抛出异常，最终也能按照我们和前端约定好的数据格式返回给前端。</p>
<blockquote>
<p><code>@RestControllerAdvice</code>注解：此注解自带<code>@ResponseBody</code>注解与<code>@Component</code>注解，REST风格的(异常处理)控制器类。</p>
<p><code>@ExceptionHandler</code>注解：专用于异常处理的控制器<strong>方法</strong>上方，出现异常后终止原始控制器执行，并转入当前方法执行。</p>
</blockquote>
<h3 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>因为异常的种类有很多，如果每一个异常都对应一个<code>@ExceptionHandler</code>，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类。</p>
<ul>
<li><p>业务异常(BusinessException)</p>
<p>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串；</p>
<p>不规范的用户行为操作产生的异常，如用户故意传递错误数据。</p>
</li>
<li><p>系统异常(SystemException)</p>
</li>
</ul>
<p>​        项目运行过程中可预计但无法避免的异常，比如数据库或服务器宕机。</p>
<ul>
<li>其他异常(Exception)</li>
</ul>
<p>​        编程人员未预期到的异常，如:用到的文件不存在。</p>
<p>将异常分类以后，针对不同类型的异常，要提供具体的解决方案。</p>
<h4 id="异常解决方案"><a href="#异常解决方案" class="headerlink" title="异常解决方案"></a>异常解决方案</h4><ul>
<li>业务异常（BusinessException）</li>
</ul>
<p>​    发送对应消息传递给用户，提醒规范操作（大家常见的就是提示用户名已存在或密码格式不正确等）</p>
<ul>
<li>系统异常（SystemException）</li>
</ul>
<p>​    发送固定消息传递给用户，安抚用户（系统繁忙，请稍后再试）</p>
<p>​    发送特定消息给运维人员，提醒维护（可以发送短信、邮箱或者是公司内部通信软件）</p>
<p>​    记录日志（发消息和记录日志对用户来说是不可见的，属于后台程序）</p>
<ul>
<li>其他异常（Exception）</li>
</ul>
<p>​    发送固定消息传递给用户，安抚用户</p>
<p>​    发送特定消息给编程人员，提醒维护（纳入预期范围内）</p>
<p>​    记录日志（一般是程序没有考虑全，比如未做非空校验等）</p>
<h4 id="异常解决方案的具体实现"><a href="#异常解决方案的具体实现" class="headerlink" title="异常解决方案的具体实现"></a>异常解决方案的具体实现</h4><blockquote>
<p>思路：</p>
<ol>
<li><p>先通过自定义异常，完成BusinessException和SystemException的定义</p>
</li>
<li><p>将其他异常包装成自定义异常类型</p>
</li>
<li><p>在异常处理器类中对不同的异常进行处理</p>
</li>
</ol>
</blockquote>
<p>步骤1：自定义异常类（新建一个exception包目录）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>让自定义异常类继承RuntimeException的好处是，后期在抛出这两个异常的时候，就不用try…catch…或throws了。</p>
<p>自定义异常类中添加code属性的原因是为了更好的区分异常是来自哪个业务的。</p>
</blockquote>
<p>步骤1.5：在Code类中再新增需要的属性</p>
<p>步骤2：将其他异常包装成自定义异常</p>
<p>具体的包装方式有两种：</p>
<p>方式一：try{…}catch(){…}在catch中重新throw我们自定义异常即可；</p>
<p>方式二：直接throw自定义异常即可；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟业务异常，包装成自定义异常</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(Code.BUSINESS_ERR, <span class="string">&quot;请不要用你的技术挑战我的饭碗！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(Code.SYSTEM_TIMEOUT_ERR,<span class="string">&quot;服务器访问超时，请重试！&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(id);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;未查询到信息，请重试&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：处理器类中处理自定义异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// @ExceptionHandler用于设置当前处理器类对应的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SystemException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doSystemException</span><span class="params">(SystemException ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">// 发送消息给运维</span></span><br><span class="line">        <span class="comment">// 发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(), <span class="literal">null</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doBusinessException</span><span class="params">(BusinessException ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(), <span class="literal">null</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        <span class="comment">// 发送消息给运维</span></span><br><span class="line">        <span class="comment">// 发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(Code.SYSTEM_UNKNOWN_ERR, <span class="literal">null</span>, <span class="string">&quot;系统繁忙，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：进行异常测试</p>
<p>在根据id查询中，如果查询请求id为1报错BusinessException错，如果id不为1则报SystemException错。</p>
<img src="image-20230620210737395.png" alt="image-20230620210737395" style="zoom:77%;" />

<p>对于异常我们就已经处理完成了。不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。</p>
<p><strong>小结</strong></p>
<p>项目中的异常处理方式为：</p>
<img src="image-20230620210909413.png" alt="image-20230620210909413" style="zoom:67%;" />

<h2 id="前后台协议联调"><a href="#前后台协议联调" class="headerlink" title="前后台协议联调"></a>前后台协议联调</h2><img src="image-20230620221704513.png" alt="image-20230620221704513" style="zoom:87%;" />

<p>因为添加了静态资源，SpringMVC会拦截，所以需要将静态资源进行放行：</p>
<blockquote>
<p><strong>复习一下如何将静态资源放行？</strong></p>
<p>1）新建SpringMvcSupport配置类，继承WebMvcConfigurationSupport，重写addResourceHandlers方法。</p>
<p>2）在SpringMvcConfig中扫描SpringMvcSupport</p>
</blockquote>
<p><strong>列表功能</strong></p>
<p>页面加载完后发送异步请求到后台获取列表数据进行展示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//列表</span><br><span class="line">getAll() &#123;</span><br><span class="line">    // 发送ajax请求</span><br><span class="line">    axios.get(&quot;/books&quot;).then((res)=&gt;&#123;</span><br><span class="line">      this.dataList = res.data.data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<img src="image-20230620230749389.png" alt="image-20230620230749389" style="zoom:67%;" />

<p><strong>添加功能</strong></p>
<p>“新建”按钮上绑定了@click=”handleCreate()”方法；在method中找到handleCreate方法，方法中打开”新增“面板。</p>
<p>”确定”按钮上绑定了@click=”handleAdd()”方法；在method中找到handleAdd方法，在方法中发送请求和数据，响应成功后将新增面板关闭并重新查询数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//弹出添加窗口</span><br><span class="line">handleCreate() &#123;</span><br><span class="line">    this.dialogFormVisible = true;</span><br><span class="line">&#125;,</span><br><span class="line">//添加</span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    //发送ajax请求</span><br><span class="line">    // this.formData是表单中的数据，最后是一个json数据</span><br><span class="line">    axios.post(&quot;/books&quot;, this.formData).then((res)=&gt;&#123;</span><br><span class="line">        this.dialogFormVisible = false;  // 关闭弹窗</span><br><span class="line">        this.getAll();  // 刷新显示全部</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><img src="image-20230620231613537.png" alt="image-20230620231613537"></p>
<p>但是我们发现在新增成功后，再次点击新增按钮会发现之前的数据还存在，这个时候就需要在新增的时候将表单内容清空。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//弹出添加窗口</span><br><span class="line">handleCreate() &#123;</span><br><span class="line">    this.dialogFormVisible = true;</span><br><span class="line">    this.resetForm();</span><br><span class="line">&#125;,</span><br><span class="line">//重置表单</span><br><span class="line">resetForm() &#123;</span><br><span class="line">    this.formData = &#123;&#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>添加功能状态处理</strong></p>
<p>新增成功是关闭面板，重新查询数据，但是我们还需要考虑新增失败的异常情况：即在handlerAdd方法中根据后台返回的数据来进行不同的处理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//添加</span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    //发送ajax请求</span><br><span class="line">    axios.post(&quot;/books&quot;, this.formData).then((res)=&gt;&#123;</span><br><span class="line">        // 如果请求成功，则关闭弹层，显示数据</span><br><span class="line">        if(res.data.code == 20011)&#123;</span><br><span class="line">            this.dialogFormVisible = false;  // 关闭弹窗</span><br><span class="line">            this.$message.success(&quot;添加成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果请求失败，则弹窗提醒</span><br><span class="line">        else if(res.data.code == 20010)&#123;</span><br><span class="line">            this.$message.error(&quot;添加失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他的未知异常</span><br><span class="line">        else&#123;</span><br><span class="line">            this.$message.error(res.data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(()=&gt;&#123;</span><br><span class="line">        this.getAll();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<img src="image-20230620235136525.png" alt="image-20230620235136525" style="zoom:77%;" />

<p><strong>修改功能</strong></p>
<p>“编辑”按钮绑定了@click=”handleUpdate(scope.row)”；在method的handleUpdate方法中发送异步请求根据ID查询图书信息。根据后台返回的结果，判断是否查询成功：如果查询成功打开修改面板回显数据，如果失败提示错误信息。</p>
<p>修改完成后“确定”按钮绑定了@click=”handleEdit()”，在method的handleEdit方法中发送异步请求提交修改数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//弹出编辑窗口</span><br><span class="line">handleUpdate(row) &#123;</span><br><span class="line">    axios.get(&quot;/books/&quot; + row.id).then((res)=&gt;&#123;</span><br><span class="line">        // 展示弹层，加载数据</span><br><span class="line">        if(res.data.code == 20041)&#123;</span><br><span class="line">            this.formData = res.data.data;</span><br><span class="line">            this.dialogFormVisible4Edit = true;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            this.$message.error(res.data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">//编辑</span><br><span class="line">handleEdit() &#123;</span><br><span class="line">    axios.put(&quot;/books&quot;, this.formData).then((res)=&gt;&#123;</span><br><span class="line">        // 如果操作成功，关闭弹层，显示数据</span><br><span class="line">        if(res.data.code == 20031)&#123;</span><br><span class="line">            this.dialogFormVisible4Edit = false;</span><br><span class="line">            this.$message.error(&quot;修改成功！&quot;);</span><br><span class="line">        &#125; else if(res.data.code == 20030)&#123;</span><br><span class="line">            this.$message.error(&quot;修改失败！&quot;);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            this.$message.error(res.data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(()=&gt;&#123;</span><br><span class="line">        this.getAll();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>删除功能</strong></p>
<p>”删除“按钮上绑定了@click=”handleDelete(scope.row)”，method的handleDelete方法弹出提示框。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除</span><br><span class="line">handleDelete(row) &#123;</span><br><span class="line">    this.$confirm(&quot;此操作永久删除当前数据，是否继续？&quot;,&quot;提示&quot;,&#123;</span><br><span class="line">        type:&#x27;info&#x27;</span><br><span class="line">    &#125;).then(()=&gt;&#123;</span><br><span class="line">        //2.做删除业务</span><br><span class="line">        axios.delete(&quot;/books/&quot;+row.id).then((res)=&gt;&#123;</span><br><span class="line">            if(res.data.code == 20021)&#123;</span><br><span class="line">                this.$message.success(&quot;删除成功&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                this.$message.error(&quot;删除失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).finally(()=&gt;&#123;</span><br><span class="line">            this.getAll();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">        //3.取消删除</span><br><span class="line">        this.$message.info(&quot;取消删除操作&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><img src="image-20230621112011258.png" alt="image-20230621112011258" style="zoom:77%;" />

<p>(1) 浏览器发送一个请求会先到Tomcat的web服务器；</p>
<p>(2) Tomcat服务器接收到请求以后，会去判断请求的是静态资源还是动态资源；</p>
<p>(3) 如果是静态资源，会直接到Tomcat的项目部署目录下去直接访问；</p>
<p>(4) 如果是动态资源，就需要交给项目的后台代码进行处理；</p>
<p>(5) 在找到具体的方法之前，我们可以去配置过滤器(可以配置多个)，按照顺序进行执行；</p>
<p>(6) 然后进入到到中央处理器(SpringMVC中的内容)，SpringMVC会根据配置的规则进行拦截；</p>
<p>(7) 如果满足规则，则进行处理，找到其对应的controller类中的方法进行执行，完成后返回结果；</p>
<p>(8) 如果不满足规则，则不进行处理；</p>
<p>(9) 这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现？——拦截器</p>
<p><strong>拦截器</strong>（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行：在指定的方法调用前后执行预先设定的代码来阻止原始方法的执行。</p>
<blockquote>
<p>SpringMVC的拦截器和Servlet的过滤器的区别：</p>
<p>归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术；</p>
<p>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强。</p>
</blockquote>
<h3 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h3><p><strong>环境准备</strong></p>
<img src="image-20230621180705381.png" alt="image-20230621180705381" style="zoom:87%;" />

<h4 id="拦截器开发"><a href="#拦截器开发" class="headerlink" title="拦截器开发"></a>拦截器开发</h4><p>步骤1：在controller表现层创建拦截器类</p>
<p>让类实现HandlerInterceptor接口，重写接口中的三个方法。<strong>同时要注意Interceptor类必须受Spring容器控制和被SpringMVC扫描到。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 注意当前类必须受Spring容器控制</span></span><br><span class="line"><span class="comment">// 定义拦截器类，实现HandlerInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：配置拦截器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(<span class="string">&quot;/books&quot;</span>, <span class="string">&quot;/books/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动装配前面创建的拦截器类，在Support配置中配置拦截的路径。</p>
<p>步骤3：SpringMvcConfig添加SpringMvcSupport包(config包下)扫描</p>
<blockquote>
<p>当拦截器拦截的路径是(“/books”)时，则发送<a href="http://localhost/books/100%E4%BC%9A%E5%8F%91%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B2%A1%E6%9C%89%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C">http://localhost/books/100会发现拦截器没有被执行，</a> 因为没有匹配上，想要拦截则要设置”/books/*”。</p>
</blockquote>
<p>当有拦截器后，请求会先进入preHandle方法，如果方法返回true，则放行继续执行后面的handle（controller的方法）和后面的方法；如果返回false，则直接跳过后面方法的执行。</p>
<img src="image-20230621182504009.png" alt="image-20230621182504009" style="zoom:87%;" />

<p>（可选）步骤4：简化SpringMvcSupport的编写</p>
<p>在SpringMvcConfig中实现WebMvcConfigurer接口后面就不用写SpringMvcSupport配置类了，但具有一定的侵入性。</p>
<h3 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h3><p><strong>前置处理方法</strong></p>
<p>request：请求对象</p>
<p>response：响应对象</p>
<p>handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装</p>
<p>使用request对象可以获取请求数据中的内容，如获取请求头的Content-Type（<font color="blue">要使用post请求</font>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle...&quot;</span> + contentType);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用handler参数，可以获取方法的相关信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">hm</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> hm.getMethod().getName();  <span class="comment">//可以获取方法的名称</span></span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle...&quot;</span> + contentType + <span class="string">&quot;, &quot;</span> + methodName);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后置处理方法</strong></p>
<p>原始方法运行后运行，如果原始方法被拦截，则不执行。</p>
<p>modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整。因为现在都是返回json数据，所以该参数的使用率不高。</p>
<p><strong>完成处理方法</strong></p>
<p>拦截器最后执行的方法，无论原始方法是否执行。</p>
<p>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理。因为现在已经有全局异常处理器类，所以该参数的使用率也不高。</p>
<p><strong>总结</strong></p>
<p>这三个方法中，最常用的是<strong>preHandle</strong>，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截。</p>
<h3 id="拦截器链配置"><a href="#拦截器链配置" class="headerlink" title="拦截器链配置"></a>拦截器链配置</h3><p>步骤1：创建多个拦截器类ProjectInterceptor1、ProjectInterceptor2…</p>
<p>步骤2：配置拦截器链</p>
<p>拦截器执行的顺序是和配置顺序有关：先进后出（preHandle是与配置顺序相同，必定运行的）。</p>
<p>执行过程：当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行；当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作，见下图所示：</p>
<img src="image-20230621185149653.png" alt="image-20230621185149653" style="zoom:67%;" />
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>04-AOP</title>
    <url>/2023/06/02/04-AOP/</url>
    <content><![CDATA[<p>前面对Spring介绍时说过，Spring有两个核心的概念，一个是IOC/DI，另一个就是AOP。接下来要学习AOP了，AOP总的来说就是在不改变原有代码的前提下对其进行增强。</p>
<span id="more"></span>

<h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p>AOP(Aspect Oriented Programming)面向切面编程，是一种编程范式，指导开发者组织程序结构。（熟知的oop也是一种编程范式）</p>
<h3 id="AOP作用"><a href="#AOP作用" class="headerlink" title="AOP作用"></a>AOP作用</h3><p>在不惊动原始设计的基础上为其进行功能增强。（前面有技术可以实现这样的功能，即代理模式）</p>
<h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>Spring的AOP的核心就是在不改动原始代码的前提下，想给谁添加功能就给谁添加，这个也是Spring的理念：无侵入式。</p>
<p>那Spring是如何做到的呢？</p>
<p><img src="image-20230602170709205.png" alt="image-20230602170709205"></p>
<ul>
<li><p>连接点：Spring的AOP是对一个类的方法在不进行任何修改前提下进行增强。对于save, update, delete, select方法，叫做<strong>连接点</strong>。</p>
</li>
<li><p>切入点：update和delete只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能；那也就是说update和delete方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫<strong>切入点</strong>（匹配连接点进行数据增强的式子）。</p>
</li>
<li><p>通知：执行update和delete方法时都被添加了一个计算执行万次消耗时间的功能，将这个功能抽取到一个方法中，也就是一个存放共性功能的方法中，我们叫这个方法为<strong>通知</strong>（在切入点处执行的操作）；方法存在的类叫做<strong>通知类</strong>。</p>
</li>
<li><p>切面：通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，需要对通知和切入点的关系有一个明确的描述，这个关系描述我们叫做<strong>切面</strong>。</p>
</li>
</ul>
<h2 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h2><p>需求分析：使用SpringAOP的注解方式完成在方法执行前打印出系统当前时间。</p>
<h3 id="AOP操作思路"><a href="#AOP操作思路" class="headerlink" title="AOP操作思路"></a>AOP操作思路</h3><p>1、导入坐标（pom.xml）</p>
<p>2、制作连接点（原始操作，比如Dao接口和实现类）</p>
<p>3、制作共性功能（通知类与通知）</p>
<p>4、定义切入点（那些连接点需要被增强）</p>
<p>5、绑定切入点和通知的关系（切面）</p>
<h3 id="AOP实现步骤"><a href="#AOP实现步骤" class="headerlink" title="AOP实现步骤"></a>AOP实现步骤</h3><ul>
<li><p>导入<code>spring</code>和<code>aspectj</code>依赖坐标</p>
<p>aop依赖是spring的子包，所以不需要单独导入了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>制作连接点——添加Dao接口和Impl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;Book dao save...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book dao upodate...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建SpringConfig配置类和App主程序运行类</p>
</li>
<li><p>定义通知类和通知</p>
<p>通知就是将共性功能抽取出来形成的方法，类名和方法名都自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 将共性抽取出来形成的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义切入点（连接点中的哪些方法需要增强）</p>
<p>我们要增强连接点中的update方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">		<span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">    <span class="comment">// 将共性抽取出来形成的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    ① 切入点定义依托一个不具有实际意义的方法（无参数、无返回值、方法体无逻辑）进行；</p>
<p>​    ② <code>Pointcut</code>后面<code>execution</code>内的内容，是连接点的返回值+具体的连接点方法。</p>
<ul>
<li><p>制作切面（切面用来描述通知和切入点之间的联系）</p>
<p>指定通知添加到原始连接点的具体执行位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">		<span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">  	<span class="meta">@Before(&quot;fn()&quot;)</span>  <span class="comment">// 通知会在切入点方法执行之前执行</span></span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">    <span class="comment">// 将共性抽取出来形成的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将通知类配给容器并标识其为切面类</p>
<p>将通知类通过<code>@Component</code>注释配置为一个Bean；再通过<code>@Aspect</code>注释将其配置为可以使用AOP的通知类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开启注释格式AOP功能（<code>@EnableAspectJAutoProxy</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span>  <span class="comment">// 默认会扫描该类所在的包下所有的配置类</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 配置类中开启AOP功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAOP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现在执行update方法前打印了系统的时间戳，说明对原始update方法进行了功能增强，AOP编程成功。</p>
</li>
</ul>
<h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><p>1、配置类注解<code>@EnableAspectJAutoProxy</code>：开启注释格式的AOP功能；</p>
<p>2、通知类注解<code>@Aspect</code>：设置当前类为AOP切面类；</p>
<p>3、切入点方法注解<code>@Pointcut</code>，设置切入点方法；</p>
<p>4、通知方法注解<code>@Before</code>，设置当前通知方法与切入点之间的绑定关系。</p>
<h2 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h2><p>由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起。</p>
<h3 id="AOP流程"><a href="#AOP流程" class="headerlink" title="AOP流程"></a>AOP流程</h3><ul>
<li>流程1：Spring容器启动</li>
</ul>
<p>​        容器启动就需要去加载bean：像需要被增强的类、通知类等都需要被加载。（此时bean对象还没有被创建成功）</p>
<ul>
<li><p>流程2：读取所有切面配置中的切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">  	<span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.save())&quot;)</span>  </span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fnx</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  	<span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="meta">@Before(&quot;fn()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码有两个切入点的配置，但是第一个<code>fnx()</code>并没有被使用，所以不会被读取。</p>
</li>
<li><p>流程3：初始化bean</p>
<p>判定bean对应的类中的方法是否匹配到任意切入点：</p>
<img src="image-20230602194257798.png" alt="image-20230602194257798" style="zoom:67%;" />

<ul>
<li>匹配失败：创建原始对象，如UserDao（匹配失败则说明不需要增强，直接调用原始对象的方法即可）；</li>
<li>匹配成功：创建原始对象的<strong>代理对象</strong>，如BookDao（匹配成功则说明需要增强，；对哪个类进行增强，这个类对应的对象就叫做目标对象；由于要对目标对象进行功能增强，而采用的是动态代理技术，所以会为其创建一个代理对象；最终运行的是代理对象的方法，该方法对原始方法进行了功能增强）。</li>
</ul>
</li>
<li><p>流程4：获取bean执行方法</p>
<ul>
<li>获取的bean是原始对象，调用方法并执行，完成操作；</li>
<li>获取的bean是代理对象，根据代理对象的运行模式运行原始方法和增强内容，完成操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>验证IOC容器中创建的对象是原始对象还是代理对象：通过<code>.getClass()</code>实现：</p>
<p><img src="image-20230602195821441.png" alt="image-20230602195821441"></p>
<p>值得注意的是：不能直接打印对象，因为直接打印对象走的是对象的toString()方法，内部对该方法进行了重写，无论是否是代理方法打印的结果都相同。</p>
</blockquote>
<h3 id="AOP核心概念-1"><a href="#AOP核心概念-1" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>这里主要讲一下前面提到的目标对象和代理：</p>
<p>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的。</p>
<p>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象来实现。</p>
<p>目标对象就是要增强的类（比如说BookServiceImpl类）对应的对象，也叫原始对象，不是说他不能运行而是他在运行过程中对于要增强的内容是缺失的；SpringAOP是在不改变原有设计的前提下进行内容增强，他底层采用的是代理模式实现的，所以要对原始对象创建代理对象，在代理对象中的方法把通知内容（如MyAdvice类中的method方法）加进去，实现了增强，这就是我们所说的代理。</p>
<h2 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h2><h3 id="AOP切入点表达式"><a href="#AOP切入点表达式" class="headerlink" title="AOP切入点表达式"></a>AOP切入点表达式</h3><img src="image-20230602202402159.png" alt="image-20230602202402159" style="zoom:67%;" />

<p>切入点：要进行增强的方法；切入点表达式：要进行增强的方法的描述方式。对于切入点表达式，需要掌握三块内容：语法格式、通配符、书写技巧。</p>
<h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以有两种表达式的描述方式：</p>
<p>描述方式1：执行BookDao接口下的无参update方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br></pre></td></tr></table></figure>

<p>描述方式2：执行BookDaoImpl实现类中的无参update方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.impl.BookDaoImpl.update())&quot;)</span></span><br></pre></td></tr></table></figure>

<p>所以切入点表达式的语法是：<code>动作关键词([访问修饰符] 返回值 包名.类/接口名.方法名(参数) [异常名])</code>，（”[]”表示可省略）</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>切入点表达式就是要找到具体增强的方法，但是需要增强的方法有很多，如果每一个方法都要对应一个切入点表达式就比较繁琐，所以用通配符来描述切入点，简化之前的配置。</p>
<ul>
<li><p><code>*</code>：单个独立的任意符号，可以独立出现，也可以作为前缀或后缀的匹配符出现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * com.Lijiacheng.*.UserService.find*(*))</span><br></pre></td></tr></table></figure>

<p>匹配com.Lijiacheng包下任意包中的UserService类或接口中所有find开头的带有一个方法参数的方法；</p>
</li>
<li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> User com..UserService.findById(..))</span><br></pre></td></tr></table></figure>

<p>匹配com包下任意包中的UserService类或接口中所有名称为findById的方法；</p>
</li>
<li><p><code>+</code>：专用于匹配子类类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure>

<p>这个使用率很低。<code>*Service+</code>表示所有以Service结尾的接口的子类。</p>
</li>
</ul>
<h4 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h4><p>1、描述切入点通常描述接口，而不描述实现类，如果描述到实现类，就出现紧耦合；</p>
<p>2、访问控制修饰符针对接口开发均采用public（可省略）；</p>
<p>3、返回值类型对于增删改查使用精准匹配，对于查询类使用<code>*</code>快速匹配；</p>
<p>4、包名书写尽量不使用<code>..</code>匹配，效率过低；常使用<code>*</code>做单个包描述匹配，或精准匹配；</p>
<p>5、接口名/类名采用<code>*</code>匹配，例如UserService书写成*Service，绑定业务层接口；</p>
<p>6、方法名书写以动词精准匹配，例如getById书写成getBy*，selectAll书写成selectAll。</p>
<h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><p>AOP通知描述了抽取的共性功能，AOP需要将通知和切入点进行绑定，并指定增强内容的执行位置。</p>
<h4 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h4><p>1、前置通知：追加功能到方法执行前；</p>
<p>2、后置通知：追加功能到方法执行后，不论方法执行过程中有没有抛出异常都会执行；</p>
<p>3、返回后通知：追加功能到方法执行后，但是只有方法正常执行结束后才进行，如果方法执行抛出异常，返回后通知将不被执行；</p>
<p>4、抛出异常后通知：追加功能到方法抛出异常后，只有方法抛出异常后才会被添加；</p>
<p>5、环绕通知：可以追加到方法执行的前后，最常用的方式。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>具体就不展开了，创建好的项目结构如下：</p>
<img src="image-20230603105052343.png" alt="image-20230603105052343" style="zoom:67%;" />

<h4 id="通知类型的使用"><a href="#通知类型的使用" class="headerlink" title="通知类型的使用"></a>通知类型的使用</h4><ul>
<li><p>前置通知：修改MyAdvice，在before方法上加<code>@Before</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;		</span><br><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;before advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20230603105857801.png" alt="image-20230603105857801"></p>
<ul>
<li><p>后置通知：修改MyAdvice，加<code>@After</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;after advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230603110109029.png" alt="image-20230603110109029"></p>
</li>
<li><p>环绕通知：修改MyAdvice，加<code>@Around</code>注解</p>
<p>相比于前置和后置通知，环绕通知需要在原始内容的前后进行内容增强，所以我们需要指定哪些内容在原始内容前执行，哪些内容在原始内容后执行，所以必须能对原始操作进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;around before advice...&quot;</span>);</span><br><span class="line">      pjp.proceed();  <span class="comment">// 对原始操作进行调用</span></span><br><span class="line">      System.out.println(<span class="string">&quot;around after advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20230603112123746.png" alt="image-20230603112123746"></p>
<p>​    刚才针对的是原始方法无返回值的情况，原始方法有返回值的情况如何处理呢？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* =================实现类中的原始方法=============== */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Book dao select is running...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    修改通知，返回值设置为通用的Object基类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* =================通知类======================== */</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(int com.Lijiacheng.dao.BookDao.select())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;around before advice...&quot;</span>);</span><br><span class="line">      <span class="comment">// 对原始操作进行调用</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">      System.out.println(<span class="string">&quot;around after advice...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    当原始方法有返回值时，需要根据原始方法的返回值设置环绕通知的返回值，否则就会报如下的错误：大概意思是空的返回不匹配原始方法的返回值。</p>
<p><img src="image-20230603112555069.png" alt="image-20230603112555069"></p>
<ul>
<li><p>返回后通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;afterReturning advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    返回后通知是需要在原始方法select正常执行后才会被执行，如果select方法在执行过程中出现了异常，那么返回后通知是不会被执行的（而后置通知是无论是否抛出异常都会被执行）：</p>
<p><img src="image-20230603124407104.png" alt="image-20230603124407104"></p>
<ul>
<li><p>异常后通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(&quot;pt2()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;afterThrowing advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>异常后通知只有在抛出异常时才会被执行：</p>
<p><img src="image-20230603124717297.png" alt="image-20230603124717297"></p>
</li>
</ul>
<p>​    <strong>环绕通知总结</strong>：环绕通知可以控制原始方法执行，所以把增强的代码写在调用原始方法的前后位置，就可以实现不同通知类型的功能：</p>
<img src="image-20230603124957569.png" alt="image-20230603124957569" style="zoom:67%;" />

<p>​            （1）环绕通知依赖形参<code>ProceedingJoinPoint</code>才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知；</p>
<p>​            （2）环绕通知未使用<code>ProceedingJoinPoint</code>调用原始方法，将跳过原始方法的执行；</p>
<p>​            （3）最好将环绕通知的返回值都设置成Object；</p>
<p>​            （4）环绕通知无法预知调用的原始方法是否会抛出异常，所以在通知方法要手动抛出Throwable异常。</p>
<h3 id="业务层接口执行效率"><a href="#业务层接口执行效率" class="headerlink" title="业务层接口执行效率"></a>业务层接口执行效率</h3><p>需求分析：任意业务层接口执行均可显示其执行时长。</p>
<p>实现思路：开始执行方法前记录一个时间，执行方法结束后记录一个时间，得到的时间差值就是执行效率。要在原始方法前后添加业务，就用到环绕通知。</p>
<h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p>具体就不展开了，如果不熟悉了要记得复习前面的博客，创建好的项目结构如下：</p>
<img src="image-20230603170251563.png" alt="image-20230603170251563" style="zoom:80%;" />

<h4 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h4><p>步骤1：开启SpringAOP的注释功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure>

<p>步骤2：创建AOP的通知类</p>
<p>① 通知类要被Spring管理，添加<code>@Component</code>注释；② 要标识通知类是个切面类，添加<code>@Aspect</code>注释；③ 配置切入点表达式，需要添加一个方法并添加<code>@Pointcut</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.Lijiacheng.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：添加环绕通知（目前没有任何增强）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：完成核心业务，记录万次执行时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">    pjp.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;万次执行时间为: &quot;</span> + (endTime-startTime) + <span class="string">&quot; ms&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>步骤5：运行单元测试类（注意看单元测试类怎么写）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTestCase</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; acs = accountService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此时无法知道是哪个接口的哪个方法执行耗时：</p>
<p><img src="image-20230603225751338.png" alt="image-20230603225751338"></p>
<p>所以我们要对步骤4的核心业务代码进行优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="comment">// 获取执行签名信息</span></span><br><span class="line">      <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();</span><br><span class="line">      <span class="comment">// 通过签名获取执行操作名称(接口名)</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">      <span class="comment">// 通过签名获取执行操作名称(方法名)</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">      <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">          pjp.proceed();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;万次执行时间为: &quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;-----&gt;&quot;</span> + (endTime-startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230603230159251.png" alt="image-20230603230159251"></p>
<h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><p>刚才写AOP仅是在原始方法前后追加一些操作，接下来要说一下AOP中数据相关内容，主要有：获取参数、获取返回值、获取异常。</p>
<ul>
<li><p>获取切入点方法的参数</p>
<ul>
<li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li>
<li>ProceedingJoinPoint：适用于环绕通知</li>
</ul>
</li>
<li><p>获取切入点方法的返回值：主要研究返回后通知和环绕通知；</p>
</li>
<li><p>获取切入点方法的异常信息：主要研究抛出异常后通知和环绕通知。</p>
</li>
</ul>
<h4 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h4><p><img src="image-20230603235831233.png" alt="image-20230603235831233"></p>
<h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><ul>
<li><p>非环绕通知获取方式：在方法上添加JoinPoint，通过JoinPoint来获取参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;fn()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">      Object[] args = jp.getArgs();</span><br><span class="line">      System.out.println(Arrays.toString(args));  <span class="comment">// 将数组以字符串的形式输出</span></span><br><span class="line">      System.out.println(<span class="string">&quot;before advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>环绕通知获取方式：环绕通知使用的是ProceedingJoinPoint</p>
<p>因为ProceedingJoinPoint是JoinPoint类的子类，所以ProceedingJoinPoint一定有getArgs()方法.</p>
<p><img src="image-20230604095226979.png" alt="image-20230604095226979"></p>
<p>此外值得注意的是，<code>pjp.proceed</code>有两个方法都可以完成功能：①调用无参数的proceed方法，当原始方法有参数时，会在调用的过程中自动传入参数；②但是当需要修改原始方法的参数时，必须采用带有参数的proceed方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;fn()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span><span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">      Object[] args = pjp.getArgs();</span><br><span class="line">      System.out.println(Arrays.toString(args));</span><br><span class="line">      args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);  <span class="comment">// 将args作为参数传回原始调用方法</span></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性。</p>
</blockquote>
</li>
</ul>
<h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><p>对于返回值只有返回后AfterReturing和环绕Around这两个通知类型可以获取。</p>
<ul>
<li><p>环绕通知获取返回值</p>
<p>和环绕通知获取参数一样，ret就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改。</p>
</li>
<li><p>返回后通知获取返回值（注意<code>returning</code>的值与通知方法的形参名一定要一致！）</p>
</li>
</ul>
<p><img src="image-20230604100651690.png" alt="image-20230604100651690"></p>
<p>​    根据以下代码分析一下程序执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ===================主程序执行======================= */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bookDao.findName(<span class="number">100</span>, <span class="string">&quot;hfut&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">/* ===================实现类======================== */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;lijiacheng&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    首先调用bookDao接口中的切入点方法findName，由于切面是返回后通知，所以优先执行原始方法；原始方法将返回值“lijiacheng”赋值给name变量后，执行返回后通知的增强内容，也就是获取返回值并将返回值修改为”liaoziting”并打印；最后一步再打印出第一步得到的name变量值。如下结果所示：</p>
<p><img src="image-20230604101417654.png" alt="image-20230604101417654"></p>
<blockquote>
<p>有一个非常关键的点，当AfterReturning有JoinPoint参数时，必须将其放在第一位，否则将会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp, Object ret)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="获取异常（了解）"><a href="#获取异常（了解）" class="headerlink" title="获取异常（了解）"></a>获取异常（了解）</h4><p>对于获取抛出异常，只有抛出异常后AfterThrowing和环绕Around这两个通知可以获取。</p>
<ul>
<li><p>环绕通知获取异常：以前我们是抛出异常，现在只需要将异常捕获，就可以获取到原始方法的异常信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;fn()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">      Object[] args = pjp.getArgs();</span><br><span class="line">      System.out.println(Arrays.toString(args));</span><br><span class="line">      args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ret = pjp.proceed(args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抛出异常后通知获取异常：也是要注意<code>throwing</code>的值和通知方法的形参值要一致！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;fn()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;afterThrowing advice... ----&gt;&quot;</span> + t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20230604102743788.png" alt="image-20230604102743788"></p>
<h3 id="AOP案例：百度网盘密码数据兼容处理"><a href="#AOP案例：百度网盘密码数据兼容处理" class="headerlink" title="AOP案例：百度网盘密码数据兼容处理"></a>AOP案例：百度网盘密码数据兼容处理</h3><p>需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理。</p>
<p>以后涉及到需要去除前后空格的业务可能会有很多，这个去空格的代码是每个业务都写么？当功能的泛化性很强时，我们考虑使用AOP来统一处理。要做到这一点，我们先要在业务方法执行之前对所有的输入参数进行格式处理、再使用处理后的参数调用原始方法。</p>
<p>因为要先获取原始方法的参数，进行处理后再将参数传回给原始方法，所以必须用到<code>ProceedingJoinPoint</code>中的proceed方法，也就是只能使用环绕通知来实现。</p>
<h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230604105322777.png" alt="image-20230604105322777" style="zoom:80%;" />

<p>当输入密码为”root”控制台打印为true,如果密码改为” root “（前后有空格）控制台打印的是false。需求是使用AOP将参数进行统一处理，不管输入的密码前后包含多少个空格，最终控制台打印的都是true。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>不多叨叨，直接展示业务核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;fn()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">passwordTrim</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 核心业务 1、获取参数并格式处理  2、交还给原始方法</span></span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 判断是否为字符串</span></span><br><span class="line">        <span class="keyword">if</span>(args[i].getClass().equals(String.class))&#123;</span><br><span class="line">            args[i] = args[i].toString().trim();  <span class="comment">// toString()返回对象的字符串形式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP总结-1"><a href="#AOP总结-1" class="headerlink" title="AOP总结"></a>AOP总结</h2><p><strong>AOP（Aspect Oriented Programming）面向切面编程</strong></p>
<p>AOP是一种编程范式，作用是在不惊动原始设计的基础上为方法进行功能增强。</p>
<p>（1）代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的</p>
<p>（2）连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</p>
<p>（3）切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</p>
<p>（4）通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</p>
<p>（5）切面（Aspect）：描述通知与切入点的对应关系</p>
<p>（6）目标对象（Target）：被代理的原始对象称为目标对象</p>
<p><strong>切入点表达式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution([访问修饰符] 返回值 包名.类/接口名.方法名（参数）[异常名])</span><br></pre></td></tr></table></figure>

<p>三种通配符：<code>*</code>, <code>..</code>, <code>+</code>.</p>
<p><strong>五种通知类型</strong></p>
<p>前置通知、后置通知、环绕通知（重点）、返回后通知、抛出异常后通知.</p>
<p>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用；它可以隔离原始方法的执行；它可以获取原始方法的参数或返回值并进行修改再交还给原始方法；它可以对原始方法的异常进行处理。</p>
<p><strong>通知中获取参数</strong></p>
<ul>
<li><p>获取切入点方法的参数：JoinPoint和ProceedingJoinPoint</p>
</li>
<li><p>获取切入点方法返回值<code>Returning</code>：返回后通知、环绕通知</p>
</li>
<li><p>获取切入点方法运行异常信息<code>Throwing</code>：抛出异常后通知、环绕通知</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>03-Spring整合三方框架</title>
    <url>/2023/06/01/03-Spring%E6%95%B4%E5%90%88%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方Bean了，下面结合IoC和DI，整合Mybatis框架，加深对Spring的理解。</p>
<span id="more"></span>

<h2 id="Spring整合Mybatis（2）"><a href="#Spring整合Mybatis（2）" class="headerlink" title="Spring整合Mybatis（2）"></a>Spring整合Mybatis（2）</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>04-Request_Response</title>
    <url>/2023/04/01/04-Request-Response/</url>
    <content><![CDATA[<p>request和response对象代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行；要向容器输出数据，只需要找response对象就行。</p>
<span id="more"></span>

<h1 id="Resquest-amp-Response"><a href="#Resquest-amp-Response" class="headerlink" title="Resquest &amp; Response"></a>Resquest &amp; Response</h1><h2 id="Request和Response的概述"><a href="#Request和Response的概述" class="headerlink" title="Request和Response的概述"></a>Request和Response的概述</h2><p>Request是请求对象，Response是响应对象。这两个对象在我们使用Servlet的时候有看到：</p>
<img src="image-20230328123304964-0344182.png" alt="image-20230328123304964" style="zoom: 50%;" />

<ul>
<li>request：获取请求数据<ul>
<li>浏览器会发送HTTP请求到后台服务器(Tomcat)</li>
<li>HTTP的请求中会包含很多请求数据（请求行+请求头+请求体）</li>
<li>后台服务器(Tomcat)会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中</li>
<li>所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数</li>
<li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务</li>
</ul>
</li>
<li>response：设置响应数据<ul>
<li>业务处理完后，后台就需要给前端返回业务处理的结果即响应数据</li>
<li>把响应数据封装到response对象中</li>
<li>后台服务器(Tomcat)会解析response对象,按照（响应行+响应头+响应体）格式拼接结果</li>
<li>浏览器最终解析结果，把内容展示在浏览器给用户浏览</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 使用request对象，获取请求数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);  <span class="comment">// url?name=lijiacheng</span></span><br><span class="line">        <span class="comment">// 使用response对象，设置响应数据</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;&lt;h1&gt;&quot;</span> + name + <span class="string">&quot;，欢迎您！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230328142421229.png" alt="image-20230328142421229"></p>
<p><code>request</code>对象用来处理来自客户端的请求数据，比如接收请求参数等；<code>responese</code>对象根据接收的数据进一步设置发送给客户端的响应数据。</p>
<h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><h3 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h3><img src="image-20230328142607415-0344182.png" alt="image-20230328142607415" style="zoom:50%;" />

<p><code>ServletRequest</code>和<code>HttpServletRequest</code>都是Java提供的接口，接口无法创建对象。</p>
<img src="image-20230328142751256-0344182.png" alt="image-20230328142751256" style="zoom:67%;" />

<p>这个时候，我们就需要用到Request继承体系中的<code>RequestFacade</code>：</p>
<ul>
<li>该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口；</li>
<li>Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器([Tomcat)来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建。</li>
</ul>
<blockquote>
<p>Tomcat（RequestFacade实现类）需要解析请求数据，封装为request对象,并且创建request对象传递到service方法</p>
</blockquote>
<h3 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h3><h4 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取请求行数据</h4><img src="image-20230328143450032-0344182.png" alt="image-20230328143450032" style="zoom:67%;" />

<ul>
<li>获取请求方式: <code>GET</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getMethod</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取虚拟目录(项目访问路径): <code>/JavaWeb_04_Request_Response</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getContextPath</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取URL(统一资源定位符): <code>http://localhost:8080/JavaWeb_04_Request_Response/req1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer <span class="title function_">getRequestURL</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取URI(统一资源标识符): <code>/JavaWeb_04_Request_Response/req1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getRequestURI</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取请求参数**(GET方式)**: <code>username=zhangsan&amp;password=123</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getQueryString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>由上到下依次获取的结果：</p>
<img src="image-20230328144502256-0344182.png" alt="image-20230328144502256" style="zoom: 80%;" />

<h4 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h4><p>根据请求头名称获取对应值的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getHeader</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure>

<h4 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取请求体数据</h4><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为<font color="red">POST</font>，请求体中的数据格式如下：</p>
<img src="image-20230328144816822-0344182.png" alt="image-20230328144816822" style="zoom:67%;" />

<p>请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是：</p>
<ul>
<li><p>获取<strong>字节输入流</strong>，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取<strong>字符输入流</strong>，如果前端发送的是纯文本数据，则使用该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader <span class="title function_">getReader</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>在<code>req.html</code>中创建form表单传递请求参数，获取字符输入流读取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 获取post的请求体数据</span></span><br><span class="line">    <span class="comment">//1. 获取字符输入流</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">    <span class="comment">//2. 读取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到的POST方法的请求体数据：</p>
<p><img src="image-20230328145615868-0344182.png" alt="image-20230328145615868"></p>
<h4 id="获取请求参数的通用方式"><a href="#获取请求参数的通用方式" class="headerlink" title="获取请求参数的通用方式"></a>获取请求参数的通用方式</h4><blockquote>
<p>请求数据则是包含请求行、请求头和请求体的所有数据。请求参数和请求数据的关系：请求参数是请求数据中的部分内容；如果是GET请求，请求参数在请求行中；如果是POST请求，请求参数一般在请求体中。</p>
</blockquote>
<p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种统一获取请求参数的方式，从而统一doGet和doPost方法内的代码?</p>
<p><code>request</code>的方法中实现了如下操作：</p>
<p>（1）根据不同的请求方式获取请求参数，获取的内容如下:</p>
<p><img src="image-20230328161112744-0344182.png" alt="image-20230328161112744"></p>
<p>（2）把获取到的内容进行分割：</p>
<img src="image-20230328161131859-0344182.png" alt="image-20230328161131859" style="zoom: 50%;" />

<p>（3）把分割后端数据，存入到一个Map集合中：</p>
<img src="image-20230328161211660-0344182.png" alt="image-20230328161211660" style="zoom: 50%;" />

<p>基于上述操作，<code>request</code>对象为我们提供了如下方法：</p>
<ul>
<li><p>获取所有参数Map集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; getParameterMap()</span><br></pre></td></tr></table></figure></li>
<li><p>根据名称获取参数值（数组）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] getParameterValues(String name)</span><br></pre></td></tr></table></figure></li>
<li><p>根据名称获取参数值（单个值）——使用频率比较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getParameter</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面进行获取请求参数的演示<strong>（后续使用的方法）</strong>：</p>
<p>（1）创建一个req.html的表单</p>
<img src="image-20230328162535194-0344182.png" alt="image-20230328162535194" style="zoom: 67%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/JavaWeb_04_Request_Response/req2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 游泳</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 爬山 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在Servlet代码中获取页面传递请求的参数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有参数的map集合</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">for</span>(String value : values)&#123;</span><br><span class="line">                System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GET方式传递请求参数：</p>
<p><img src="image-20230328163623631-0344182.png" alt="image-20230328163623631"></p>
<p>后端接收到的GET方式的请求参数：</p>
<p><img src="image-20230328163711898-0344182.png" alt="image-20230328163711898"></p>
<p>剩下两个<code>getParameterValues()</code>和<code>getParameter()</code>一个return类型是<code>String[]</code>，一个return类型是<code>String</code>，按需使用即可，这里就不展示了。</p>
<p>在传递POST请求的参数也如上述所示，只需要修改前端表单的请求类型为<code>POST</code>即可，在Servlet类的<code>doPost()</code>里只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.doGet(req,resp);</span><br></pre></td></tr></table></figure>

<h3 id="请求参数中文乱码问题"><a href="#请求参数中文乱码问题" class="headerlink" title="请求参数中文乱码问题"></a>请求参数中文乱码问题</h3><p>不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。</p>
<h4 id="POST请求解决方案"><a href="#POST请求解决方案" class="headerlink" title="POST请求解决方案"></a>POST请求解决方案</h4><ul>
<li><p>分析出现中文乱码的原因：</p>
<ul>
<li>POST的请求参数是通过request的getReader()来获取流中的数据</li>
<li>TOMCAT在获取流的时候采用的编码是ISO-8859-1</li>
<li>ISO-8859-1编码是不支持中文的，所以会出现乱码</li>
</ul>
</li>
<li><p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>但这种方式不适用于GET请求。</p>
<h4 id="GET请求解决方案"><a href="#GET请求解决方案" class="headerlink" title="GET请求解决方案"></a>GET请求解决方案</h4><p><code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>是设置request处理流的编码，但是GET获取请求参数的方式是<code>request.getQueryString()</code>，它并没有通过流的方式获取参数。</p>
<p>先分析一下GET请求出现乱码的原因：</p>
<img src="image-20230328182439642-0344182.png" alt="image-20230328182439642" style="zoom: 50%;" />

<p>(1)浏览器通过HTTP协议发送请求和数据给后台服务器(Tomcat)</p>
<p>(2)浏览器在发送HTTP的过程中会对中文数据进行URL编码</p>
<p>(3)在进行URL编码的时候会采用页面<code>&lt;meta&gt;</code>标签指定的UTF-8的方式进行编码，“张三”编码后的结果为”%E5%BC%A0%E4%B8%89“</p>
<p>(4)后台服务器(Tomcat)接收到<code>%E5%BC%A0%E4%B8%89</code>后会默认按照<code>ISO-8859-1</code>进行URL解码</p>
<p>(5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。</p>
<p>关于URL编解码，Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.URLEncoder.encode(<span class="string">&quot;需要被编码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)  <span class="comment">// encode</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.URLDecoder.decode(<span class="string">&quot;需要被解码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)  <span class="comment">// decode</span></span><br></pre></td></tr></table></figure>

<p>我们可以发现：在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的<code>%E5%BC%A0%E4%B8%89</code>是一致的，所以具体的解决方案为：① 按照ISO-8859-1编码获取乱码<code>å¼ ä¸</code>对应的字节数组；② 按照UTF-8编码获取字节数组对应的字符串。</p>
<blockquote>
<p>Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8。</p>
</blockquote>
<h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><p>请求转发(forward)是一种在服务器内部的资源跳转方式。</p>
<img src="image-20230328194558560-0344182.png" alt="image-20230328194558560" style="zoom: 33%;" />

<p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求；</p>
<p>(2)资源A处理完请求后将请求发给资源B；</p>
<p>(3)资源B处理完后将结果响应给浏览器；</p>
<p>(4)请求从资源A到资源B的过程就叫<strong>请求转发</strong>。</p>
<p><strong>请求转发的实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;资源B路径&quot;</span>).forward(req,resp);</span><br></pre></td></tr></table></figure>

<p><strong>请求转发资源间共享数据</strong></p>
<p>需要使用request对象提供的三个方法：</p>
<ul>
<li>存储数据到request域[范围,数据是存储在request对象]中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object o)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据key获取值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据key删除该键值对</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>请求转发的特点</strong></p>
<ul>
<li><p>浏览器地址栏路径不发生变化：虽然后台从<code>/req3</code>转发到<code>/req4</code>,但是浏览器的地址一直是<code>/req4</code>，未发生变化</p>
<p><img src="image-20230328195744977-0344182.png" alt="image-20230328195744977"></p>
</li>
<li><p>只能转发到当前服务器的内部资源：不能从一个服务器通过转发访问另一台服务器</p>
</li>
<li><p>一次请求，可以在转发资源间使用request共享数据：虽然后台从<code>/req3转发到</code>/req4`，但是这个只有<font color="red">一次请求</font></p>
</li>
</ul>
<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><h3 id="Response继承体系"><a href="#Response继承体系" class="headerlink" title="Response继承体系"></a>Response继承体系</h3><img src="image-20230328200036194-0344182.png" alt="image-20230328200036194" style="zoom: 50%;" />

<h3 id="Response设置响应数据"><a href="#Response设置响应数据" class="headerlink" title="Response设置响应数据"></a>Response设置响应数据</h3><ul>
<li>响应行</li>
</ul>
<p>对于响应头，比较常用的就是设置响应状态码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> sc)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>响应头</li>
</ul>
<p>设置响应头键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(String name,String value)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>响应体</li>
</ul>
<p>对于响应体，是通过字符、字节输出流的方式往浏览器写。</p>
<p>获取字符输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>获取字节输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Response请求重定向"><a href="#Response请求重定向" class="headerlink" title="Response请求重定向"></a>Response请求重定向</h3><p>Response重定向(redirect)是另一种资源跳转方式。</p>
<img src="image-20230328200601634.png" alt="image-20230328200601634" style="zoom:50%;" />

<p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求；</p>
<p>(2)资源A现在无法处理该请求，就会<font color="red">给浏览器响应</font>一个302状态码和location一个访问资源B的路径；</p>
<p>(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B；</p>
<p>(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向。</p>
<p><strong>重定向实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resposne.setStatus(<span class="number">302</span>);</span><br><span class="line">resposne.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;资源B的访问路径&quot;</span>);  <span class="comment">// &quot;/JavaWeb_04_Request_Response/resp2&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者用简化后的一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resposne.sendRedirect(<span class="string">&quot;/JavaWeb_04_Request_Response/resp2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>重定向的特点</strong></p>
<ul>
<li><p>浏览器地址栏路径发送变化：当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化；</p>
<img src="image-20230328201530915.png" alt="image-20230328201530915" style="zoom: 67%;" /></li>
<li><p>可以重定向到任何位置的资源（服务内容、外部均可）：因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源；</p>
</li>
<li><p>两次请求，不能在多个资源使用request共享数据：因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据。</p>
</li>
</ul>
<p>请求转发和重定向的比较：</p>
<p><img src="image-20230328201650015.png" alt="image-20230328201650015"></p>
<blockquote>
<p><strong>什么时候用项目访问路径，什么时候不需要？</strong></p>
<p>判断的依据很简单，只需要记住下面的规则即可:</p>
<ul>
<li>浏览器使用：需要加虚拟目录(项目访问路径)</li>
<li>服务端使用：不需要加虚拟目录</li>
</ul>
</blockquote>
<p>对于请求转发来说，因为是在服务端进行的，所以不需要加虚拟目录；对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。同时，由于虚拟目录的项目路径是硬编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改。可以在使用虚拟目录时动态配置，降低代码的耦合度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">   response.sendRedirect(contextPath+<span class="string">&quot;/resp2&quot;</span>);  <span class="comment">// 重定向</span></span><br></pre></td></tr></table></figure>

<h3 id="Response响应字符数据"><a href="#Response响应字符数据" class="headerlink" title="Response响应字符数据"></a>Response响应字符数据</h3><p>要想将字符数据写回到浏览器，我们需要两个步骤：</p>
<ul>
<li><p>通过Response对象获取字符输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br></pre></td></tr></table></figure></li>
<li><p>通过字符输出流写数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在之前要记得设置服务器发送给浏览器的数据类型和数据编码格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code>  等于 <code>response.setHeader(&quot;content-type&quot;, &quot;text/html&quot;); </code>和<code>response.setCharacterEncoding(&quot;utf-8&quot;); </code> 两句。</p>
</blockquote>
<p>一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。</p>
<h3 id="Response响应字节数据"><a href="#Response响应字节数据" class="headerlink" title="Response响应字节数据"></a>Response响应字节数据</h3><p>要想将字节数据写回到浏览器，我们需要两个步骤：</p>
<ul>
<li><p>通过Response对象获取字节输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br></pre></td></tr></table></figure></li>
<li><p>通过字节输出流写数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outputStream.write(字节数据);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>实现方式1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            <span class="comment">// 1、读取文件</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/webapp/picture.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、获取response字节流</span></span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">            <span class="comment">// 3、完成流的copy</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现方式2</strong></p>
<p>我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是：</p>
<p>（1）pom.xml添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）调用工具类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IOUtils.copy(fis,os);  <span class="comment">// fis:输入流  os:输出流</span></span><br></pre></td></tr></table></figure>

<p>优化后的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1、读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/webapp/picture.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、获取response字节流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">// 3、完成流的copy</span></span><br><span class="line">        IOUtils.copy(fis,outputStream);</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>05-JSP</title>
    <url>/2023/04/01/05-JSP/</url>
    <content><![CDATA[<p>JSP（全称：Java Server Pages），Java 服务端页面。是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容， <code>JSP = HTML + Java</code>。虽然说JSP技术早已过时了，但是在很多国企银行还在使用它，可以把JSP当作javaweb的发展史来学习一下。</p>
<span id="more"></span>

<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP到底是什么作用呢？在前面我们使用Servlet在网页端进行动态展示，当时使用了<code>writer.write()</code>向前端写html标签内容进行展示，这样我们的代码就显得很麻烦。在JSP中，用html展示静态页面，用java代码展示动态数据，从而简化开发，避免了在Servlet中直接输出HTML标签。</p>
<h2 id="JSP快速入门"><a href="#JSP快速入门" class="headerlink" title="JSP快速入门"></a>JSP快速入门</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, JSP!&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h2><p>JSP 本质上就是一个 Servlet，看一看访问JSP时的流程：</p>
<img src="image-20230329100053695.png" alt="image-20230329100053695" style="zoom:50%;" />

<p>（1）浏览器第一次访问 <code>hello.jsp</code> 页面</p>
<p>（2）<code>tomcat</code> 会将 <code>hello.jsp</code> 转换为名为 <code>hello_jsp.java</code> 的一个 <code>Servlet</code></p>
<p>（3）<code>tomcat</code> 再将转换的 <code>servlet</code> 编译成字节码文件 <code>hello_jsp.class</code></p>
<p>（4）<code>tomcat</code> 会执行该字节码文件，向外提供服务</p>
<p>在Servlet当中是需要我们编写代码将数据write到页面上去，但是在JSP中通过生成相应的Servlet，tomcat自动帮我们完成了这项工作。</p>
<blockquote>
<p>JSP脚本分类：</p>
<ul>
<li>&lt;%…%&gt;：内容会直接放到<code>_jspService()</code>方法之中；</li>
<li>&lt;%=…%&gt;：内容会放到<code>out.print()</code>中，作为out.print()的参数；</li>
<li>&lt;%!…%&gt;：内容会放到<code>_jspService()</code>方法之外，被类直接包含</li>
</ul>
</blockquote>
<p><strong>JSP缺点</strong></p>
<ul>
<li>书写麻烦：既要写 HTML 标签，还要写 Java 代码</li>
<li>前后端没有分离</li>
<li>调试困难：出错后，需要找到自动生成的.java文件进行调试</li>
</ul>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language ）表达式语言，用于简化 JSP 页面内的 Java 代码。</p>
<p>EL 表达式的主要作用是获取数据：就是从域对象中获取数据，然后将数据展示在页面上。而 EL 表达式的语法也比较简单，语法形式为：<code>$&#123;expression&#125;</code> 。例如：<code>$&#123;brands&#125; </code>就是获取域中存储的 key 为 brands 的数据。</p>
<p>我们定义一个Servlet，在域对象中存储一些数据，然后通过数据共享（请求转发）的方式令JSP资源获取数据并展示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        List&lt;Brand&gt; brands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Brand&gt;();</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">1</span>,<span class="string">&quot;三只松鼠&quot;</span>,<span class="string">&quot;三只松鼠&quot;</span>,<span class="number">100</span>,<span class="string">&quot;三只松鼠，好吃不上火&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">2</span>,<span class="string">&quot;优衣库&quot;</span>,<span class="string">&quot;优衣库&quot;</span>,<span class="number">200</span>,<span class="string">&quot;优衣库，服适人生&quot;</span>,<span class="number">0</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">3</span>,<span class="string">&quot;小米&quot;</span>,<span class="string">&quot;小米科技有限公司&quot;</span>,<span class="number">1000</span>,<span class="string">&quot;为发烧而生&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        req.setAttribute(<span class="string">&quot;brands&quot;</span>,brands);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>index.jsp</code>资源中通过EL表达式获取数据到页面即可，但是<font color="red">要注意在标签中加入<code>isELIgnored=&quot;false&quot;</code></font>表示不忽略EL表达式。</p>
<p><strong>域对象</strong></p>
<p>JavaWeb中有四大域对象，分别是：</p>
<ul>
<li>page：当前页面有效</li>
<li>request：当前请求有效</li>
<li>session：当前会话有效</li>
<li>application：当前应用有效</li>
</ul>
<img src="image-20230329103637590.png" alt="image-20230329103637590" style="zoom: 50%;" />

<p>例如<code>$&#123;brands&#125;</code>el 表达式获取数据，会先从page域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。</p>
<h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><p>JSP标准标签库(Jsp Standarded Tag Library) ，使用标签取代JSP页面上的Java代码。</p>
<p>JSTL 使用也是比较简单的，分为如下步骤：</p>
<ul>
<li><p>导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在JSP页面上引入JSTL标签库</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 1&#125;&quot;</span>&gt;</span><br><span class="line">       启用</span><br><span class="line">   &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">   &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 0&#125;&quot;</span>&gt;</span><br><span class="line">       禁用</span><br><span class="line">   &lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p><em>用法一：</em></p>
<ul>
<li><p>items：被遍历的容器</p>
</li>
<li><p>var：遍历产生的临时变量</p>
</li>
<li><p>varStatus：遍历状态对象</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;status&quot;</span>&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<p><strong>用法二</strong></p>
<ul>
<li><p>begin：开始数</p>
</li>
<li><p>end：结束数</p>
</li>
<li><p>step：步长</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MVC模式和三层架构"><a href="#MVC模式和三层架构" class="headerlink" title="MVC模式和三层架构"></a>MVC模式和三层架构</h2><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>MVC 是一种分层开发的模式，其中：</p>
<ul>
<li><p>M：Model，业务模型，处理业务</p>
</li>
<li><p>V：View，视图，界面展示</p>
</li>
<li><p>C：Controller，控制器，处理请求，调用模型和视图</p>
</li>
</ul>
<img src="image-20230329105238249.png" alt="image-20230329105238249" style="zoom:67%;" />

<p>控制器（Serlvlet）用来接收浏览器发送过来的请求，控制器调用模型（JavaBean）来获取数据，比如从数据库查询数据；控制器获取到数据后再交由视图（JSP）进行数据展示。</p>
<p><strong>MVC 好处：</strong></p>
<ul>
<li><p>有利于分工协作</p>
</li>
<li><p>有利于组件重用</p>
</li>
</ul>
<h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>三层架构是将我们的项目分成了三个层面：分别是<strong>表现层</strong>、<strong>业务逻辑层</strong>、<strong>数据访问层</strong>。</p>
<img src="image-20230329105611759.png" alt="image-20230329105611759" style="zoom:67%;" />

<ul>
<li>数据访问层：对数据库的CRUD基本操作；</li>
<li>业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如“注册业务功能” ，我们会先调用 <code>数据访问层</code> 的 <code>selectByName()</code> 方法判断该用户名是否存在，如果不存在再调用 <code>数据访问层</code> 的 <code>insert()</code> 方法进行数据的添加操作；</li>
<li>表现层：接收请求，封装数据，调用业务逻辑层，响应数据。</li>
</ul>
<p>整个流程是，浏览器发送请求，表现层的Servlet接收请求并调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法调用数据访问层方法进行数据的操作，依次返回到Serlvet，然后Servlet将数据交由 JSP 进行展示。</p>
<p>三层架构的每一层都有特有的包名称：</p>
<ul>
<li>表现层： <code>com.Lijiacheng.controller</code> 或者 <code>com.Lijiacheng.web</code></li>
<li>业务逻辑层：<code>com.Lijiacheng.service</code></li>
<li>数据访问层：<code>com.Lijiacheng.dao</code> 或者 <code>com.Lijiacheng.mapper</code></li>
</ul>
<h3 id="MVC和三层架构"><a href="#MVC和三层架构" class="headerlink" title="MVC和三层架构"></a>MVC和三层架构</h3><p>三层架构是对MVC 模式实现架构的思想。 那么我们以后按照要求将不同层的代码写在不同的包下，每一层里功能职责做到单一，将来如果将表现层的技术换掉，而业务逻辑层和数据访问层的代码不需要发生变化。</p>
<img src="image-20230329110654633.png" alt="image-20230329110654633" style="zoom:67%;" />

<h2 id="实现增删改查"><a href="#实现增删改查" class="headerlink" title="实现增删改查"></a>实现增删改查</h2><p>这里使用三层架构做增删改查的基础操作，开发流程总结为：</p>
<ul>
<li>分析业务（最重要！）</li>
<li>写sql映射配置文件</li>
<li>声明与sql配置文件对应的mapper接口函数</li>
<li>编写<code>service</code>层代码，调用接口函数进行业务实现</li>
<li>编写<code>Servlet</code>代码，通常是接收数据并将其请求转发进行数据共享</li>
</ul>
<p>1、查询全部数据</p>
<p>​    这个没什么好说的，在Servlet中将<code>brands</code>集合里的数据共享给相应展示的jsp页面即可。</p>
<p>2、增加数据</p>
<p>​    业务逻辑是：在查询全部数据页面中点击链接进入添加数据的jsp页面，将jsp页面的表单数据发送给相应的Servlet，在Servlet中接收数据并封装成brand对象，调用业务逻辑层和数据访问层函数将数据添加到数据库当中；最后不要忘记了请求转发回到”查询所有”的资源。</p>
<p>3、修改数据</p>
<p>​    业务逻辑是：①在查询全部数据页面中点击<strong>某行数据</strong>的链接，从数据库中根据id找到对应的数据信息将它们回显到修改数据的jsp页面上。回显的流程是，通过调用”根据用户查询“的函数，将数据封装在一个brand对象中，并请求转发给修改数据的jsp页面来接收。②在前端页面修改数据后，通过将form表单中的数据传递到修改数据的Servlet中，将封装了属性的对象作为参数调用业务逻辑层和数据访问层函数将数据在数据库中进行修改，最后仍然是回到”查询所有”的资源。</p>
<blockquote>
<p>在”增加“业务和”修改“业务时，需要将表单的数据通过post请求方式传递给服务器，由于存在中文乱码问题，如果不在Servlet中首先通过<code>setCharacterEncoding</code>进行设置，就会出现get到的参数是乱码的问题，这里特别注意一下。</p>
</blockquote>
<p>4、删除数据</p>
<p>​    根据id删除，跟上面的<code>selectById</code>业务基本一致，就不说了。</p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>05-Spring事务管理</title>
    <url>/2023/06/04/05-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>数据库的事务在数据库还有JavaWeb中也多次提到了，事务管理保障了一系列的数据库操作同成功同失败，事务管理非常重要。下面就来讲一下Spring是如何进行事务管理的。</p>
<span id="more"></span>

<h2 id="Spring事务简介"><a href="#Spring事务简介" class="headerlink" title="Spring事务简介"></a>Spring事务简介</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>事务作用：在数据层保障一系列的数据库操作同成功同失败；</li>
<li>Spring事务作用：在数据层或<strong>业务层</strong>保障一系列的数据库操作同成功同失败；</li>
</ul>
<p>为什么业务层需要进行事务管理？举个例子来说，转账业务会有两次数据层的调用，一次是加钱一次是减钱；把事务放在数据层，加钱和减钱就有两个事务；没办法保证加钱和减钱同时成功或者同时失败；这个时候就需要将事务放在业务层进行处理。</p>
<p>Spring为了管理事务，提供了一个平台事务管理器（接口）<code>PlatformTransactionManager</code>：</p>
<img src="image-20230604122146529.png" alt="image-20230604122146529" style="zoom:67%;" />

<p>除此之外，Spring还为其提供了一个具体的实现（类）：<code>DataSourceTransactionManager</code>.</p>
<p>我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。</p>
<h3 id="Spring事务转账案例"><a href="#Spring事务转账案例" class="headerlink" title="Spring事务转账案例"></a>Spring事务转账案例</h3><p>需求：实现任意两个账户间转账操作（账户A加钱，账户B减钱）</p>
<p>实现：基于Spring整合MyBatis环境，实现转账操作。忘记如何整合Mybatis环境的去看<a href="https://kicheng.github.io/2023/06/01/03-Spring%E6%95%B4%E5%90%88%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/">03-Spring整合三方框架</a>。</p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><img src="image-20230604161234419.png" alt="image-20230604161234419" style="zoom:80%;" />

<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>如果在转账过程中出现了异常，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String in, String out, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">      accountDao.outMoney(out, money);</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;  <span class="comment">// 模拟异常</span></span><br><span class="line">      accountDao.inMoney(in, money);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败：</p>
<p><img src="image-20230604161633065.png" alt="image-20230604161633065"></p>
<p>正常来说，Tom账户应该收到来自Jerry账户转账的100元，但是由于在转出之后程序出现异常，后面的转入操作根本没有进行，这在现实中是肯定不允许出现的。这就体现出事务管理的重要性，程序出现异常时要进行事务回滚，这个事务应该是在业务层（Service），Spring事务管理就是做这个的：</p>
<p>步骤1：在需要被事务管理的方法上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String in, String out, <span class="type">double</span> money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <code>@Transactional</code>可以写在接口类上、接口方法上、实现类上和实现类方法上，建议（标准）写在接口或接口的方法上。</p>
</blockquote>
<p>步骤2：在JdbcConfig类中配置事务管理器（mybatis使用的是jdbc事务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dataSourceTransactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用DataSourceTransactionManager。</p>
</blockquote>
<p>步骤3：SpringConfig开启事务注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br></pre></td></tr></table></figure>

<p>发现在转换的业务出现错误后，事务就可以控制回滚，保证数据的正确性：</p>
<p><img src="image-20230604163037324.png" alt="image-20230604163037324"></p>
<p><strong>Spring事务管理总结</strong></p>
<p>注意两个注释：</p>
<ul>
<li>配置类注释：<code>@EnableTransactionManagement</code>设置当前Spring环境中开启注解式事务支持；</li>
<li>业务层接口注释：<code>@Transactional</code>为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）。</li>
</ul>
<h2 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h2><p>重点要理解两个概念，分别是事务管理员和事务协调员。</p>
<p>1、未开启Spring事务之前：</p>
<img src="image-20230604163420737.png" alt="image-20230604163420737" style="zoom:50%;" />

<p>AccountDao的outMoney因为是修改操作，会开启一个事务T1；AccountDao的inMoney因为是修改操作，会开启一个事务T2；<br>AccountService的transfer没有事务。</p>
<p>如果运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确；如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行，就会出现数据错误。</p>
<p>2、开启Spring事务后</p>
<img src="image-20230604163558148.png" alt="image-20230604163558148" style="zoom:50%;" />

<p>transfer上添加了<code>@Transactional</code>注解，在该方法上就会有一个事务T，AccountDao的outMoney方法的事务T1加入到transfer的事务T中，AccountDao的inMoney方法的事务T2加入到transfer的事务T中。这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</p>
<ul>
<li>事务管理员：发起事务方，在Spring中通常指业务层开启事务的方法；</li>
<li>事务协调员：加入事务方，在Spring中通常指数据层方法，也可以是业务层方法；</li>
</ul>
<blockquote>
<p>注意：目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个DataSource数据源。</p>
</blockquote>
<h2 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h2><h3 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h3><p>这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p>
<ul>
<li><p>readOnly：true只读事务，false读写事务，增删改要设为false（默认），查询设为true。</p>
</li>
<li><p>timeout：设置超时时间（单位秒），在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p>
</li>
<li><p><strong>rollbackFor：</strong>当出现指定异常进行事务回滚</p>
</li>
<li><p>noRollbackFor：当出现指定异常不进行事务回滚</p>
</li>
</ul>
<blockquote>
<p>关于Spring事务异常回滚的问题，Spring的事务只会对Error异常和RuntimeException异常及其子类（运行时异常）进行事务回滚，其他的异常类型是不会回滚的，比如IOException不符合上述条件所以不回滚。</p>
</blockquote>
<p>此时就可以使用<code>rollbackFor</code>属性来设置IOException异常回滚。</p>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>为了讲解事务传播行为属性<code>propagation</code>的设置，我们需要完成下面的案例。</p>
<h4 id="转账业务追加日志案例"><a href="#转账业务追加日志案例" class="headerlink" title="转账业务追加日志案例"></a>转账业务追加日志案例</h4><p>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕（数据库记录日志），<strong>无论转账操作是否成功，均进行转账操作的日志留痕</strong>。</p>
<p><strong>环境准备</strong></p>
<p>步骤1：数据库创建日志表</p>
<p>步骤2：添加LogDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_log (info,createDate) values(#&#123;info&#125;,now())&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：添加LogService接口与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,<span class="type">double</span> money)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,<span class="type">double</span> money)</span>&#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;转账操作由 &quot;</span> + out + <span class="string">&quot;到&quot;</span> + in + <span class="string">&quot;，金额：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：在转账的业务中添加记录日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> LogService logService;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String in, String out, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          accountDao.outMoney(out, money);</span><br><span class="line">          accountDao.inMoney(in, money);</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          logService.log(out,in,money);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功；当转账业务之间出现异常（int i =1/0），转账失败，tbl_account成功回滚，但是tbl_log表未添加数据。而我们希望无论转账操作是否成功，日志都必须保留。</p>
<p>失败原因：日志的记录与转账操作隶属同一个事务，同成功同失败。</p>
<h4 id="事务传播行为-1"><a href="#事务传播行为-1" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><img src="image-20230604174004771.png" alt="image-20230604174004771" style="zoom: 50%;" />

<p>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1、T2、T3，<code>@Transactional</code>注释开启事务T，把T1、T2、T3都加入到事务T中来，当转账失败后，所有事务都回滚，所以日志没有记录下来。如果要想让log方法单独开启一个事务，就用到了事务传播行为。</p>
<p>事务传播行为是指事务协调员对事务管理员所携带事务的处理态度，用到了<code>@propagation</code>属性。</p>
<p>修改logSevice的<code>@Transactional</code>属性值，改变事务传播行为（当前操作需要新事务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br></pre></td></tr></table></figure>

<p><strong>事务传播行为的可选值</strong></p>
<img src="image-20230604174832710.png" alt="image-20230604174832710" style="zoom:50%;" />
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>06-会话技术</title>
    <url>/2023/04/01/06-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>会话跟踪是web程序中常用的技术，常用的<em>会话跟踪</em>技术是Cookie 和Session。</p>
<span id="more"></span>

<h1 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h1><p>对于会话跟踪，首先要理解什么是会话，然后再去理解什么是会话跟踪：</p>
<ul>
<li><p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</p>
<ul>
<li>从浏览器发出请求到服务端响应数据给前端之后，一次会话（在浏览器和服务器之间）就被建立了；</li>
<li>会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着；</li>
<li>浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称为会话。</li>
</ul>
</li>
<li><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p>
<ul>
<li>服务器会收到多个请求，这多个请求可能来自多个浏览器；</li>
<li>服务器需要识别请求是否来自同一个浏览器，这个过程就是会话跟踪；</li>
<li>服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据。</li>
</ul>
</li>
</ul>
<blockquote>
<p>多次请求间的数据共享：购物网站的购物车结算；页面展示用户登录信息（发送多次请求都显示信息）；网站登录的”记住我“功能；登录页面的验证码功能（声明验证码和点击登录也是两次请求，需要进行比对才能登陆成功）</p>
</blockquote>
<p>但是目前的浏览器和服务器之间不支持数据共享：浏览器和服务器之间使用的是HTTP请求来进行数据传输，而<strong>HTTP协议是无状态的</strong>，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求（HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响），请求与请求之间独立后，就无法实现多次请求之间的数据共享。</p>
<p>会话跟踪分为客户端的会话跟踪和服务端的会话跟踪技术。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的基本使用"><a href="#Cookie的基本使用" class="headerlink" title="Cookie的基本使用"></a>Cookie的基本使用</h3><p>Cookie是一种客户端会话技术，将数据保存到<strong>客户端</strong>，以后每次请求都携带Cookie数据进行访问。</p>
<h4 id="Cookie的工作流程"><a href="#Cookie的工作流程" class="headerlink" title="Cookie的工作流程"></a>Cookie的工作流程</h4><img src="image-20230329175917166.png" alt="image-20230329175917166" style="zoom: 50%;" />

<ul>
<li>服务端提供了两个Servlet，分别是ServletA和ServletB；</li>
<li>浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理；</li>
<li>服务端ServletA在处理的过程中可以创建一个Cookie对象并将<code>name=zs</code>的数据存入Cookie；</li>
<li>服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器；</li>
<li>浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就建立了一次会话；</li>
<li><strong>在同一次会话中</strong>浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据；</li>
<li>ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享。</li>
</ul>
<h4 id="Cookie的基本使用-1"><a href="#Cookie的基本使用-1" class="headerlink" title="Cookie的基本使用"></a>Cookie的基本使用</h4><p>1、发送Cookie</p>
<ul>
<li><p>创建Cookie对象，并设置数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>发送Cookie到客户端：使用response对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过Servlet向客户端发送一个Cookie：</p>
<p><img src="image-20230329181624169.png" alt="image-20230329181624169"></p>
<p>2、获取Cookie</p>
<ul>
<li><p>获取客户端携带的所有Cookie，使用request对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure></li>
<li><p>遍历数组获取每一个Cookie对象，使用Cookie对象方法获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie.getName();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie.getValue();</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>在访问AServlet后关闭浏览器，重启浏览器后访问BServlet就无法获取到Cookie中的数据，因为重启浏览器之后就不是一次会话了。</p>
</blockquote>
<h3 id="Cookie原理分析"><a href="#Cookie原理分析" class="headerlink" title="Cookie原理分析"></a>Cookie原理分析</h3><p>对于Cookie的实现原理是基于HTTP协议的，其中涉及到HTTP协议中的两个请求头信息：响应头 set-cookie、请求头 cookie</p>
<img src="image-20230329183559500.png" alt="image-20230329183559500" style="zoom:67%;" />

<ul>
<li>对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据；当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在<strong>响应头</strong>中添加一行数据<code>Set-Cookie:username=zs</code>；</li>
<li>浏览器获取到响应结果后，从响应头中就可以获取到<code>Set-Cookie</code>对应值<code>username=zs</code>,并将数据存储在浏览器的内存中；</li>
<li>浏览器再次发送请求给BServlet的时候，浏览器会自动在<strong>请求头</strong>中添加<code>Cookie: username=zs</code>发送给服务端BServlet；</li>
<li>Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组，BServlet通过Request对象获取Cookie。</li>
</ul>
<p>可以验证一下：</p>
<p><img src="image-20230329210416050.png" alt="image-20230329210416050"></p>
<h3 id="Cookie的使用细节"><a href="#Cookie的使用细节" class="headerlink" title="Cookie的使用细节"></a>Cookie的使用细节</h3><h4 id="Cookie的存活时间"><a href="#Cookie的存活时间" class="headerlink" title="Cookie的存活时间"></a>Cookie的存活时间</h4><p>正像前面提到的，在访问AServlet后关闭浏览器，重启浏览器后访问BServlet就无法获取到Cookie中的数据。在默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁。那么如何将Cookie持久化存储？</p>
<ul>
<li><p>设置Cookie存活时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setMaxAge(int seconds)</span><br></pre></td></tr></table></figure>

<p>参数为：</p>
<ul>
<li>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储，到时间自动删除；</li>
<li>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁；</li>
<li>0：删除对应Cookie。</li>
</ul>
</li>
</ul>
<h4 id="Cookie存储中文"><a href="#Cookie存储中文" class="headerlink" title="Cookie存储中文"></a>Cookie存储中文</h4><p>Cookie不能直接存储中文，当cookie里存储中文时访问服务器资源时会报错。所以我们可以用URL编解码的方式，在cookie中存字节数据。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session的基本使用"><a href="#Session的基本使用" class="headerlink" title="Session的基本使用"></a>Session的基本使用</h3><p>Session是一种服务端会话跟踪技术，将数据保存到<strong>服务端</strong>。</p>
<blockquote>
<ul>
<li>Session是存储在服务端而Cookie是存储在客户端；</li>
<li>存储在客户端的数据容易被窃取和截获，存在很多不安全的因素存储在服务端的数据相比于客户端来说就更安全。</li>
</ul>
</blockquote>
<h4 id="Session的工作流程"><a href="#Session的工作流程" class="headerlink" title="Session的工作流程"></a>Session的工作流程</h4><img src="image-20230329212652378.png" alt="image-20230329212652378" style="zoom:67%;" />

<ul>
<li>在服务端的AServlet获取一个Session对象，把数据存入其中；</li>
<li>在服务端的BServlet获取到相同的Session对象<em>（如何保证使用的是同一个Session对象）</em>，从中取出数据；</li>
<li>就可以实现一次会话中多次请求之间的数据共享了。</li>
</ul>
<h4 id="Session的基本使用-1"><a href="#Session的基本使用-1" class="headerlink" title="Session的基本使用"></a>Session的基本使用</h4><ul>
<li><p>获取Session对象，使用的是request对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure></li>
<li><p>Session对象提供的功能</p>
<ul>
<li><p>存储数据到session域中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setAttribute(String name, Object o)</span><br></pre></td></tr></table></figure></li>
<li><p>根据 key，获取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object getAttribute(String name)  // Session中是一个Object类型的数据，也就是说Session中可以存储任意数据类型</span><br></pre></td></tr></table></figure></li>
<li><p>根据 key，删除该键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void removeAttribute(String name)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>可以自己写个Servlet就能看到Session是能够在一次会话中两次请求之间共享数据的。</p>
<h3 id="Session的原理分析"><a href="#Session的原理分析" class="headerlink" title="Session的原理分析"></a>Session的原理分析</h3><p>Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个；我们可以在Session 的两个Servlet中分别print出创建的Session对象：</p>
<p><img src="image-20230329214508736.png" alt="image-20230329214508736"></p>
<p>那么如果关闭浏览器再重新打开呢？这时候就不是同一个session对象了，所以Session实现的也是一次会话中多次请求之间的数据共享。</p>
<img src="image-20230329214604582.png" alt="image-20230329214604582" style="zoom:67%;" />

<p><img src="image-20230329215505220.png" alt="image-20230329215505220"></p>
<p><strong>Session保证在一次会话中获取的Session对象是同一个（基于Cookie）</strong></p>
<p><img src="image-20230329215911579.png" alt="image-20230329215911579"></p>
<ul>
<li>demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是<code>id:10</code>；</li>
<li>demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器；</li>
<li>Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识<code>id:10</code>当做一个cookie，添加<code>Set-Cookie:JESSIONID=10</code>到响应头中，并响应给浏览器；</li>
<li>浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中；</li>
<li>浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照<code>Cookie: JESSIONID=10</code>的格式添加到请求头中并发送给服务器Tomcat；</li>
<li>demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找<code>id:10</code>的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象；</li>
<li>关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象。</li>
</ul>
<p>可以看一下在同一会话的两次请求中的Cookie数据：</p>
<p><img src="image-20230329221834266.png" alt="image-20230329221834266"></p>
<p><img src="06-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/image-20230329221909633.png" alt="image-20230329221909633"></p>
<h3 id="Session的使用细节"><a href="#Session的使用细节" class="headerlink" title="Session的使用细节"></a>Session的使用细节</h3><h4 id="Session的钝化和活化"><a href="#Session的钝化和活化" class="headerlink" title="Session的钝化和活化"></a>Session的钝化和活化</h4><p>服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中；当服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了。但是对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对——服务器就是通过<strong>Session的钝化和活化</strong>做到的。</p>
<img src="image-20230329222619158.png" alt="image-20230329222619158" style="zoom:67%;" />

<ul>
<li>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中</li>
<li>活化：再次启动服务器后，从文件中加载数据到Session中（数据加载到Session中后，路径中的文件会被删除掉）</li>
</ul>
<blockquote>
<p>小结：</p>
<ul>
<li>session数据存储在服务端，服务器重启后，session数据会被保存；</li>
<li>浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象；</li>
<li><strong>session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据；cookie是存储在客户端，可以长期保存。</strong></li>
</ul>
</blockquote>
<h4 id="Session销毁"><a href="#Session销毁" class="headerlink" title="Session销毁"></a>Session销毁</h4><ul>
<li><p>默认情况下，无操作，30分钟自动销毁；对于这个失效时间，是可以通过在<code>web.xml</code>配置进行修改的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;session-timeout&gt;100&lt;/session-timeout&gt;  &lt;!-- 单位是mins --&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>调用Session对象的<code>invalidate()</code>进行销毁</p>
</li>
</ul>
<h2 id="Cookie和Session小结"><a href="#Cookie和Session小结" class="headerlink" title="Cookie和Session小结"></a>Cookie和Session小结</h2><p>Cookie 和 Session 都是来完成一次会话内多次请求间的数据共享。</p>
<ul>
<li>区别：<ul>
<li>存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端；</li>
<li>安全性：Cookie不安全，Session安全；</li>
<li>数据大小：Cookie最大3KB，Session无大小限制；</li>
<li>存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟；</li>
<li>服务器性能：Cookie不占服务器资源，Session占用服务器资源；</li>
</ul>
</li>
<li>应用场景（不绝对）：<ul>
<li>购物车：使用Cookie来存储；</li>
<li>以登录用户的名称展示：使用Session来存储；</li>
<li>记住我功能：使用Cookie来存储；</li>
<li>验证码：使用Session来存储；</li>
</ul>
</li>
</ul>
<h2 id="会话跟踪在登陆注册中的应用"><a href="#会话跟踪在登陆注册中的应用" class="headerlink" title="会话跟踪在登陆注册中的应用"></a>会话跟踪在登陆注册中的应用</h2><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>登录功能做完了，很无语…本来几分钟就能搞定的事花了俩小时，一直识别不到xml映射文件，我反复检查<code>namespace</code>和核心配置文件无果，偶然发现我竟然将mapper下的xml映射文件放在了<code>webapp</code>目录而不是<code>resource</code>目录……欲哭无泪……</p>
<p>登录功能的业务逻辑是：在登录时（第一次请求）将用户数据存入session中，并进行数据共享到登陆成功页面以及其他页面（第二次请求）。由于是一次会话的多次请求，所以共享session中的数据不能用请求转发只能用重定向，这里值得注意一下。</p>
<h3 id="”记住我“功能"><a href="#”记住我“功能" class="headerlink" title="”记住我“功能"></a>”记住我“功能</h3><p>在服务器端创建Cookie对象分别存储<code>username</code>和<code>password</code>，add到客户端，这时候可以看到response的响应头中存在<code>Set-Cookie</code>：</p>
<p><img src="image-20230330111257163.png" alt="image-20230330111257163"></p>
<p>下一步是在客户端页面获取Cookie，将数据设置到登陆页面的用户名和密码框中。在页面可以使用EL表达式获取Cookie：</p>
<img src="image-20230330111714218.png" alt="image-20230330111714218" style="zoom:50%;" />

<p>在jsp页面中修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot; type=&quot;text&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; value=&quot;$&#123;cookie.password.value&#125;&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="用户注册功能"><a href="#用户注册功能" class="headerlink" title="用户注册功能"></a>用户注册功能</h3><p>业务逻辑是：前端通过表单将注册的用户名和密码传给<code>RegisterServlet</code>，调用Service层register，如果注册成功则跳转到登录界面并给提示；如果注册失败则重新跳转到注册界面并给提示。</p>
<h3 id="验证码的生成和校验"><a href="#验证码的生成和校验" class="headerlink" title="验证码的生成和校验"></a>验证码的生成和校验</h3><blockquote>
<p>验证码的作用：防止机器自动注册，攻击服务器</p>
</blockquote>
<p>这段业务比较陌生是第一次见到，记录下详细的实现过程。</p>
<ul>
<li>生成二维码</li>
</ul>
<p>验证码的生成是通过工具类来实现的，具体的工具类参考<code>CheckCodeUtil.java</code>，编写main方法进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    //生成验证码的图片位置</span><br><span class="line">    OutputStream fos = new FileOutputStream(&quot;d://a.jpg&quot;);</span><br><span class="line">    //checkCode为最终验证码的数据</span><br><span class="line">    String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4);</span><br><span class="line">    System.out.println(checkCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现流程分析</strong></p>
<img src="image-20230330151138981.png" alt="image-20230330151138981" style="zoom:50%;" />

<p>测试类是通过<code>OutputStream</code>流将图片生成到磁盘，可以通过reponse对象的<code>getOutputStream()</code>字节输出流将图片响应给页面。</p>
<p><strong>具体实现</strong></p>
<p>（1）修改Register.jsp页面，将验证码图片从后台获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;td class=&quot;inputs&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt;</span><br><span class="line">    &lt;!-- 将验证码的图片从后台获取 --&gt;</span><br><span class="line">    &lt;img id=&quot;checkCodeImg&quot; src=&quot;/JavaWeb_06_Cookie_Session/checkCodeServlet&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;&quot; id=&quot;changeImg&quot;&gt;看不清？&lt;/a&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure>

<p>（2）CheckCodeServlet用来接收请求生成验证码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;/checkCodeServlet&quot;)</span><br><span class="line">public class CheckCodeServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 生成验证码</span><br><span class="line">        ServletOutputStream os = response.getOutputStream();</span><br><span class="line">        String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>校验二维码</li>
</ul>
<p>判断<strong>生成的验证码</strong>和<strong>用户输入的验证码</strong>是否一样，如果不一样，则阻止注册。验证码图片访问和提交注册表单是<strong>两次</strong>请求，所以要将程序生成的验证码存入Session中。</p>
<p><strong>实现流程分析</strong></p>
<img src="image-20230330151923006.png" alt="image-20230330151923006" style="zoom:50%;" />

<p>（1）在CheckCodeServlet中生成验证码的时候，将验证码数据存入Session对象；</p>
<p>（2）前端将验证码和注册数据提交到后台，交给RegisterServlet类；</p>
<p>（3）RegisterServlet类接收到请求和数据后，其中就有验证码，和Session中的验证码进行对比；</p>
<p>（4）如果一致，则完成注册，如果不一致，则提示错误信息。</p>
<p><strong>具体实现</strong></p>
<p>（1）修改CheckCodeServlet类，将验证码存入Session对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将生成的验证码存入Session对象</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;checkCode&quot;,checkCode);</span><br></pre></td></tr></table></figure>

<p>（2）在RegisterServlet中，获取页面的和session对象中的验证码，进行对比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取用户输入的验证码</span><br><span class="line">String checkCode = request.getParameter(&quot;checkCode&quot;);</span><br><span class="line">// 获取Session中的验证码</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">Object s_checkCode = session.getAttribute(&quot;checkCode&quot;);</span><br><span class="line">// 将二者进行比对</span><br><span class="line">if(!s_checkCode.equals(checkCode))&#123;</span><br><span class="line">     // 验证码错误，无法注册 -- 跳转到注册jsp并给予提示</span><br><span class="line">     request.setAttribute(&quot;register_msg&quot;,&quot;验证码错误，请重新输入！&quot;);</span><br><span class="line">     request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response);</span><br><span class="line">     return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>07-Filter_Listener_Ajax</title>
    <url>/2023/04/01/07-Filter-Listener-Ajax/</url>
    <content><![CDATA[<p>这块知识点比较杂，而且Ajax是代替jsp的前端技术，了解即可。</p>
<span id="more"></span>

<h1 id="Filter-amp-Listener-amp-Ajax"><a href="#Filter-amp-Listener-amp-Ajax" class="headerlink" title="Filter&amp;Listener&amp;Ajax"></a>Filter&amp;Listener&amp;Ajax</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。Servlet 我们之前都已经学习过了，Filter和Listener我们今天都会进行学习。过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</p>
<p>正常情况下浏览器可以访问服务器上的所有的资源，而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter：</p>
<img src="image-20230330163113415.png" alt="image-20230330163113415" style="zoom:67%;" />

<p>过滤器一般完成一些通用的操作：比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。</p>
<p>我们之前做的品牌数据管理就已经做了登录的功能，但不登录的时候也可以通过首页的超链接访问到全部数据，这显然不符合我们的要求。我们希望如果登录过就跳转到品牌数据展示的页面，没有登录就跳转到登录界面，但如果要实现这个效果就要在每个资源中写上这段逻辑。像这种通用的操作，就可以用过滤器来实现，这就是过滤器的权限控制。</p>
<h3 id="Filter快速开发"><a href="#Filter快速开发" class="headerlink" title="Filter快速开发"></a>Filter快速开发</h3><ul>
<li><p>定义类，实现Filter接口，并重写其中的所有方法；</p>
</li>
<li><p>配置Filter拦截资源的路径：在类上定义 <code>@WebFilter</code> 注解。而注解的 <code>value</code> 属性值 <code>/*</code> 表示拦截所有的资源；</p>
</li>
<li><p>在doFilter方法中执行通用业务，并放行（<code>chain.doFilter(req,resp);</code> 就是放行，也就是让其访问本该访问的资源）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FilterDemo01...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);  <span class="comment">// 放行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Filter执行流程"><a href="#Filter执行流程" class="headerlink" title="Filter执行流程"></a>Filter执行流程</h3><img src="image-20230330165523793.png" alt="image-20230330165523793" style="zoom: 67%;" />

<p>可以总结Filter的执行流程如下：</p>
<img src="image-20230330165658889.png" alt="image-20230330165658889" style="zoom:80%;" />

<p>以后我们可以将对请求进行处理的代码在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行处理。</p>
<h3 id="Filter拦截路径配置"><a href="#Filter拦截路径配置" class="headerlink" title="Filter拦截路径配置"></a>Filter拦截路径配置</h3><p>拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 <code>@WebFilter</code> 注解进行配置。</p>
<ul>
<li>拦截具体的资源：<code>/index.jsp</code>：只有访问index.jsp时才会被拦截；</li>
<li>目录拦截：<code>/user/*</code>：访问/user下的所有资源，都会被拦截；</li>
<li>后缀名拦截：<code>*.jsp</code>：访问后缀名为jsp的资源，都会被拦截；</li>
<li>拦截所有：<code>/*</code>：访问所有资源，都会被拦截。</li>
</ul>
<h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p>
<img src="image-20230330171958846.png" alt="image-20230330171958846" style="zoom: 50%;" />

<p>在<code>FilterDemo01</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;1.FilterDemo...&quot;</span>);</span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">System.out.println(<span class="string">&quot;5.FilterDemo...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>FilterDemo2</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;2.FilterDemo...&quot;</span>);</span><br><span class="line">   filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">   System.out.println(<span class="string">&quot;4.FilterDemo...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在服务器动态资源<code>hello.jsp</code>中：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  System.out.println(<span class="string">&quot;3.hello jsp...&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>访问服务器中的jsp资源，可以根据打印的信息看到web请求和响应是如何通过过滤器链执行的：</p>
<img src="image-20230330172922401.png" alt="image-20230330172922401" style="zoom:67%;" />

<blockquote>
<p>但是为什么，我们配置的<code>FilterDemo1</code>和<code>FilterDemo2</code>的拦截路径是一致的，为什么会先执行1再执行2呢？使用的是注解配置Filter，这种配置方式的优先级是按照过滤器类名（字符串）的自然排序。</p>
</blockquote>
<h3 id="Filter应用——登录校验"><a href="#Filter应用——登录校验" class="headerlink" title="Filter应用——登录校验"></a>Filter应用——登录校验</h3><img src="image-20230330173546835.png" alt="image-20230330173546835" style="zoom: 67%;" />

<p>这块应用在上一个project<code>JavaWeb_06_Cookie_Session</code>里补充代码。在<code>web</code>目录下创建<code>filter</code>目录新建<code>LoginFilter</code>过滤器即可，通过判断session中是否有user对象就可以判断用户是否登录，代码很简单就不记录了。</p>
<img src="image-20230330175255343.png" alt="image-20230330175255343" style="zoom: 50%;" />

<p>但是我们看到的效果是这样的（先删除浏览器缓存的记录），这是为什么呢？因为登陆页面需要 <code>css/login.css</code> 文件进行样式渲染，但是这个文件在filter中被拦截了，导致没有加载到样式文件，为了解决这个问题，<strong>需要对所有的登陆相关的资源进行放行</strong>。<strong>还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行</strong>。</p>
<p>过滤器<code>LoginFilter</code>的完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 在数组中存储登陆和注册相关的资源路径，优先将他们放行</span></span><br><span class="line">        String[] urls = &#123;<span class="string">&quot;/login.jsp&quot;</span>,<span class="string">&quot;/imgs/&quot;</span>,<span class="string">&quot;/css/&quot;</span>,<span class="string">&quot;/loginServlet&quot;</span>,<span class="string">&quot;/register.jsp&quot;</span>,<span class="string">&quot;/registerServlet&quot;</span>,<span class="string">&quot;/checkCodeServlet&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURL</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line">        <span class="keyword">for</span>(String url: urls)&#123;</span><br><span class="line">            <span class="keyword">if</span>(requestURL.contains(url))&#123;</span><br><span class="line">                <span class="comment">// 需要放行的资源url</span></span><br><span class="line">                filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行前 -- 判断用户是否登录</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 已经登录过 -- 放行</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 未登录 -- 跳转到登录界面</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;login_msg&quot;</span>,<span class="string">&quot;未登录，请先登录！&quot;</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(servletRequest,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。监听器可以监听在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>
<p>request和session我们学习过。而 <code>application</code> 是 <code>ServletContext</code> 类型的对象（<code>ServletContext</code> 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象）。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JavaWeb 提供了8个监听器，只有 <code>ServletContextListener</code> 这个监听器后面会用到，<code>ServletContextListener</code> 是用来监听 <code>ServletContext</code> 对象的创建和销毁。</p>
<p><code>ServletContextListener</code> 接口中有以下两个方法：</p>
<ul>
<li><code>void contextInitialized(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被创建了会自动执行的方法；</li>
<li><code>void contextDestroyed(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被销毁时会自动执行的方法。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于 <code>ServletContextListener</code> 监听器：</p>
<ul>
<li>定义一个类，实现<code>ServletContextListener</code> 接口，重写所有的抽象方法</li>
<li>使用 <code>@WebListener</code> 进行配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ContextLoaderListener...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX (Asynchronous JavaScript And XML)是异步的 JavaScript 和 XML。</p>
<h3 id="AJAX概述"><a href="#AJAX概述" class="headerlink" title="AJAX概述"></a>AJAX概述</h3><h4 id="AJAX作用"><a href="#AJAX作用" class="headerlink" title="AJAX作用"></a>AJAX作用</h4><p>1、<strong>与服务器进行数据交换</strong>：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。</p>
<p>之前我们是这样做功能：</p>
<p><img src="image-20230330213503973.png" alt="image-20230330213503973"></p>
<p>Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL标签库 进行数据的展示。</p>
<p>而我们学习了AJAX 后，就可以使用AJAX和服务器进行通信，以达到使用 HTML+AJAX 来替换JSP页面了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。</p>
<p><img src="image-20230330213640794.png" alt="image-20230330213640794"></p>
<p>2、<strong>异步交互</strong>：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术（搜索联想、用户名是否可用校验）。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><ul>
<li>同步发送请求</li>
</ul>
<img src="image-20230330214009570.png" alt="image-20230330214009570" style="zoom:67%;" />

<p>浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。</p>
<ul>
<li><p>异步发送请求过程如下</p>
<img src="image-20230330214043364.png" alt="image-20230330214043364" style="zoom:67%;" /></li>
</ul>
<p>浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><strong>服务端实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/ajaxServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello ajax~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//1. 创建核心对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> xhttp;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="language-javascript">    xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//2. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">  xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/ajaxServlet&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//3. 获取响应</span></span></span><br><span class="line"><span class="language-javascript">  xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230330220341705.png" alt="image-20230330220341705"></p>
<p>查看异步请求：</p>
<p><img src="image-20230330220604851.png" alt="image-20230330220604851"></p>
<h3 id="Ajax应用"><a href="#Ajax应用" class="headerlink" title="Ajax应用"></a>Ajax应用</h3><p>需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在。</p>
<img src="image-20230330220940894.png" alt="image-20230330220940894" style="zoom:67%;" />

<h4 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 接收用户名数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;username&quot;</span>).toString();</span><br><span class="line">    <span class="comment">// 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 响应标记</span></span><br><span class="line">    response.getWriter().write(<span class="string">&quot;&quot;</span> + flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 给用户名输入框绑定 失去焦点事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2. 发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取用户名的值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> username = <span class="variable language_">this</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.1. 创建核心对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> xhttp;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="language-javascript">            xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.2. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/selectUserServlet?username=&quot;</span> + username);</span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.3. 获取响应</span></span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//判断</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">responseText</span> == <span class="string">&quot;true&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//用户名存在，显示提示信息</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//用户名不存在 ，清楚提示信息</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 对原生的AJAX进行封装，简化书写。</p>
<blockquote>
<p>Axios官网：<a href="https://www.axios-http.cn/">https://www.axios-http.cn</a></p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li><p>引入 axios 的 js 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用axios发送请求，并获取响应结果</p>
<ul>
<li><p>get请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>post请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;  </span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON概述"><a href="#JSON概述" class="headerlink" title="JSON概述"></a>JSON概述</h3><p>JSON是JavaScript对象的表示法。</p>
<ul>
<li><p>JavaScript对象的定义格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">	<span class="attr">city</span>:<span class="string">&quot;北京&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JSON格式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	name<span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">	age<span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">	city<span class="punctuation">:</span><span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p> js对象中的属性名可以使用引号（单引号或双引号）；而json格式中的键要求必须使用双引号括起来，这是 json格式的规定。</p>
<p><strong>作用</strong>：由于其语法格式简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。像通过<code>response.getWriter()</code>就是服务端给浏览器响应的数据，有些数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该怎么做呢？</p>
<p>以前是通过xml进行数据传递：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>json描述（ 格式数据的简单、所占的字节数少）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>	</span><br><span class="line">	<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="JSON基础语法"><a href="#JSON基础语法" class="headerlink" title="JSON基础语法"></a>JSON基础语法</h3><h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><p>JSON本质就是一个字符串，但是该字符串内容是有一定的格式要求的：键要求必须使用双引号括起来，而值根据要表示的类型确定。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">var 变量名 = &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span>value<span class="punctuation">,</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span>value<span class="punctuation">,</span>...<span class="punctuation">&#125;</span>&#x27;;</span><br></pre></td></tr></table></figure>

<p>value的数据类型如下：数字（整数或浮点数）、字符串（双引号）、逻辑值（true或false）、数组（在方括号中）、对象（在花括号中）、null。</p>
<p>如果需要获取到该 JSON串中的属性值，应该怎么处理呢？</p>
<p>如果它是一个 js 对象，我们就可以通过 <code>js对象.属性名</code> 的方式来获取数据。JS 提供了一个对象<code>JSON</code>，该对象有如下两个方法：</p>
<ul>
<li><code>parse(str)</code> ：将 JSON串转换为 js 对象。使用方式是：<code>var jsObject = JSON.parse(jsonStr);</code></li>
<li><code>stringify(obj)</code> ：将 js 对象转换为 JSON 串。使用方式是：<code>var jsonStr = JSON.stringify(jsObject)</code></li>
</ul>
<p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//1. 定义JSON字符串</span></span><br><span class="line">    <span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span></span><br><span class="line">    <span class="title function_">alert</span>(jsonStr);</span><br><span class="line">    <span class="comment">//2. 将 JSON 字符串转为 JS 对象</span></span><br><span class="line">    <span class="keyword">let</span> jsObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr);</span><br><span class="line">    <span class="title function_">alert</span>(jsObject)</span><br><span class="line">    <span class="title function_">alert</span>(jsObject.<span class="property">name</span>)</span><br><span class="line">    <span class="comment">//3. 将 JS 对象转换为 JSON 字符串</span></span><br><span class="line">    <span class="keyword">let</span> jsonStr2 = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsObject);</span><br><span class="line">    <span class="title function_">alert</span>(jsonStr2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="发送异步请求携带参数"><a href="#发送异步请求携带参数" class="headerlink" title="发送异步请求携带参数"></a>发送异步请求携带参数</h4><p>使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON格式进行传递。可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 <code>JSON.stringify(js对象)</code> 转换为JSON串，再将该 JSON串作为 axios 的 data 属性值进行请求参数的提交（axios会自动将 js 对象转换为JSON串进行提交）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:jsObject  <span class="comment">//这里 axios 会将该js对象转换为 json 串的</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发送异步请求时，如果请求参数是JSON格式，那请求方式必须是POST。因为JSON串需要放在请求体中。</p>
</blockquote>
<h3 id="JSON串和Java对象的相互转换"><a href="#JSON串和Java对象的相互转换" class="headerlink" title="JSON串和Java对象的相互转换"></a>JSON串和Java对象的相互转换</h3><p>以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。</p>
<img src="image-20230330233339635.png" alt="image-20230330233339635" style="zoom:50%;" />

<p>在后端我们就需要重点学习以下两部分操作：</p>
<ul>
<li>请求数据：JSON字符串转为Java对象；</li>
<li>响应数据：Java对象转为JSON字符串；</li>
</ul>
<h4 id="Fastjson-概述"><a href="#Fastjson-概述" class="headerlink" title="Fastjson 概述"></a>Fastjson 概述</h4><p>阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，可以实现 Java对象和 JSON字符串的相互转换。</p>
<p><strong>基本使用</strong></p>
<ul>
<li><p>导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON对象转换成Java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr, User.class);</span><br></pre></td></tr></table></figure></li>
<li><p>Java对象转换成JSON对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>JSON对象和Java对象的相互转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Java对象转换成Json对象</span></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">   user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">   System.out.println(jsonString);</span><br><span class="line">   <span class="comment">// 将Json对象转换城Java对象</span></span><br><span class="line">   <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> JSON.parseObject(jsonString,User.class);</span><br><span class="line">   System.out.println(u);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>ChatGPT本地安装</title>
    <url>/2023/06/05/ChatGPT%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本地搭建ChatGPT，无需API、 免翻墙使用纯正OpenAI的全部功能。</p>
<span id="more"></span>

<h2 id="和官网的比较"><a href="#和官网的比较" class="headerlink" title="和官网的比较"></a>和官网的比较</h2><p>优点：</p>
<ul>
<li>不需要挂代理就可以访问</li>
<li>相比官网而言速度更快</li>
</ul>
<p>缺点：</p>
<ul>
<li>后台要挂Docker</li>
<li>和使用API不同，并不是真正意义上的本地部署，只是通过自己的Access TOKEN避免了网络代理</li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1、下载并安装Docker（<a href="https://www.docker.com/products/docker-desktop/">官网链接</a>）</p>
<p>2、使用开源项目：潘多拉 (Pandora) </p>
<p>​    一键安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull pengzhile/pandora</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora</span><br></pre></td></tr></table></figure>

<p>3、获取自己的Access TOKEN：<a href="http://chat.openai.com/api/auth/session">http://chat.openai.com/api/auth/session</a> 14天内免代理登录</p>
<p>4、访问本地链接：<a href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a> 可以实现与官网的同步</p>
<img src="image-20230605085358793.png" alt="image-20230605085358793" style="zoom:67%;" />

<p>​    </p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>Android平台JNI开发保姆级教程</title>
    <url>/2023/03/12/Android-jni/</url>
    <content><![CDATA[<p>​        最近项目中在Android移动端需要用到音视频处理的部分，这离不开FFmpeg工具。但是FFmpeg源码是C语言，想要在Android java中调用FFmpeg工具，这就需要Android NDK登场了。</p>
<span id="more"></span>

<h1 id="Android平台JNI开发保姆级教程"><a href="#Android平台JNI开发保姆级教程" class="headerlink" title="Android平台JNI开发保姆级教程"></a>Android平台JNI开发保姆级教程</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>​        FFmpeg源码：可以在官网下载，目前我是用的是最新版的6.0版本（只下载源代码即可，不要下载已经编译好的在不同平台可以运行的安装包）。</p>
<p><img src="pic1.png" alt="image-20230312105234096"></p>
<p>​        Android NDK：可以在官网下载，但更推荐在Android Studio中的Setting中可以直接下载NDK对应版本，我这里使用的是22.1.7171670版本的NDK（建议不要使用太新的NDK，否则可能会出现一些BUG）。</p>
<img src="pic2.png" alt="image-20230312103532627" style="zoom: 33%;" />

<p>​        安装msys2：由于我是在Windows下对FFmpeg源码进行交叉编译，所以需要一个类Unix环境；或者你可以直接使用linux操作系统。</p>
<p>​        由于第一次接触Android开发，对Android程序调用类库的流程不清楚，导致走了很多弯路。其实总结下来也很简单，我这里引用了雷神的流程图：</p>
<p><img src="pic3.png" alt="img"></p>
<blockquote>
<p><strong>在FFmpeg的最新版本6.0中，已经不需要在源码中修改configure设置了（我记得貌似从4.0版本之后就不需要修改了，记不太清了）。</strong></p>
</blockquote>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Android-NDK"><a href="#Android-NDK" class="headerlink" title="Android NDK"></a>Android NDK</h3><p>​        NDK 主要提供了一些库和工具，包括交叉编译器、调试器、库文件等，开发者可以使用这些工具将原生代码编译为针对不同 CPU 架构的本地库，然后在 Android 应用中通过 Java Native Interface（JNI）来调用这些本地库，以实现一些高性能、低级别的操作，例如图形处理、音频处理、加密、数据处理等。</p>
<p>​        Android NDK 是一个允许使用 C、C++ 等本地语言编写 Android 应用的工具包，可以提高应用的运行效率和系统性能。</p>
<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>​        JNI（Java Native Interface）是Java平台提供的一种机制，用于在Java虚拟机中运行本地代码。它允许Java应用程序通过调用本地语言编写的函数来使用底层操作系统和硬件资源，从而实现高性能的计算和底层操作。简单来说，JNI提供了一种在Java程序中调用本地代码的方式，可以扩展Java程序的功能和性能。</p>
<h3 id="so库"><a href="#so库" class="headerlink" title=".so库"></a>.so库</h3><p>​        在Android中，C语言代码需要被编译为.so库的形式才能被Android应用程序调用。这是因为Android系统是基于Linux内核的，而Linux系统下的.so库是一种常见的代码共享形式，可以被多个进程动态链接使用，避免了代码的重复编写和内存占用。通过将C语言代码编译为.so库的形式，Android应用程序可以在运行时动态加载和链接所需的库，从而实现对底层系统和硬件资源的访问和控制。</p>
<p>​        通过.so库的形式调用C语言代码，可以让Android应用程序更高效地使用底层系统和硬件资源，从而提高程序的性能和可靠性。同时，.so库也方便了代码的管理和维护，可以将公共的代码打包成库，供多个应用程序共享使用。</p>
<h2 id="开发流程（敲黑板！）"><a href="#开发流程（敲黑板！）" class="headerlink" title="开发流程（敲黑板！）"></a>开发流程（敲黑板！）</h2><h3 id="编译FFmpeg库"><a href="#编译FFmpeg库" class="headerlink" title="编译FFmpeg库"></a>编译FFmpeg库</h3><p>​        首先要把NDK安装好，路径是在你SDK路径下的NDK目录中，最好把你要用到的版本加入到环境变量当中。</p>
<p>​        在任意目录中新建一个脚本<code>build_ffmpeg.sh</code>，添加内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">SRC_DIR=D:\Android-Studio\ffmpeg-6.0</span><br><span class="line">DST_DIR=D:\Android-Studio\ffmpeg_build_out</span><br><span class="line">NDK=D:/Android/Sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/windows-x86_64</span><br><span class="line">API=23  </span><br><span class="line"> </span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$SRC_DIR</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> build_onearch</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; configure <span class="variable">$CPU</span>&quot;</span></span><br><span class="line">	./configure --enable-cross-compile --target-os=android  \</span><br><span class="line">	--prefix=<span class="variable">$DST_DIR</span>/<span class="variable">$ANDROID_ABI</span>  --cross-prefix=<span class="variable">$CROSS_PREFIX</span>  \</span><br><span class="line">	--cc=<span class="variable">$CLANG_PREFIX</span> --cxx=<span class="variable">$CLANG_PREFIX</span>++  \</span><br><span class="line">	--<span class="built_in">arch</span>=<span class="variable">$ARCH</span>  --cpu=<span class="variable">$CPU</span>  --sysroot=<span class="variable">$NDK</span>/sysroot \</span><br><span class="line">	--enable-shared --disable-static \</span><br><span class="line">	--enable-small --disable-programs --disable-doc \</span><br><span class="line">	--enable-asm --enable-neon \</span><br><span class="line">	--enable-jni --enable-mediacodec </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&lt;&lt; configure <span class="variable">$CPU</span>&quot;</span></span><br><span class="line">	make clean</span><br><span class="line">	make</span><br><span class="line">	make install</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ANDROID_ABI=arm64-v8a</span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=armv8-a</span><br><span class="line">CROSS_PREFIX=<span class="variable">$NDK</span>/bin/aarch64-linux-android-</span><br><span class="line">CLANG_PREFIX=<span class="variable">$NDK</span>/bin/aarch64-linux-android<span class="variable">$API</span>-clang</span><br><span class="line">build_onearch</span><br></pre></td></tr></table></figure>

<p>​        <font color=red>前面几行要根据自己的电脑路径进行配置，切莫照搬全抄！</font>这里的API的版本是最低版本，注意不要大于自己设备的Android API版本。网上有很多类似的配置脚本，可以对configure响应的修改进行功能增减。</p>
<p>​        我这里只编译了<code>arm64-v8a</code>的.so库，通常来说64位的CPU架构是对先前的CPU架构是兼容的。</p>
<p>​        将脚本保存后关闭，然后打开安装好的msys2，在脚本目录下运行脚本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./build_ffmpeg.sh</span><br></pre></td></tr></table></figure>

<p>​        整个编译过程大概有二十多分钟吧，编译好后的动态库会生成在你前面设置的<code>DST_DIR</code>路径下。</p>
<p><img src="pic4.png" alt="image-20230312111053279"></p>
<p>​        <code>include</code>目录下是一些头文件，<code>lib</code>目录下就是相应的.so库了。    </p>
<h3 id="JNI调用C程序"><a href="#JNI调用C程序" class="headerlink" title="JNI调用C程序"></a>JNI调用C程序</h3><p>使用<code>JNI</code>调用C语言代码需要做以下几步：</p>
<ul>
<li>编写带有native方法的Java类和声明要加载的类库</li>
<li>使用javah命令生成.h头文件（也可以用<strong>JNI_OnLoad</strong>动态注册函数，就不用生成.h头文件了）</li>
<li>编写C代码实现头文件中的方法</li>
</ul>
<h4 id="编写Java端代码"><a href="#编写Java端代码" class="headerlink" title="编写Java端代码"></a>编写Java端代码</h4><p>​        用官方文档中的<code>hello_jni</code>例程修改的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellojni;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> <span class="keyword">extends</span> <span class="title class_">Activity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** Called when the activity is first created. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TextView</span>  <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextView</span>(<span class="built_in">this</span>);</span><br><span class="line">        tv.setText( stringFromJNI() );</span><br><span class="line">        setContentView(tv);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title function_">unimplementedStringFromJNI</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;hellojni&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写C端代码"><a href="#编写C端代码" class="headerlink" title="编写C端代码"></a>编写C端代码</h4><p>1、获取C语言的接口函数声明</p>
<p>​        根据Java对于C语言接口的定义，生成相应的接口函数声明。说通俗点就是Java层只是用<strong>native</strong>关键词声明了一个C语言的函数，要在Java层的函数和C语言层的函数之间形成一个映射关系，这一步需要用到JDK中的“javac -h”命令。</p>
<p>​        尴尬的是在生成头文件的时候出现了<strong>程序包XX.XX不存在</strong>的BUG，网上找了一会发现并没有卵用，于是乎就直接定义<code>JNI_Onload</code>方法形成动态函数映射。<font color=red>（跳过第一步生成.h头文件的步骤即可）</font></p>
<p>下面的第三步就讲讲如何用<code>JNI_Onload</code>：</p>
<blockquote>
<p>传统java  JNI方式： 编写带有native方法的Java类 → 使用javah命令生成.h头文件 → 编写代码实现头文件中的方法</p>
<p>但是上述每次都需要通过javah依据java类的全类名生成对应的native函数全名称，其实我们可以使用RegisterNatives方法把c/c++中的方法隐射到Java中的native方法，这样就可以随意定义你的函数名而不用写那么长的又看不懂的全名类啦！</p>
</blockquote>
<p>2、编写C语言代码</p>
<p>在项目根目录下创建<code>jni</code>目录：<code>jni</code>目录中新建<code>hellojni.c</code>文件，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="comment">// 用的雷佬的代码 -- 该函数调用了libavcodec的avcodec_configuration()方法，用于获取FFmpeg的配置信息。</span></span><br><span class="line">jstring <span class="title function_">stringFromJNI</span><span class="params">( JNIEnv* env,jobject thiz )</span></span><br><span class="line">&#123;</span><br><span class="line">   	<span class="type">char</span> info[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   	<span class="built_in">sprintf</span>(info, <span class="string">&quot;%s\n&quot;</span>, avcodec_configuration());</span><br><span class="line">   	<span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、定义函数<code>JNI_OnLoad</code>动态注册函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM* pVm, <span class="type">void</span>* reserved)</span> &#123;</span><br><span class="line">	JNIEnv* env;</span><br><span class="line">	<span class="keyword">if</span> ((*pVm)-&gt;GetEnv(pVm, (<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">	 	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	JNINativeMethod nm[<span class="number">1</span>];</span><br><span class="line">	nm[<span class="number">0</span>].name = <span class="string">&quot;stringFromJNI&quot;</span>;</span><br><span class="line">	nm[<span class="number">0</span>].signature = <span class="string">&quot;()Ljava/lang/String;&quot;</span>;</span><br><span class="line">	nm[<span class="number">0</span>].fnPtr = (<span class="type">void</span>*)stringFromJNI;</span><br><span class="line">	jclass cls = (*env)-&gt;FindClass(env, <span class="string">&quot;com/example/hellojni/HelloJni&quot;</span>);</span><br><span class="line">	(*env)-&gt;RegisterNatives(env, cls, nm, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        前后都是固定的模板，不需要修改，只需要更改<code>JNINativeMethod</code>中的字段信息，关于JNI编程的简单语法都很简单，去了解一下就可，不在这里说了。其实就是用这个<code>RegisterNatives</code>注册方法，C语言本地的函数与Java层的类和函数进行动态绑定。</p>
<p><code>JNINativeMethod</code>结构体的字段信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;     <span class="comment">// java层对应的方法名称  </span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature;<span class="comment">// 该方法的返回值类型和参数类型  </span></span><br><span class="line">    <span class="type">void</span>*       fnPtr;    <span class="comment">// native中对应的函数指针  </span></span><br><span class="line">&#125; JNINativeMethod;  </span><br></pre></td></tr></table></figure>

<p>3、<code>Android.mk</code>和 <code>Application.mk</code>编写</p>
<p>​        在<code>JNI</code>目录下创建<code>Android.mk</code>和 <code>Application.mk</code>文件。这是NDK官方推荐的<code>ndk-build</code>（是一个命令行工具，它用于构建使用C/C++编写的Android Native库）构建方式的脚本文件（不过yysy现在用的更多的是<code>cmake</code>了，反正ndk-build很好用，管他的呢）。</p>
<p><code>Android.mk</code>的编写规范可以看NDK的官方文档，<code>Android.mk</code>添加如下代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">LOCAL<span class="emphasis">_PATH := $(call my-dir)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># FFmpeg library</span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avcodec</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavcodec.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avdevice</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavdevice.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avfilter</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavfilter.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avformat</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavformat.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avutil</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavutil.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := swresample</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libswresample.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := swscale</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libswscale.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># Program</span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := hellojni</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := hellojni.c</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>C<span class="emphasis">_INCLUDES += $(LOCAL_</span>PATH)/include</span><br><span class="line">LOCAL<span class="emphasis">_LDLIBS := -llog -lz</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SHARED<span class="emphasis">_LIBRARIES := avcodec avdevice avfilter avformat avutil swresample swscale</span></span><br><span class="line"><span class="emphasis">include $(BUILD_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p><code>Application.mk</code>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">APP<span class="emphasis">_ABI := arm64-v8a</span></span><br><span class="line"><span class="emphasis">APP_</span>PLATFORM := android-23  # minAPI</span><br></pre></td></tr></table></figure>

<p><code>APP_ABI</code> 指定了设备CPU的架构。因为前面编译<code>FFmpeg</code>的时候我只编译了64位版本的，这里就对应上。</p>
<p>4、NDK-BUILD编译</p>
<p>​        将先前编译的FFmpeg的<code>include</code>和<code>lib</code>目录复制到<code>jni</code>目录当中来，现在看<code>jni</code>目录结构应该是这样的：</p>
<img src="pic5.png" alt="image-20230312171910710" style="zoom: 80%;" />

<p>​        命令行<code>cd</code>到这一层目录下，执行<code>ndk-build</code>命令即可。</p>
<img src="pic6.png" alt="image-20230312172026460" style="zoom:80%;" />

<p>​        然后你还会发现项目的根目录下生成了这两个目录。</p>
<p><img src="pic7.png" alt="image-20230312172123920"></p>
<p>​        <code>libs</code>里面就是根据<code>android.mk</code>脚本编译的.so库了，<code>obj</code>没什么用，里面就是一些编译的过程文件。将<code>libs</code>目录中的内容（应该是cpu架构文件夹，下层目录才是.so库）copy到<code>app/src/main</code>目录的<code>jniLibs</code>目录当中（项目运行时默认就是在<code>jniLibs</code>中寻找加载相应的第三方.so库）。</p>
<img src="pic8.png" alt="image-20230312172450844" style="zoom: 67%;" />

<p>​        接下来就可以在手机上对项目进行测试啦！因为我使用的是<code>arm64-v8a</code>cpu架构，这种架构好像不支持在虚拟机上测试（虚拟机架构是<code>x86</code>和<code>x86_64</code>，但可不可以我也没试过）。</p>
<p>​        下面是测试的结果啦：</p>
<img src="result_pic.jpg" alt="result_pic" style="zoom: 33%;" />
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JNI开发</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的深浅拷贝</title>
    <url>/2023/07/14/Java%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>今天在刷算法题的时候忘记了引用数据类型深浅拷贝的问题，正好借此机会来复习一下。</p>
<span id="more"></span>

<h2 id="拷贝的分类"><a href="#拷贝的分类" class="headerlink" title="拷贝的分类"></a>拷贝的分类</h2><ul>
<li><p>引用拷贝</p>
<p>没有创建新的内存空间，只是复制了一个引用变量指向了堆空间中相同的地址。</p>
</li>
<li><p>对象拷贝</p>
<p>创建对象的一个副本，创建了新的对象指向不同的地址空间。而深浅拷贝的区别在于<strong>对象里面的属性拷贝方式</strong>。</p>
<ul>
<li><p>浅拷贝</p>
<p>属性就是引用拷贝，指向同一地址。</p>
</li>
<li><p>深拷贝</p>
<p>属性也是对象拷贝，不是同一地址。</p>
</li>
</ul>
</li>
</ul>
<h2 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;riemann&quot;</span>, <span class="number">28</span>);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">otherTeacher</span> <span class="operator">=</span> teacher;  <span class="comment">// 没有创建新的对象</span></span><br><span class="line">System.out.println(teacher);</span><br><span class="line">System.out.println(otherTeacher);</span><br></pre></td></tr></table></figure>

<img src="image-20230714215404681.png" alt="image-20230714215404681" style="zoom: 45%;" />

<p>它们的地址值是相同的，<code>teacher</code>和<code>otherTeacher</code>只是引用而已，他们都指向了一个相同的对象<code>Teacher(“riemann”,28)</code>。</p>
<h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;riemann&quot;</span>, <span class="number">28</span>);</span><br><span class="line">  <span class="type">Teacher</span> <span class="variable">otherTeacher</span> <span class="operator">=</span> (Teacher) teacher.clone();</span><br><span class="line">  System.out.println(teacher);</span><br><span class="line">  System.out.println(otherTeacher);</span><br></pre></td></tr></table></figure>

<img src="image-20230714215759090.png" alt="image-20230714215759090" style="zoom:45%;" />

<p>它们的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量，这就叫做对象拷贝。</p>
<p>由于<code>age</code>是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。但是<code>name</code>是String类型的， 它只是一个引用， 指向一个真正的String对象，那么对它的拷贝有两种方式将对象拷贝分为了浅拷贝和深拷贝。</p>
<ul>
<li>直接将源对象中的<code>name</code>的引用值拷贝给新对象的<code>name</code>字段；</li>
<li>根据<code>原Person</code>对象中的<code>name</code>指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给<code>新拷贝的Person</code>对象的<code>name</code>字段。</li>
</ul>
<p>Student类和Teacher类的pojo结构是这样的：</p>
<p>​                                                                        <img src="image-20230714215314001.png" alt="image-20230714215314001"></p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p>
<p><img src="image-20230714220049094.png" alt="image-20230714220049094"></p>
<p>无论是String对象还是pojo对象，它们都是引用数据类型：</p>
<img src="image-20230714220406867.png" alt="image-20230714220406867" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) student1.clone();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Object类本身没有实现<code>Cloneable</code>接口，所以要使用clone方法必须在pojo类上实现该接口。</p>
</blockquote>
<p>两个引用<code>student1</code>和<code>student2</code>指向不同的两个对象，但是两个引用<code>student1</code>和<code>student2</code>中的<code>teacher</code><strong>引用指向的是同一个对象</strong>，所以说明是<strong>浅拷贝</strong>。</p>
<p><code>Cloneable</code>接口中的<code>clone()</code>方法是浅拷贝的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p>
<p><img src="image-20230714221034487.png" alt="image-20230714221034487"></p>
<p>无论是String对象还是pojo对象，它们都是引用数据类型：</p>
<img src="image-20230714221056367.png" alt="image-20230714221056367" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) student1.clone();</span><br></pre></td></tr></table></figure>

<p>两个引用<code>student1</code>和<code>student2</code>指向不同的两个对象，两个引用<code>student1</code>和<code>student2</code>中的两个<code>teacher</code>引用指向的是两个对象。对<code>student1</code>中的<code>teacher</code>属性的修改只能影响<code>student1</code>对象，所以说是<strong>深拷贝</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="comment">// 深拷贝时：</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">    student.setTeacher((Teacher)student.getTeacher().clone());</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>讲到对象的拷贝，突然想到字符串，字符串也是一种引用数据类型，这在初学中是容易被忽视掉的。</p>
<ul>
<li><p>String字符串的基本特性</p>
<ul>
<li>String声明为<code>final</code>的，不可被继承、不可变特性；</li>
<li>String实现了<code>Serializable</code>接口：表示字符串是支持序列化的；实现了<code>Comparable</code>接口：表示String可以比较大小；</li>
<li>String在jdk8及以前内部定义了<code>final char [] value</code>用于存储字符串数据，<code>jdk9</code>时改为<code>byte[]</code>；</li>
</ul>
</li>
<li><p>字符串连接池</p>
</li>
</ul>
<p>为了减少在jvm中创建的字符串的数量，虚拟机维护了一个字符串常量池。当创建String对象时，jvm会先检查字符串常量池，如果这个字符串的常量值已经存在在池中了，就直接返回池中对象的引用，如果不在池中，就会实例化一个字符串并放入池中。</p>
<h3 id="String不可变性"><a href="#String不可变性" class="headerlink" title="String不可变性"></a>String不可变性</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247487062&idx=2&sn=00ba05ef2f80488b1860d6d49e8b9557&chksm=eb538b60dc240276fc745eca8b7667364ea6ca86092d8f404b0bde5ec03dbcd81a4bc3a9454d#rd">Java 中的 String 真的是不可变的吗？</a></p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Python&quot;</span>;</span><br><span class="line">System.out.println(str); <span class="comment">// Python</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">System.out.println(str); <span class="comment">// Java</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">&quot;ABC&quot;</span>;  <span class="comment">// 相当于new String(&quot;ABC&quot;)，交给str2的引用</span></span><br><span class="line">System.out.println(str1 + <span class="string">&quot;----------&quot;</span> + str2);  <span class="comment">// str1=&quot;abc&quot;, str2=&quot;ABC&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;  <span class="comment">// 在底层是StringBuilder.toString而来的，相当于new String(s1+s2);</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当调用String的<code>replace()</code>方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2023/07/17/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>复习一下Java的集合：分为单列集合和双列集合，单列集合有List和Set两类，双列集合是Map集合。<code>List</code>接口的实现类有ArrayList, LinkedList；Set和Map可以配合着学，主要有HashSet–HashMap, LinkedHashSet–LinkedHashMap, TreeSet–TreeMap三组。</p>
<span id="more"></span>

<img src="image-20230718120825421.png" alt="image-20230718120825421" style="zoom:67%;" />

<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><img src="image-20230718120851741.png" alt="image-20230718120851741" style="zoom:67%;" />

<p>总结一下Collection单列集合的常用功能有哪些，<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>集合都可以调用下面的方法：</p>
<img src="image-20230718121036160.png" alt="image-20230718121036160" style="zoom:77%;" />

<p><strong>Collection集合的遍历方式：</strong></p>
<ul>
<li><p>迭代器遍历集合</p>
<ul>
<li>当调用<code>iterator()</code>方法获取迭代器时，当前指向第一个元素；</li>
<li><code>hasNext()</code>方法则判断这个位置是否有元素，如果有则返回<code>true</code>，进入循环；</li>
<li>调用<code>next()</code>方法获取元素，并将当月元素指向下一个位置；</li>
<li>等下次循环时，则获取下一个元素，依此类推。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增强for遍历集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String context: list)&#123;</span><br><span class="line">    System.out.println(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>forEach</code>遍历集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*  ======Lambda表达式简化=======  */</span></span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>当往集合中存对象时，实际上存储的是对象的地址值：</strong></p>
<p><img src="image-20230718122238215.png" alt="image-20230718122238215"></p>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><img src="image-20230718122400682.png" alt="image-20230718122400682" style="zoom:77%;" />

<p><strong>List集合的常用方法：</strong></p>
<img src="image-20230718122435550.png" alt="image-20230718122435550" style="zoom:67%;" />

<p>因为List集合有索引，所以可以通过普通for循环的方式遍历List集合。</p>
<h3 id="Arraylist集合"><a href="#Arraylist集合" class="headerlink" title="Arraylist集合"></a>Arraylist集合</h3><p><code>ArrayList</code>集合底层是基于数组结构实现的，也就是说当你往集合容器中存储元素时，底层本质上是往数组中存储元素。 特点如下：</p>
<img src="image-20230718122710834.png" alt="image-20230718122710834" style="zoom:77%;" />

<p>我们知道数组的长度是固定的，但是集合的长度是可变的，这是怎么做到的呢？</p>
<img src="image-20230718122825047.png" alt="image-20230718122825047" style="zoom:77%;" />

<p>数组扩容，并不是在原数组上扩容（原数组是不可以扩容的），底层是创建一个新数组，然后把原数组中的元素全部复制到新数组中去。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList底层是<strong>双向链表</strong>结构。</p>
<p><img src="image-20230718123113316.png" alt="image-20230718123113316"></p>
<p>所以相对于<code>ArrayList</code>新增了一些可以针对头尾进行操作的方法，如下图示所示：</p>
<img src="image-20230718123129380.png" alt="image-20230718123129380" style="zoom:77%;" />

<p><strong>由于双向链表的结构，可以用它来设计栈、队列：</strong></p>
<img src="image-20230718123341697.png" alt="image-20230718123341697" style="zoom:50%;" />

<img src="image-20230718123356578.png" alt="image-20230718123356578" style="zoom:50%;" />

<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><img src="image-20230717220114816.png" alt="image-20230717220114816" style="zoom:77%;" />

<h3 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h3><img src="image-20230717221646999.png" alt="image-20230717221646999" style="zoom: 72%;" />

<img src="image-20230717221809732.png" alt="image-20230717221809732" style="zoom:72%;" />

<p><strong>HashSet去重原理</strong></p>
<p>前面我们学习了HashSet存储元素的原理，依赖于两个方法：一个是<code>hashCode</code>方法用来确定在底层数组中存储的位置，另一个是用<code>equals</code>方法判断新添加的元素是否和集合中已有的元素相同。</p>
<p>要想保证在HashSet集合中没有重复元素，我们需要重写对象类的<code>hashCode</code>和<code>equals</code>方法。比如以下面的<code>User</code>类为例，假设把<code>User</code>类的对象作为HashSet集合的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;User&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ljc&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ljc&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">hs.add(u1);</span><br><span class="line">hs.add(u2);</span><br><span class="line">System.out.println(hs);  <span class="comment">// [User&#123;username = ljc, password = 123&#125;, User&#123;username = ljc, password = 123&#125;]</span></span><br></pre></td></tr></table></figure>

<p>我们发现结果和我们想象的不一样，HashSet不是可以去重吗？实际上，通常两个不同对象的HashCode值是不同的，导致元素挂在了不同的数组位置上。要解决这个问题要重写对象类的<code>hashCode</code>和<code>equals</code>方法——直接generate自动生成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(username, user.username) &amp;&amp; Objects.equals(password, user.password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><p><code>LinkedHashSet</code>类是<code>HashSet</code>的子类。<code>LinkedHashSet</code>它底层采用的是也是哈希表结构，只不过额外新增了一个<strong>双向链表</strong>来维护元素的存取顺序。</p>
<p>特点：相比<code>HashSet</code>，它记录了元素存入的顺序。</p>
<img src="image-20230717225009568.png" alt="image-20230717225009568" style="zoom:67%;" />

<h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><p>TreeSet集合的特点是可以对元素进行排序（底层是<strong>红黑树</strong>实现的），但是<strong>必须指定元素的排序规则</strong>。如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。如果往TreeSet集合中存储自定义类型的元素，比如说<code>User</code>类型，则需要我们自己指定排序规则，否则会出现异常，原因是TreeSet不知道按照什么条件对自定义对象来排序：</p>
<p><img src="image-20230717225542069.png" alt="image-20230717225542069"></p>
<p>我们想要告诉TreeSet集合按照指定的规则排序，有两种办法：</p>
<p>第一种：在创建TreeSet集合时，通过构造方法传递<code>Compartor</code>比较器对象；</p>
<p>第二种：让元素的类实现<code>Comparable</code>接口，重写<code>compareTo</code>方法；</p>
<ul>
<li><p>第一种：创建集合时传递比较器对象</p>
<p><code>o1-o2</code>是升序排序，<code>o2-o1</code>是降序排序。</p>
<blockquote>
<p>Double类型用<code>Double.compare(d1, d2)</code>比较，String类型用<code>s1.compareTo(s2)</code>方法比较。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;User&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User o1, User o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getUsername().compareTo(o2.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>第二种：实体类实现<code>Comparable</code>接口，重写<code>compareTo</code>方法</p>
<p><code>this</code>：表示将要添加进去的Student对象；<code>o</code>: 表示集合中已有的Student对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"> 		<span class="comment">/* ...... */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username.compareTo(o.username);  <span class="comment">// 升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>自然排序<code>Comparable</code>是类在创建的时候就规定了类的比较的特性，而比较器<code>Comparator</code>是在具体的应用过程中我们根据需求创建一个工具类来完成比较，相比之下比较器的使用更加灵活（有的时候需要对同一对象进行多种不同方式的排序；或者按照特定的需求比较字符串但无法重写<code>String</code>类中的<code>compareTo</code>方法），不会改变这个类本身，降低了耦合度。</p>
<h3 id="Collection集合总结"><a href="#Collection集合总结" class="headerlink" title="Collection集合总结"></a>Collection集合总结</h3><img src="image-20230718101153256.png" alt="image-20230718101153256" style="zoom:67%;" />

<h3 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h3><p><font color="red">在使用迭代器遍历集合时，可能存在并发修改异常：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  list.add(<span class="string">&quot;王麻子&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;小李子&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;李爱花&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;张全蛋&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;晓李&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;李玉刚&quot;</span>);</span><br><span class="line">  System.out.println(list); <span class="comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span></span><br><span class="line">  Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">      <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">          list.remove(name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(list);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230718101929828.png" alt="image-20230718101929828"></p>
<p>这是因为迭代器遍历机制，规定<strong>迭代器遍历集合的同时，不允许集合自己去增删元素</strong>。</p>
<p>增强for循环遍历方式，是在内部调用迭代器进行遍历，所以也会出现并发修改异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String name: list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        list.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>简单for循环遍历方式，不会出发迭代器的并发修改异常，但会造成结果出错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        list.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);  <span class="comment">// [王麻子, 李爱花, 张全蛋, 李玉刚]</span></span><br></pre></td></tr></table></figure>

<p><code>[王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</code>，以上述list集合为例，当<code>i=1</code>时<code>remove</code>了“小李子”元素，这时候<code>i=1</code>的元素变成了“李爱花”，而循环执行了<code>i++</code>，该元素就被跳过去了。解决方案是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">            list.remove(name);</span><br><span class="line">            i--;  <span class="comment">// 因为普通for循环没有异常出现，所以在逻辑上将每次remove元素后的索引i--即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而迭代器遍历解决并发修改异常的方法是，使用迭代器的修改元素方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        it.remove();  <span class="comment">// 当前迭代器指向谁，就删除谁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p><strong>可变参数</strong></p>
<ul>
<li><p>可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。</p>
</li>
<li><p>可变参数在方法内部，<strong>本质上是一个数组</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    test(<span class="number">1</span>);</span><br><span class="line">    test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>...nums)</span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个形参列表中，只能有一个可变参数；否则会报错。</li>
<li>形参列表中如果多个参数，可变参数需要写在最后；否则会报错。</li>
</ul>
<p><strong>Collections工具类</strong></p>
<p><img src="image-20230718105406211.png" alt="image-20230718105406211"></p>
<p>往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储实体类对象，这个时候想要对List集合进行排序自定义比较规则的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User o1, User o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getPassword().compareTo(o2.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以<code>key=value</code>的形式存在的，一个<code>key=value</code>就称之为一个键值对，而且在 Java 中有一个类叫<code>Entry</code>类，Entry的对象用来表示键值对对象。</p>
<p>Map集合有如下的特点：<strong>键不能重复，值可以重复，每一个键只能找到自己对应的值。</strong></p>
<img src="image-20230718111534965.png" alt="image-20230718111534965" style="zoom:77%;" />

<h3 id="Map集合常用方法"><a href="#Map集合常用方法" class="headerlink" title="Map集合常用方法"></a>Map集合常用方法</h3><img src="image-20230718112151598.png" alt="image-20230718112151598" style="zoom:87%;" />

<h3 id="Map集合遍历方法"><a href="#Map集合遍历方法" class="headerlink" title="Map集合遍历方法"></a>Map集合遍历方法</h3><ul>
<li><p>方式一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">162.5</span>);</span><br><span class="line">map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">  </span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key: keys)&#123;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;---&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<p>Map集合是用来存储键值对的，而每一个键值对实际上是一个<code>Entry</code>对象。可以直接获取每一个<code>Entry</code>对象，把<code>Entry</code>存储扫Set集合中去，再通过<code>Entry</code>对象获取键和值。</p>
<p><img src="image-20230718112943729.png" alt="image-20230718112943729"></p>
<p>Map集合提供<code>entrySet</code>方法，把Map集合转换成键值对类型的Set集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry: entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;---&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式三</p>
<p><img src="image-20230718113224411.png" alt="image-20230718113224411"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k, Double v)</span> &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;---&gt;&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>集合的特点是由键决定的： <strong>它的键是无序、不能重复，而且没有索引的</strong>。在各种Map集合中也是用得最多的一种集合。</p>
<p><code>HashMap</code>底层原理和<code>HashSet</code>是一样的。因为我们往<code>HashSet</code>集合中添加元素时，实际上是把元素作为<code>key</code>添加到了<code>HashMap</code>集合中。</p>
<p><img src="image-20230718114026273.png" alt="image-20230718114026273"></p>
<p><code>HashMap</code>和<code>HashSet</code>是一样的，底层是哈希表结构，哈希表是一种增删改查性能相对都较好的数据结构。</p>
<img src="image-20230718114458631.png" alt="image-20230718114458631" style="zoom:77%;" />

<ul>
<li><p>往HashMap集合中键值对数据时，底层步骤如下：</p>
<ul>
<li>第1步：当你第一次往<code>HashMap</code>集合中存储键值对时，底层会创建一个<strong>长度为16的数组</strong>；</li>
<li>第2步：把键然后将键和值封装成一个对象，叫做<code>Entry</code>对象；</li>
<li>第3步：再根据<code>Entry</code>对象的键计算<code>hashCode</code>值（和值无关）；</li>
<li>第4步：利用<code>hashCode</code>值和数组的长度做一个类似求余数的算法，会得到一个索引位置；</li>
<li>第5步：判断这个索引的位置是否为<code>null</code>：如果为<code>null</code>，就直接将这个<code>Entry</code>对象存储到这个索引位置；如果不为<code>null</code>，则还需要进行第6步的判断；</li>
<li>第6步：继续调用equals方法判断两个对象键是否相同：如果<code>equals</code>返回<code>false</code>，则以链表的形式往下挂；如果<code>equals</code>方法<code>true</code>，则认为键重复，此时新的键值对会替换就的键值对。</li>
</ul>
</li>
<li><p>HashMap底层需要注意这几点：</p>
<ul>
<li>底层数组默认长度为16，如果数组中有超过12个位置已经存储了元素，则会对数组进行扩容<strong>2倍</strong>。数组扩容的加载因子是 0.75 ，意思是：<code>16*0.75=12</code>； </li>
<li>数组的同一个索引位置有多个元素、并且在8个元素以内（包括8），则以链表的形式存储（JDK8以后版本链表采用尾插法）。</li>
<li>数组的同一个索引位置有多个元素、并且超过了8个，则以红黑树形式存储。       </li>
</ul>
</li>
<li><p>决定键是否重复与两个方法有关，一个是<code>hashCode</code>方法、一个是<code>equals</code>方法。有两个键计算得到的<code>hashCode</code>值相同，并且两个键使用<code>equals</code>比较为<code>true</code>，就认为键重复。所以，往Map集合中存储自定义对象作为键，为了保证键的唯一性，我们应该重写这两个方法。</p>
</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><code>LinkedHashMap</code>集合的特点也是由键决定的：<strong>有序的、不重复、无索引</strong>。<font color="blue">这里的“有序”是只存入的顺序。</font><code>LinkedHashMap</code>的底层原理，和<code>LinkedHashSet</code>底层原理是一样的，底层多个一个双向链表来维护键的存储顺序。</p>
<img src="image-20230718115713991.png" alt="image-20230718115713991" style="zoom:77%;" />

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code>集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。<code>TreeMap</code>集合的底层原理和<code>TreeSet</code>也是一样的，底层都是<strong>红黑树</strong>实现的，所以可以对键进行排序。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6-5830-Lab1</title>
    <url>/2024/08/06/MIT6-5830-Lab1/</url>
    <content><![CDATA[<p>前段时间学习一下 MySQL，正好准备一个手撕轮子项目，就准备完成这个 MIT6.5830 的数据库课程。Lab1 主要是完成一些简单的数据库定义以及实现简单的全表扫描。</p>
<span id="more"></span>

<h2 id="任务目录"><a href="#任务目录" class="headerlink" title="任务目录"></a>任务目录</h2><ul>
<li><p><input checked="" disabled="" type="checkbox">  exercise1：实现元组以及元组属性字段</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  exercise2：实现数据库目录，包含数据库现有的表信息</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  exercise3：实现BufferPool，将内存读取过的数据页缓存下来</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  exercise4：实现页面id、数据记录id以及Page类</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  exercise5：实现磁盘文件的接口HeapFile，通过HeapFile可以从磁盘读写数据</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  exercise6：实现全表扫描</p>
</li>
</ul>
<h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><blockquote>
<p>实现Tuple、TupleDesc两个类</p>
</blockquote>
<p>在数据库中，行被称为元组(tuple)或记录(record)，列称为字段(field)。tuple元组在数据库中是一组Field对象的集合。</p>
<p><img src="image-18.png"></p>
<h3 id="TupleDesc类"><a href="#TupleDesc类" class="headerlink" title="TupleDesc类"></a>TupleDesc类</h3><p><img src="image-15.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>private CopyOnWriteArrayList&lt;TDItem&gt; tdItems</code></li>
</ul>
<blockquote>
<p>TupleDesc中提供了一个TDItem内部辅助类，类中定义了<code>Type fieldType</code>和<code>String fieldName</code>两个成员变量（Type是枚举类型，当前只实现了INT_TYPE和STRING_TYPE）。</p>
</blockquote>
<p><strong>方法：</strong></p>
<ul>
<li><p>初始化方法：<code>public TupleDesc(Type[] typeAr, String[] fieldAr)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TupleDesc</span><span class="params">(Type[] typeAr, String[] fieldAr)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    tdItems = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (typeAr.length != fieldAr.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeAr.length; i++) &#123;</span><br><span class="line">        tdItems.add(<span class="keyword">new</span> <span class="title class_">TDItem</span>(typeAr[i], fieldAr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回所有属性的迭代器：<code>public Iterator&lt;TDItem&gt; iterator()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;TDItem&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (tdItems == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tdItems.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回TupleDesc属性的数量：<code>public int numFields()</code></p>
</li>
<li><p>返回第i个属性的属性名：<code>public String getFieldName(int i)</code></p>
</li>
<li><p>返回第i个属性的属性类型：<code>public Type getFieldType(int i)</code></p>
</li>
<li><p>根据属性名返回属性在tditem中的序号：<code>public int indexForFieldName(String name)</code></p>
</li>
<li><p>返回此TupleDesc对应的元组所占字节大小：<code>public int getSize()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dataSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numFields(); i++) &#123;</span><br><span class="line">        <span class="comment">// Type中存在getLen()方法，可获取INT_TYPE和STRING_TYPE字节数</span></span><br><span class="line">        dataSize += tdItems.get(i).fieldType.getLen();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并两个TupleDesc：<code>public static TupleDesc merge(TupleDesc td1, TupleDesc td2)</code></p>
</li>
<li><p>判断两个TupleDesc是否相等：<code>public boolean equals(Object o)</code></p>
<p>相等条件：两个TupleDesc的属性数量相等，且tditem1[i]和tditem2[i]属性类型相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// instanceof 测试左边的对象是否是右边“特定类or其子类”的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> TupleDesc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TupleDesc</span> <span class="variable">other</span> <span class="operator">=</span> (TupleDesc) o;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.numFields() != other.numFields() || <span class="built_in">this</span>.tdItems.size() != other.tdItems.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.numFields(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.getFieldType(i).equals(other.getFieldType(i))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>instanceof</li>
</ol>
<p>语法：<code>boolean result = object instanceof Class（该类、父类、接口）;</code></p>
<p>用法：① 判断object对象是否是class类实例； ② 判断object对象是否是class类的子类的实例； ② 判断object对象是否是接口实现类的实例。</p>
<p><img src="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;===============instanceof阶段测试1===============&quot;</span>);</span><br><span class="line"><span class="comment">// 判断object对象是否为 class类本身的实例</span></span><br><span class="line">System.out.println(computer <span class="keyword">instanceof</span> Computer);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断object对象是否为 class类的子类的实例</span></span><br><span class="line">System.out.println(computer <span class="keyword">instanceof</span> Machine);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断object对象是否为 接口的实现类的实例</span></span><br><span class="line">System.out.println(mouse <span class="keyword">instanceof</span> usb);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===============instanceof阶段测试2===============&quot;</span>);</span><br><span class="line"><span class="comment">// 所有对象都为Object类</span></span><br><span class="line">System.out.println(computer <span class="keyword">instanceof</span> Object);  <span class="comment">// true</span></span><br><span class="line">System.out.println(mouse <span class="keyword">instanceof</span> Object);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===============instanceof阶段测试3===============&quot;</span>);</span><br><span class="line"><span class="comment">// null不是任何类的实例</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Object);  <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Computer);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>isInstance</li>
</ul>
<p>语法：<code>boolean result = Class.class.isInstance(object);</code></p>
<p>用法：同上（判断object对象能否被转化为这个Class类）</p>
</blockquote>
</li>
<li><p>返回该TupleDesc的哈希值：<code>public int hashCode()</code></p>
</li>
<li><p>展示TupleDesc的所有属性类型+属性名：<code>public String toString()</code></p>
</li>
</ul>
<h3 id="Tuple类"><a href="#Tuple类" class="headerlink" title="Tuple类"></a>Tuple类</h3><p><img src="image-19.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><p><code>private TupleDesc td;</code></p>
</li>
<li><p>元组的id：<code>private RecordId rid;</code></p>
</li>
<li><p>存储Tuple中所有字段：<code>CopyOnWriteArrayList&lt;Field&gt; fields;</code></p>
<blockquote>
<p>Field接口，包含compare()、getType()、equals()、toString()方法，IntField 和 StringField 类实现了该接口。</p>
</blockquote>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Tuple(TupleDesc td)</code></p>
</li>
<li><p>获得元组对应的字段属性：<code>public TupleDesc getTupleDesc()</code></p>
</li>
<li><p>获得元组id：<code>public RecordId getRecordId()</code></p>
</li>
<li><p>设置元组id：<code>public void setRecordId(RecordId rid)</code></p>
</li>
<li><p>为Tuple的第i个字段赋值：<code>public void setField(int i, Field f)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">(<span class="type">int</span> i, Field f)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= fields.size()) &#123;</span><br><span class="line">        fields.add(f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fields.set(i, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获得第i个字段：<code>public Field getField(int i)</code></p>
</li>
<li><p>展示该Tuple的所有字段值：<code>public String toString()</code></p>
</li>
<li><p>返回元组字段的迭代器：<code>public Iterator&lt;Field&gt; fields()</code></p>
</li>
<li><p>重置TupldeDesc：<code>public void resetTupleDesc(TupleDesc td)</code></p>
</li>
</ul>
<p><img src="image-17.png"></p>
<h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><blockquote>
<p>实现Catalog类</p>
</blockquote>
<p><img src="image-4.png"></p>
<h3 id="Catalog类"><a href="#Catalog类" class="headerlink" title="Catalog类"></a>Catalog类</h3><p>Catalog管理着数据库中的所有表：</p>
<p><img src="image-1.png"></p>
<blockquote>
<p>dbFile是什么 —— 每一个DbFile对应数据库中的一张表。</p>
<p><img src="image-10.png"></p>
<p><img src="image-11.png"></p>
</blockquote>
<p><strong>参数：</strong></p>
<ul>
<li><p>表id与表的映射：<code>ConcurrentHashMap&lt;Integer, Table&gt; tableIdMap;</code></p>
<blockquote>
<p>Table类包含参数tableName、pkeyField（表中的主键）、dbFile（存储表内容）</p>
</blockquote>
</li>
<li><p>表名与表id的映射（方便通过tableName获取table）：<code>ConcurrentHashMap&lt;String, Integer&gt; tableNameMap;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Catalog()</code></p>
</li>
<li><p>向Catalog中添加表：<code>public void addTable(DbFile file, String name, String pkeyField)</code></p>
</li>
<li><p>根据表明获取表id：<code>public int getTableId(String name)</code></p>
</li>
<li><p>&#x20;通过表id获取表TupleDesc：<code>public TupleDesc getTupleDesc(int tableId)</code></p>
</li>
<li><p>通过表id获取表的内容dbFile：<code>public DbFile getDatabaseFile(int tableId)</code></p>
</li>
<li><p>通过表id获取表的主键：<code>public String getPrimaryKey(int tableId)</code></p>
</li>
<li><p>返回tableId的迭代器：<code>public Iterator&lt;Integer&gt; tableIdIterator()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">tableIdIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> tableIdMap.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过表id获取表名：<code>public String getTableName(int id)</code></p>
</li>
<li><p>清空Catalog：<code>public void clear()</code></p>
</li>
</ul>
<p><img src="image-14.png"></p>
<h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><blockquote>
<p>实现BufferPool的构造器和getPage()方法</p>
</blockquote>
<h3 id="BufferPool类"><a href="#BufferPool类" class="headerlink" title="BufferPool类"></a>BufferPool类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>默认page大小：<code>private static final int </code><em><code>DEFAULT_PAGE_SIZE </code></em><code>= 4096;</code> <code>private static int </code><em><code>pageSize </code></em><code>= </code><em><code>DEFAULT_PAGE_SIZE</code></em><code>;</code></p>
</li>
<li><p>BufferPool能获取的page数量：<code>private final int numPages;</code></p>
</li>
<li><p>pageId到page的映射：<code>private final Map&lt;PageId, Page&gt; bufferPools = new ConcurrentHashMap&lt;&gt;();</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public BufferPool(int numPages)</code></p>
</li>
<li><p>从BufferPool中根据pageId获取对应的page，如果BufferPool中不存在就去磁盘搜索并保存到BufferPool：<code>public Page getPage(TransactionId tid, PageId pid, Permissions perm)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span>(!bufferPools.containsKey(pid)) &#123;</span><br><span class="line">        <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> file.readPage(pid);</span><br><span class="line">        bufferPools.put(pid, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bufferPools.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取page的方法有且只有<code>BufferPool.getPage()</code>。</p>
<p>通过一个具体的索引页id就可以找到一张特定的数据表，所以我们可以认为：“<strong>在一个数据页上只能存储同一张表的数据”</strong>。</p>
<p><img src="image-9.png" alt="copilot解答"></p>
<ol>
<li>数据组织和查询效率</li>
</ol>
<ul>
<li><p><strong>连续存储</strong>：将同一张表的数据存储在连续的页面中，有助于提高查询效率。读取一个表的数据时，可以通过顺序扫描这些页面，减少磁盘寻道时间。</p>
</li>
<li><p><strong>索引效率</strong>：索引通常是基于表的。当页面只存储一张表的数据时，索引查找可以更快地定位数据。</p>
</li>
</ul>
<ul>
<li>数据一致性和隔离</li>
</ul>
<ul>
<li><p><strong>事务管理</strong>：事务的隔离级别要求对表的操作是可预测和隔离的。将不同表的数据混合在同一个页面中，可能会导致复杂的锁管理和数据一致性问题。</p>
</li>
<li><p><strong>日志记录和恢复</strong>：数据库的日志记录机制（如WAL日志）通常基于表进行管理。将不同表的数据混合在一个页面中，恢复过程会变得更加复杂。</p>
</li>
</ul>
<ul>
<li>空间管理和回收</li>
</ul>
<ul>
<li><p><strong>空间利用</strong>：将同一张表的数据放在同一页面中，可以更有效地利用空间。当需要扩展表时，只需分配新的页面，不需要考虑不同表的数据混合导致的空间浪费问题。</p>
</li>
<li><p><strong>垃圾回收</strong>：当删除数据时，页面中的空闲空间可以更容易地被同一表的新数据使用。如果不同表的数据混合在一起，空间回收和再利用会更加困难。</p>
</li>
</ul>
<ul>
<li>设计和实现的简化</li>
</ul>
<ul>
<li><p><strong>代码复杂度</strong>：将每个页面绑定到一个特定的表，可以简化数据库管理系统的实现。比如，代码中的 <code>Database.getCatalog().getDatabaseFile(pid.getTableId())</code> 就是通过表ID来获取相关的数据库文件（包含多个页面）的。</p>
</li>
<li><p><strong>模块化设计</strong>：这种设计方式使得数据库系统的模块化和维护变得更简单。每个模块（如页面管理、缓冲区管理、事务管理）可以专注于处理单一表的数据。</p>
<p>&#x20;                                                                                                                                —— chatGPT解答</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><blockquote>
<p>实现HeapPageId类、RecordId类、HeapPage类</p>
</blockquote>
<p><img src="image-13.png"></p>
<h3 id="HeapPageId类"><a href="#HeapPageId类" class="headerlink" title="HeapPageId类"></a>HeapPageId类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>page所在的数据表id：<code>private int tableId;</code></p>
</li>
<li><p>page的序号：<code>private int pgNo;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public HeapPageId(int tableId, int pgNo)</code></p>
</li>
<li><p>返回该page所在的数据表id：<code>public int getTableId() </code></p>
</li>
<li><p>返回该page的序号：<code>public int getPageNumber()</code></p>
</li>
<li><p>返回该pageId的哈希值：<code>public int hashCode()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> getPageNumber() * <span class="number">1000</span> + getTableId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判断两个PageId对应的page是否相等：<code>public boolean equals(Object o)</code></p>
<p>相等条件：两个PageId的pageNo和tableId相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> HeapPageId) &#123;</span><br><span class="line">        <span class="type">HeapPageId</span> <span class="variable">other</span> <span class="operator">=</span> (HeapPageId) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPageNumber() == other.getPageNumber() &amp;&amp; <span class="built_in">this</span>.getTableId() == other.getTableId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RecordId类"><a href="#RecordId类" class="headerlink" title="RecordId类"></a>RecordId类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>元组id所在页的pageId：<code>private PageId pid;</code></p>
</li>
<li><p>元组的序号：<code>private int tupleNo;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public RecordId(PageId pid, int tupleno)</code></p>
</li>
<li><p>返回元组的序号：<code>public int getTupleNumber()</code></p>
</li>
<li><p>返回元组所在页的pageId：<code>public PageId getPageId()</code></p>
</li>
<li><p>判断两个tuple是否相同：<code>public boolean equals(Object o)</code></p>
</li>
<li><p>返回 tuple的哈希值：<code>public int hashCode()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.pid.getPageNumber() * <span class="number">100</span> + <span class="built_in">this</span>.pid.getTableId() * <span class="number">10</span> + <span class="built_in">this</span>.tupleNo; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HeapPage类"><a href="#HeapPage类" class="headerlink" title="HeapPage类"></a>HeapPage类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>pageId：<code>private final HeapPageId pid;</code></p>
</li>
<li><p>page所对应表格的tupleDesc：<code>private final TupleDesc td;</code></p>
</li>
<li><p>page中槽slot的bitmap，判断该页的slot是否被占用：<code>final byte[] header;</code></p>
</li>
<li><p>page中的元组：<code>final Tuple[] tuples;</code></p>
</li>
<li><p>page中slot的数量：<code>private final int numSlots;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public HeapPage(HeapPageId id, byte[] data)</code></p>
</li>
<li><p>返回每个page中包含的tuple数量：<code>private int getNumTuples()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNumTuples</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page_bits</span> <span class="operator">=</span> BufferPool.getPageSize() * <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tuple_bits</span> <span class="operator">=</span> (td.getSize() * <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> page_bits / tuple_bits;  <span class="comment">// 进行下取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>数据库中每个page的tuple需要 tuple size*8 bit 的内容大小和 1bit 的header大小。&#x20;</p>
<ul>
<li><p>返回page中的header大小：<code>private int getHeaderSize()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeaderSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) Math.ceil((<span class="type">double</span>) getNumTuples() / <span class="number">8</span>);  <span class="comment">// 进行上取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回pageId：<code>public HeapPageId getId()</code></p>
</li>
<li><p>判断第i个slot槽是否为空：<code>public boolean isSlotUsed(int i)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSlotUsed</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 计算在header中的位置(哪一个字节)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">iTh</span> <span class="operator">=</span> i / <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 计算具体在bitmap中的位置(哪一个比特位，或者理解为header字节位中的比特偏移量)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bitTh</span> <span class="operator">=</span> i % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">onBit</span> <span class="operator">=</span> (header[iTh] &gt;&gt; bitTh) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> onBit == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>header的存储方式是byte数组，每个byte包含8个bit，例如某header的状态如下：{<code>11111111</code>, <code>11111111</code>, <code>00000011</code>}（byte的右侧为低位），此时先通过<code>iTh=i/8</code>变量确定槽i在哪一个byte中，再通过<code>bitTh=i%8</code>确定槽i在byte字节中具体是哪一个bit，最后通过 &amp; 异或确定该bit是0或1。</p>
<ul>
<li>返回page中空slot的数量：<code>public int getNumUnusedSlots()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumUnusedSlots</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回page中所有tuple的迭代器（不包括空slot）：<code>public Iterator&lt;Tuple&gt; iterator()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;Tuple&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    List&lt;Tuple&gt; tupleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSlotUsed(i)) &#123;</span><br><span class="line">            tupleList.add(tuples[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tupleList.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeapPage中的tuple是通过数组存储的，为了访问迭代器方法需要将tuple数组转换成tuple集合。</p>
<h2 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h2><blockquote>
<p>实现HeapFile类</p>
</blockquote>
<p><img src="image-12.png"></p>
<h3 id="HeapFile类"><a href="#HeapFile类" class="headerlink" title="HeapFile类"></a>HeapFile类</h3><p>一个HeapFile就是一张数据表。</p>
<p><img src="image-8.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><p>表中的内容：<code>private final File f;</code></p>
</li>
<li><p>表的属性行：<code>private final TupleDesc td;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public HeapFile(File f, TupleDesc td)</code></p>
</li>
<li><p>返回表的内容：<code>public File getFile()</code></p>
</li>
<li><p>返回标识表文件的唯一id (heapfile绝对路径的哈希值)：<code>public int getId()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> f.getAbsolutePath().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回表的属性行：<code>public TupleDesc getTupleDesc()</code></p>
</li>
<li><p>返回表的page数目：<code>public int numPages()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numPages</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">file_length</span> <span class="operator">=</span> getFile().length();  <span class="comment">// 文件长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> BufferPool.getPageSize();  <span class="comment">// 每个页面的大小</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (file_length / pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从表文件中读取page：<code>public Page readPage(PageId pid)</code></p>
<blockquote>
<p><code>readPage()</code>方法仅会被BufferPool中的<code>getPage()</code>方法调用，再其他地方获取page时也都要调用BufferPool的<code>getPage()</code>方法，这也是BufferPool的意义。</p>
</blockquote>
<p>利用 RandomAccessFile 来读写 HeapFile 中的Page：</p>
<p><code>RandomAccessFile</code> 是 Java 中用于对文件进行读写操作的类，其支持随机访问文件内容的特性。这里的随机 <code>seek()</code> 方法指的是可以通过指定文件中的任意位置（偏移量）来读取或写入数据，而不是像顺序读写那样只能按照文件中数据的顺序逐个访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">readPage</span><span class="params">(PageId pid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tableId</span> <span class="operator">=</span> pid.getTableId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgNo</span> <span class="operator">=</span> pid.getPageNumber();</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> pgNo * BufferPool.getPageSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// randomaccessfile try-catch-finally</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        randomAccessFile = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="comment">// 保证pid页面的结束位置不大于文件randomFile的长度</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) pgNo * BufferPool.getPageSize() &gt; randomAccessFile.length()) &#123;</span><br><span class="line">            randomAccessFile.close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;table %d page %d is invalid&quot;</span>, tableId, pgNo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[BufferPool.getPageSize()];</span><br><span class="line">        <span class="comment">// 移动偏移量到页面的开头</span></span><br><span class="line">        randomAccessFile.seek(offset);</span><br><span class="line">        <span class="comment">// 不要在调用时将整个表加载到内存中，这将导致非常大的表出现内存不足错误</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> randomAccessFile.read(bytes, <span class="number">0</span>, BufferPool.getPageSize());</span><br><span class="line">        <span class="keyword">if</span> (read != BufferPool.getPageSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;table %d page %d read %d bytes not equal to BufferPool.getPageSize()&quot;</span>,</span><br><span class="line">                    tableId, pgNo, read));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeapPageId</span> <span class="variable">heapPageId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(pid.getTableId(), pid.getPageNumber());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapPage</span>(heapPageId, bytes);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (randomAccessFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randomAccessFile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;table %d page %d is invalid&quot;</span>, tableId, pgNo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回表文件中所有heapPage中元组的迭代器：<code>public DbFileIterator iterator(TransactionId tid)</code></p>
<p><img src="image-16.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DbFileIterator <span class="title function_">iterator</span><span class="params">(TransactionId tid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapFileIterator</span>(tid, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapFileIterator</span> <span class="keyword">implements</span> <span class="title class_">DbFileIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionId tid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HeapFile heapFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元组迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Tuple&gt; tupleIterator;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页面索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeapFileIterator</span><span class="params">(TransactionId tid, HeapFile heapFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tid = tid;</span><br><span class="line">        <span class="built_in">this</span>.heapFile = heapFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        tupleIterator = getTupleIterator(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Tuple&gt; <span class="title function_">getTupleIterator</span><span class="params">(<span class="type">int</span> pageNumber)</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageNumber &gt;= <span class="number">0</span> &amp;&amp; pageNumber &lt; heapFile.numPages()) &#123;</span><br><span class="line">            <span class="type">HeapPageId</span> <span class="variable">heapPageId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(heapFile.getId(), pageNumber);</span><br><span class="line">            <span class="type">HeapPage</span> <span class="variable">heapPage</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, heapPageId, Permissions.READ_ONLY);</span><br><span class="line">            <span class="keyword">return</span> heapPage.iterator();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(String.format(<span class="string">&quot;heapFile %d does not exist in page %d&quot;</span>, heapFile.getId(), pageNumber));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tupleIterator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!tupleIterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前页面没有元组，则切换到下一个页面</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; heapFile.numPages()) &#123;</span><br><span class="line">                tupleIterator = getTupleIterator(index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前页面还有元组，则返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tupleIterator == <span class="literal">null</span> || !tupleIterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tupleIterator.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        close();</span><br><span class="line">        open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        tupleIterator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-7.png"></p>
<h2 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h2><blockquote>
<p>实现SeqScan类：该类应该能通过构造方法传入的tableId参数扫描数据表中的所有元组，并使用<code>dbFile.iterator()</code>访问元组</p>
</blockquote>
<h3 id="SeqScan类"><a href="#SeqScan类" class="headerlink" title="SeqScan类"></a>SeqScan类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>事务id：<code>private TransactionId tid;</code></p>
</li>
<li><p>需要扫描的数据表id：<code>private int tableid;</code></p>
</li>
<li><p>表的别名（返回TupleDesc时，要在fieldName前加上tableAlias字段）：<code>private String tableAlias;</code></p>
</li>
<li><p>扫描数据表要访问的dbFile迭代器：<code>private DbFileIterator dbFileIterator;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public SeqScan(TransactionId tid, int tableid, String tableAlias)</code></p>
</li>
<li><p>获取表名：<code>public String getTableName()</code></p>
</li>
<li><p>获取表的alias别名：<code>public String getAlias()</code></p>
</li>
<li><p>查找新的表（重新对tableId赋值）：<code>public void reset(int tableid, String tableAlias)</code></p>
</li>
<li><p>返回数据表的tupleDesc，需要在fieldName之前添加alias别名：<code>public TupleDesc getTupleDesc()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">TupleDesc</span> <span class="variable">td_old</span> <span class="operator">=</span> Database.getCatalog().getTupleDesc(tableid);</span><br><span class="line">    String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[td_old.numFields()];</span><br><span class="line">    Type[] types = <span class="keyword">new</span> <span class="title class_">Type</span>[td_old.numFields()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; td_old.numFields(); i++) &#123;</span><br><span class="line">        names[i] = tableAlias + <span class="string">&quot;.&quot;</span> + td_old.getFieldName(i);</span><br><span class="line">        types[i] = td_old.getFieldType(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(types, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历表用到的方法</p>
<ul>
<li><p>打开迭代器：<code>public void open()</code></p>
</li>
<li><p>如果有更多元组可用，则为True，如果没有元组或未打开迭代器则为False：<code>public boolean hasNext()</code></p>
</li>
<li><p>根据迭代器获取下一个元组：<code>public Tuple next()</code></p>
</li>
<li><p>关闭迭代器（置空）：<code>public void close()</code></p>
</li>
<li><p>将迭代器重置为起始位置（关闭、开启）：<code>public void rewind()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    dbFileIterator = Database.getCatalog().getDatabaseFile(tableid).iterator(tid);</span><br><span class="line">    dbFileIterator.open();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (dbFileIterator == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;The dbFileIterator is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dbFileIterator.hasNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException,</span><br><span class="line">        TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (dbFileIterator == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;The dbFileIterator is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">t</span> <span class="operator">=</span> dbFileIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No more tuples&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    dbFileIterator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    close();</span><br><span class="line">    open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-6.png"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>Test：<code>select * from some_data_file</code></p>
</blockquote>
<p>在项目根目录下创建some_data_file.txt文件：</p>
<p><img src="image-3.png"></p>
<p>用 ant 编译出dist目录下simpleDB的jar包：</p>
<p><img src="image-5.png"></p>
<p>运行测试，展示结果：</p>
<p><img src="image-2.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/2023/07/08/Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Linux的常见命令和Linux中安装jdk、mysql等。</p>
<span id="more"></span>

<h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="文件目录操作命令"><a href="#文件目录操作命令" class="headerlink" title="文件目录操作命令"></a>文件目录操作命令</h3><ul>
<li><p><code>ls</code></p>
<ul>
<li><code>-a</code></li>
<li><code>-l</code></li>
</ul>
</li>
<li><p><code>cd</code></p>
<ul>
<li><code>~</code>：表示用户的home目录</li>
<li><code>.</code>：表示当前所在目录</li>
<li><code>..</code>：表示目前目录位置的上级目录</li>
</ul>
</li>
<li><p><code>cat</code></p>
<ul>
<li><code>-n</code>：显示行号</li>
</ul>
</li>
<li><p><code>more</code>：分页的形式显示文件内容</p>
<ul>
<li><code>回车键</code>：向下滚动一行</li>
<li><code>空格键</code>：向下滚动一屏</li>
<li><code>b</code>：返回上一屏</li>
<li><code>q或者Ctrl+C</code>：退出more</li>
</ul>
</li>
<li><p><code>tail</code>：查看文件末尾的内容</p>
<ul>
<li><code>-f</code>：动态读取文件末尾内容并显示，常用于日志文件的内容输出</li>
</ul>
</li>
<li><p><code>mkdir</code>：创建目录</p>
<ul>
<li><code>-p</code>：可以实现多级目录的同时创建（<code>mkdir 1/2/3</code>）</li>
</ul>
</li>
<li><p><code>rmdir</code>：删除空目录</p>
</li>
</ul>
<h3 id="拷贝移动命令"><a href="#拷贝移动命令" class="headerlink" title="拷贝移动命令"></a>拷贝移动命令</h3><ul>
<li><p><code>cp</code>：用来复制文件或目录（<code>cp [-r] source dest</code>）</p>
<ul>
<li><code>-r</code>：复制该目录下的所有子目录和文件</li>
</ul>
</li>
<li><p><code>mv</code>：为文件或目录改名，或移动到其他位置（<code>mv source dest</code>）</p>
</li>
</ul>
<h3 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h3><ul>
<li><p><code>tar</code>：对文件进行打包、解包、压缩、解压</p>
<blockquote>
<p>包文件后缀名<code>.tar</code>，表示只是完成了打包，并没有压缩；包文件后缀名<code>.tar.gz</code>表示打包的同时还进行了压缩。</p>
</blockquote>
<ul>
<li><code>-z</code>：代表是gzip，gzip可以对文件压缩或解压；</li>
<li><code>-c</code>：代表是create，创建新的包文件；</li>
<li><code>-x</code>：代表是extract，实现从包文件中还原文件；</li>
<li><code>-v</code>：代表是verbose，显示命令的执行操作；</li>
<li><code>-f</code>：代表是file，用于指定包文件的名称。</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf fileName  # 打包tar文件</span><br><span class="line">tar -xvf fileName  # 解包tar文件</span><br><span class="line">tar -zcvf fileName  # 打包并压缩tar.gz文件</span><br><span class="line">tar -zxvf fileName  # 打包并解压tar.gz文件</span><br></pre></td></tr></table></figure>

<h3 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h3><ul>
<li><p><code>vi</code>/<code>vim</code></p>
<blockquote>
<p><code>vim</code>安装：<code>yum install yum</code></p>
</blockquote>
<ul>
<li>命令模式<ul>
<li><code>G</code></li>
<li><code>gg</code></li>
</ul>
</li>
<li>插入模式</li>
<li>底行模式：<ul>
<li><code>wq</code></li>
<li><code>q!</code></li>
<li><code>set nu</code>：显示行号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><ul>
<li><p><code>find</code>：在指定目录下查找文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find dirName -name fileName</span><br></pre></td></tr></table></figure></li>
<li><p><code>grep</code>：从指定文件查找指定文本内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep word fileName</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="远程服务器上传下载"><a href="#远程服务器上传下载" class="headerlink" title="远程服务器上传下载"></a>远程服务器上传下载</h2><ul>
<li><p>本地向服务器上传</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /localpath/filename（本地目录文件） username@IP_Address:/remotepath（远程目录）</span><br><span class="line">scp -r /localpath（本地目录） username@IP_Address:/remotepath（远程目录）</span><br></pre></td></tr></table></figure></li>
<li><p>本地从服务器下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp username@IP_Address:/remotepath/filename（远程目录文件） /localpath（本地目录）</span><br><span class="line">scp -r username@IP_Address:/remotepath（远程目录） /localpath（本地目录）</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>远程服务器设置固定的ip地址：<a href="https://www.cnblogs.com/itbsl/p/10998696.html">https://www.cnblogs.com/itbsl/p/10998696.html</a></p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux中安装jdk"><a href="#Linux中安装jdk" class="headerlink" title="Linux中安装jdk"></a>Linux中安装jdk</h3><p>建议安装jdk8，jdk17亲测在CentOS中和tomcat不兼容，tomcat安装时无法识别jdk17（我看网上的博主在23年还在linux中使用jdk8的版本，可能CentOS7真的和jdk17有一些兼容上的问题）。</p>
<p>下载jdk8地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>其中别忘记环境变量的配置：</p>
<ul>
<li><p>使用vim修改<code>/etc/profile</code>文件，在文件末尾加入配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_371</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li>
<li><p>重新加载profile文件，使得配置立即生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li>
</ul>
<p>检查jdk是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h3 id="Linux中安装Tomcat"><a href="#Linux中安装Tomcat" class="headerlink" title="Linux中安装Tomcat"></a>Linux中安装Tomcat</h3><p>我使用的是Tomcat9版本。</p>
<p>在Tomcat的<code>/bin</code>目录下启动tomcat服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh startup.sh 或者 ./startup.sh</span><br></pre></td></tr></table></figure>

<p>查看进程检查是否启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure>

<p>通过客户机浏览器可以试着访问服务器的8080端口：</p>
<img src="image-20230710181303092.png" alt="image-20230710181303092" style="zoom:67%;" />

<p>如果无法访问大概率是防火墙关闭了服务器的8080端口，尝试开放8080端口后尝试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent  # 开放指定端口</span><br><span class="line">firewall-cmd --zone=public --remove-port=8080/tcp --permanent  # 开放指定端口</span><br><span class="line">firewall-cmd --reload  # 立即生效配置</span><br><span class="line">filewall-cmd --zone=public --list-ports  # 查看开放的端口</span><br></pre></td></tr></table></figure>

<p>停止Tomcat服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法一</span></span><br><span class="line">./shutdown.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法二</span></span><br><span class="line">kill -9 进程id</span><br></pre></td></tr></table></figure>

<h3 id="Linux中安装MySQL"><a href="#Linux中安装MySQL" class="headerlink" title="Linux中安装MySQL"></a>Linux中安装MySQL</h3><p>CentOS7中自带的 Mariadb 和 MySQL 有冲突，先将其卸载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br><span class="line">sudo rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64  # mariadb-libs-5.5.68-1.el7.x86_64是上面命令显示的</span><br><span class="line">sudo rm /etc/my.cnf</span><br></pre></td></tr></table></figure>

<p>检查MySQL是否存在，如果存在也卸载重新安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<p>下载MySQL地址：<a href="https://downloads.mysql.com/archives/community/?spm=a2c6h.12873639.article-detail.5.51fa3861DJz2jH">https://downloads.mysql.com/archives/community/?spm=a2c6h.12873639.article-detail.5.51fa3861DJz2jH</a></p>
<p><img src="image-20230708173316683.png" alt="image-20230708173316683"></p>
<p>将<code>mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar</code>上传至服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /localpath/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar username@IP_Address:/remotepath/mysql</span><br></pre></td></tr></table></figure>

<p>将tar解压到指定目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf /home/ljc/mysql/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar -C /usr/local/mysql</span><br></pre></td></tr></table></figure>

<p><img src="image-20230708174332889.png" alt="image-20230708174332889"></p>
<p>不考虑依赖关系的强制安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh *.rpm --nodeps --force</span><br></pre></td></tr></table></figure>

<p><img src="image-20230708175727311.png" alt="image-20230708175727311"></p>
<p>安装成功后，启动MySQL服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p>进入MySQL：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>MySQL的默认临时密码在安装时的日志文件中，复制过来登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p><img src="image-20230708175930124.png" alt="image-20230708175930124"></p>
<p>降低密码的校验等级和校验规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password.policy=0;</span><br><span class="line">set global validate_password.length=8;</span><br></pre></td></tr></table></figure>

<p>重新设置MySQL密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure>

<p><code>localhost</code>只能用户本机127.0.0.1访问，创建一个新<code>root</code>用户用于远程登录访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;12345678&#x27;;</span><br></pre></td></tr></table></figure>

<p>给新<code>root</code>用户分配权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>在NaviCat上远程连接服务器上的MySQL：</p>
<img src="image-20230708181224067.png" alt="image-20230708181224067" style="zoom:67%;" />

<p>这里如果连接失败是CentOS防火墙没有开启3306端口，建议关闭防火墙。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<p><img src="image-20230708181402460.png" alt="image-20230708181402460"></p>
<p>关闭防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<p><img src="image-20230708181459858.png" alt="image-20230708181459858"></p>
<p>永久关闭防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6-5830-Lab2</title>
    <url>/2024/08/15/MIT6-5830-Lab2/</url>
    <content><![CDATA[<p>MIT6.5830 的数据库课程。Lab2 主要是完成查询的连接和过滤、实现聚合下的查询操作、对表的插入删除以及实现数据库中非常重要的 LRU 页面置换算法。</p>
<span id="more"></span>

<h2 id="任务目录"><a href="#任务目录" class="headerlink" title="任务目录"></a>任务目录</h2><ul>
<li><p><input checked="" disabled="" type="checkbox">  Exercise1：实现查询的连接和过滤</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise2：实现聚合操作MIN、MAX、COUNT、SUM、AVG</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise3：实现修改表的方法，完成添加和删除</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise4：实现Insert和Delete操作符</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise5：实现BufferPool的页面置换算法</p>
</li>
</ul>
<h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><blockquote>
<p>实现Predicate、JoinPredicate、Filter、Join</p>
</blockquote>
<h3 id="Predicate类"><a href="#Predicate类" class="headerlink" title="Predicate类"></a>Predicate类</h3><p>Filter的辅助类，用于筛选满足条件的tuple：将tuple中的字段与<strong>指定字段</strong>进行比较，实现对单个tuple的过滤操作（比较逻辑有==、&gt;=、&lt;=、&gt;、&lt;、!=、LIKE等）。</p>
<p><img src="image-17.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><p>指定的比较字段(也是<code>Field.compare()</code>的参数)：<code>private Field operand;</code></p>
</li>
<li><p>tuple中指定字段对应字段的索引：<code>private int fieldIndex;</code></p>
</li>
<li><p>执行的比较逻辑，运算操作符(也是<code>Field.compare()</code>的参数)：<code>private Op op;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Predicate(int field, Op op, Field operand)</code></p>
</li>
<li><p>返回tuple中对应字段的索引：<code>public int getField()</code></p>
</li>
<li><p>返回运算操作符：<code>public Op getOp()</code></p>
</li>
<li><p>返回指定的比较字段：<code>public Field getOperand()</code></p>
</li>
<li><p>对元组t进行比较：<code>public boolean filter(Tuple t)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">otherOperand</span> <span class="operator">=</span> t.getField(fieldIndex);</span><br><span class="line">    <span class="keyword">return</span> otherOperand.compare(op, operand);  <span class="comment">// 例如: otherOperand &gt;= operand</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>IntField和StringField分别实现了Field接口中的<code>compare(op, operand)</code>方法。</p>
<ul>
<li>返回展示结果：<code>public String toString()</code></li>
</ul>
<h3 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h3><p>Filter类实现了Operator接口，根据Predicate的判断结果，得到满足结果的tuples，实现了类似于<code>where age &gt; 16</code>的过滤操作。</p>
<p><img src="image-14.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><p>通过Predicate成员变量，实现对每一个tuple的过滤操作：<code>private Predicate predicate;</code></p>
</li>
<li><p>待过滤的tuples迭代器，处理输入的元组流，并产生输出的元组流(在 Filter 的上下文中，通常只有一个子操作符)：<code>private OpIterator[] children;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Filter(Predicate p, OpIterator child)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Filter</span><span class="params">(Predicate p, OpIterator child)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.predicate = p;</span><br><span class="line">    <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">OpIterator</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">this</span>.children[<span class="number">0</span>] = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回谓词predicate：<code>public Predicate getPredicate()</code></p>
</li>
<li><p>返回待过滤的tuple属性：<code>public TupleDesc getTupleDesc()</code></p>
</li>
<li><p>开启过滤迭代器：<code>public void open()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">super</span>.open(); </span><br><span class="line">    children[<span class="number">0</span>].open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Filter是操作符Operator的子类，需要执行<code>super.open()</code>方法。</p>
<ul>
<li><p>关闭过滤迭代器：<code>public void close()</code></p>
</li>
<li><p>每次调用时，返回过滤后的下一个tuple：<code>protected Tuple fetchNext()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException,</span><br><span class="line">        TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">while</span> (children[<span class="number">0</span>].hasNext()) &#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> children[<span class="number">0</span>].next();</span><br><span class="line">        <span class="comment">// predicate封装了过滤条件，包括要比较的字段、比较操作符（如等于、大于等）和比较值</span></span><br><span class="line">        <span class="keyword">if</span> (predicate.filter(tuple)) &#123;</span><br><span class="line">            <span class="keyword">return</span> tuple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回待过滤的tuples迭代器：<code>public OpIterator[] getChildren()</code></p>
</li>
<li><p>设置待过滤的tuples迭代器：<code>public void setChildren(OpIterator[] children)</code></p>
</li>
</ul>
<h3 id="JoinPredicate类"><a href="#JoinPredicate类" class="headerlink" title="JoinPredicate类"></a>JoinPredicate类</h3><p>Join的辅助类，与Predicate类似，实现连接的条件，对两个tuple中的某一字段进行比较(类似<code>where t1.age = t2.age</code>)。</p>
<p><img src="image-9.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><p>tuple1进行比较的字段索引：<code>private int fieldIndex1;</code></p>
</li>
<li><p>tuple2进行比较的字段索引：<code>private int fieldIndex2;</code></p>
</li>
<li><p>执行的比较逻辑：<code>private Predicate.Op op;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public JoinPredicate(int field1, Predicate.Op op, int field2)</code></p>
</li>
<li><p>返回tuple1的字段索引：<code>public int getField1()</code></p>
</li>
<li><p>返回tuple2的字段索引：<code>public int getField2()</code></p>
</li>
<li><p>返回比较逻辑符：<code>public Predicate.Op getOperator()</code></p>
</li>
<li><p>对tuple1的字段和tuple2的字段进行比较：<code>public boolean filter(Tuple t1, Tuple t2)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t1, Tuple t2)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> t1.getField(fieldIndex1);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> t2.getField(fieldIndex2);</span><br><span class="line">    <span class="keyword">return</span> field1.compare(op, field2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Join类"><a href="#Join类" class="headerlink" title="Join类"></a>Join类</h3><p>和Filter类一样都实现了Operator接口，实现连接操作——对于给定两组tuple中满足JoinPredicate操作的两个tuple进行连接，连接方式采取最简单的<strong>嵌套循环连接</strong>。</p>
<p><img src="image-16.png"></p>
<p><strong>参数：</strong></p>
<ul>
<li><p>通过JoinPredicate成员变量，实现对两个tuple的连接操作：<code>private JoinPredicate joinPredicate;</code></p>
</li>
<li><p>用于连接的tuples迭代器：<code>private OpIterator[] children;</code></p>
<ul>
<li><p><em>Left Tuples迭代器: <code>children[0]</code></em></p>
</li>
<li><p><em>Right Tuples迭代器: <code>children[1]</code></em></p>
</li>
</ul>
</li>
<li><p><code>fetchNext()</code>方法每次用嵌套循环选择children[0]中的一个tuple1和children[1]中一个符合条件的tuple2进行连接，记录当前children[0]中的tuple：<code>private Tuple curTuple;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Join(JoinPredicate p, OpIterator child1, OpIterator child2)</code></p>
</li>
<li><p>返回joinPredicate：<code>public JoinPredicate getJoinPredicate()</code></p>
</li>
<li><p>返回children[0]（左）中进行比较的字段名：<code>public String getJoinField1Name()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getJoinField1Name</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> children[<span class="number">0</span>].getTupleDesc().getFieldName(joinPredicate.getField1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回children[1]（右）中进行比较的字段名：<code>public String getJoinField2Name()</code></p>
</li>
<li><p>返回连接后tuple的字段属性，即新表的tupleDesc：<code>public TupleDesc getTupleDesc()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> TupleDesc.merge(children[<span class="number">0</span>].getTupleDesc(), children[<span class="number">1</span>].getTupleDesc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>调用TupleDesc类的merge操作完成两个tupleDesc的合并。</p>
<ul>
<li><p>迭代器相关开启、关闭、重启</p>
<ul>
<li><p><code>public void open()</code></p>
</li>
<li><p><code>public void close()</code></p>
</li>
<li><p><code>public void rewind()</code></p>
</li>
</ul>
</li>
<li><p>返回连接生成的下一个结果：<code>protected Tuple fetchNext()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">while</span> (children[<span class="number">0</span>].hasNext() || curTuple != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curTuple == <span class="literal">null</span>)</span><br><span class="line">            curTuple = children[<span class="number">0</span>].next();</span><br><span class="line">        Tuple rightTuple;</span><br><span class="line">        <span class="keyword">while</span>(children[<span class="number">1</span>].hasNext()) &#123;</span><br><span class="line">            rightTuple = children[<span class="number">1</span>].next();</span><br><span class="line">            <span class="keyword">if</span> (joinPredicate.filter(curTuple, rightTuple)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> curTuple.getTupleDesc().numFields();</span><br><span class="line">                <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> rightTuple.getTupleDesc().numFields();</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">combiTuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(getTupleDesc());</span><br><span class="line">                <span class="comment">// join后的元组字段数等于左右两个元组字段数之和</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">                    combiTuple.setField(i, curTuple.getField(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">                    combiTuple.setField(i + len1, rightTuple.getField(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> combiTuple;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curTuple = <span class="literal">null</span>;</span><br><span class="line">        children[<span class="number">1</span>].rewind();  <span class="comment">// 重置右侧子操作符的迭代器到初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>采用嵌套循环的连接方式，即两个for循环遍历比较每一对元组：先获取<code>children[0]</code>中的一个tuple赋值给<code>curTuple</code>，令<code>curTuple</code>依次与<code>children[1]</code>中的所有tuples进行比较，<code>curTuple</code>与满足连接条件的tuple2进行连接并返回连接后的tuple，当完成<code>children[1]</code>的一次遍历后，<code>curTuple=children[0].next()</code> +<code>children[1].rewind()</code>。</p>
<ul>
<li><p>返回用于连接的tuples迭代器：<code>public OpIterator[] getChildren()</code></p>
</li>
<li><p>设置用于连接的tuples迭代器：<code>public void setChildren(OpIterator[] children)</code></p>
</li>
</ul>
<p><img src="image-13.png"></p>
<h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><blockquote>
<p>实现IntegerAggregator、StringAggregator、Aggregate类，实现5种SQL聚合(COUNT、SUM、AVG、MIN、MAX)，同时支持分组。</p>
</blockquote>
<h3 id="IntegerAggerator类"><a href="#IntegerAggerator类" class="headerlink" title="IntegerAggerator类"></a>IntegerAggerator类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>无分组默认StringField字段：<code>private static final Field </code><em><code>NO_GROUP_FIELD </code></em><code>= new StringField(&quot;NO_GROUP_FIELD&quot;, 20);</code></p>
</li>
<li><p>分组字段的索引：<code>private int groupByIndex;</code></p>
</li>
<li><p>分组字段的类型（目前只有int和String）：<code>private Type groupByType;</code></p>
</li>
<li><p>聚合字段的索引：<code>private int aggregateIndex;</code></p>
</li>
<li><p>进行的聚合操作（5种SQL聚合操作）：<code>private Op aggOp;</code></p>
</li>
<li><p>分组计算的map结果集</p>
<ul>
<li>分组的结果（key–分组的字段，value–封装的结果类对象）：<code>private Map&lt;Field, GroupCalResult&gt; groupCalMap;</code></li>
</ul>
<blockquote>
<p>辅助类GroupCalResult：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GroupCalResult</span> &#123;</span><br><span class="line">    <span class="comment">// 根据不同的聚合操作，可能不会同时用到result和count，当聚合操作不使用该成员时设置默认值-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DEFAULT_RES</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">Deactivate_RES</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// result成员变量无效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DEFAULT_COUNT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">Deactivate_COUNT</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// count成员变量无效</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前分组计算的结果: sum, avg, max, min, count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Field出现的频率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupCalResult</span><span class="params">(<span class="type">int</span> result , <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>封装分组聚合的结果集，方便迭代器遍历查看结果（key–分组的字段，value–聚合元组tuple）：<code>private Map&lt;Field, Tuple&gt; resultMap;</code></li>
</ul>
</li>
<li><p>聚合后tuple的tupleDesc：<code>private TupleDesc aggDesc;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public IntegerAggregator(int gbfield, Type gbfieldtype, int afield, Op what)</code></p>
<p>根据是否有group分组确定聚合后的表字段属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntegerAggregator</span><span class="params">(<span class="type">int</span> gbfield, Type gbfieldtype, <span class="type">int</span> afield, Op what)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.groupByIndex = gbfield;</span><br><span class="line">    <span class="built_in">this</span>.groupByType = gbfieldtype;</span><br><span class="line">    <span class="built_in">this</span>.aggregateIndex = afield;</span><br><span class="line">    <span class="built_in">this</span>.aggOp = what;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init map</span></span><br><span class="line">    <span class="built_in">this</span>.groupCalMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.resultMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (groupByIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 有groupBy</span></span><br><span class="line">        <span class="built_in">this</span>.aggDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;groupByType, Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;groupVal&quot;</span>, <span class="string">&quot;aggregateVal&quot;</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无groupBy</span></span><br><span class="line">        <span class="built_in">this</span>.aggDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aggregateVal&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分组聚合操作的执行方法：<code>public void mergeTupleIntoGroup(Tuple tup)</code></p>
<p>聚合操作的流程是：先读取一个tuple进行聚合操作，得到一个只聚合了一个tuple的聚合结果，之后每读取一个tuple就将其加入到聚合结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">groupByField</span> <span class="operator">=</span> <span class="built_in">this</span>.groupByIndex == NO_GROUPING ? NO_GROUP_FIELD : tup.getField(groupByIndex);</span><br><span class="line">    <span class="comment">// 分组字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span>(!NO_GROUP_FIELD.equals(groupByField) &amp;&amp; groupByField.getType() != groupByType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected groupByType: 「&quot;</span> + groupByType + <span class="string">&quot;」, but got: &quot;</span> + groupByField.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 聚合字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span>(!(tup.getField(aggregateIndex) <span class="keyword">instanceof</span> IntField)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected aggType is 「IntField」, but got: &quot;</span> + tup.getField(aggregateIndex).getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、store</span></span><br><span class="line">    groupStore(tup, groupByField);</span><br><span class="line">    <span class="comment">// 2、cal</span></span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">curCalTuple</span> <span class="operator">=</span> calResult(groupByField);</span><br><span class="line">    <span class="comment">// 3、update</span></span><br><span class="line">    resultMap.put(groupByField, curCalTuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>分组聚合核心算法：根据不同的聚合操作，GroupCalResult(result, count)封装了分组聚合的结果。例如<code>MIN</code>操作，GroupCalResult的count成员是无效的，故将其置为*<code>Deactivate_COUNT</code>。*</p>
<p>计算聚合后的结果，如果存在分组则结果字段属性为“分组字段+结果”，若不存在分组则结果字段属性为“结果”。</p>
<ul>
<li><p>返回聚合结果的迭代器：<code>public OpIterator iterator()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OpIterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntAggTupIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>聚合结果的迭代器辅助类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">IntAggTupIterator</span> <span class="keyword">implements</span> <span class="title class_">OpIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">open</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Map.Entry&lt;Field, Tuple&gt;&gt; iter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        iter = resultMap.entrySet().iterator();</span><br><span class="line">        open = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        open = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> open &amp;&amp; iter.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iter.next().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.close();</span><br><span class="line">        <span class="built_in">this</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aggDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-6.png"></p>
<h3 id="StringAggerator类"><a href="#StringAggerator类" class="headerlink" title="StringAggerator类"></a>StringAggerator类</h3><p>对String类型的字段实现分组聚合操作，思路和IntegerAggerator一致，不过对于String类型来说只需要实现<code>COUNT</code>聚合操作。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>无分组默认StringField字段：<code>private static final Field </code><em><code>NO_GROUP_FIELD </code></em><code>= new StringField(&quot;NO_GROUP_FIELD&quot;, 20);</code></p>
</li>
<li><p>分组字段的索引：<code>private int groupByIndex;</code></p>
</li>
<li><p>分组字段的类型：<code>private Type groupByType;</code></p>
</li>
<li><p>聚合字段的索引：<code>private int aggregateIndex;</code></p>
</li>
<li><p>聚合结果的字段属性：<code>private TupleDesc aggDesc;</code></p>
</li>
<li><p>分组计算的map结果集：</p>
<ul>
<li><p>分组的结果：<code>private Map&lt;Field, Integer&gt; groupCalMap;</code></p>
<p>因为只有<code>COUNT</code>聚合操作符，所以不需要使用GroupCalResult辅助类来区分result和count，value直接使用Integer类型即可。</p>
</li>
<li><p>private Map&lt;Field, Tuple&gt; resultMap;</p>
</li>
</ul>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public StringAggregator(int gbfield, Type gbfieldtype, int afield, Op what)</code></p>
</li>
<li><p>分组聚合操作的执行方法：<code>public void mergeTupleIntoGroup(Tuple tup)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">groupField</span> <span class="operator">=</span> groupByIndex &gt;= <span class="number">0</span> ? tup.getField(groupByIndex) : NO_GROUP_FIELD;</span><br><span class="line">    <span class="comment">// 分组字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!NO_GROUP_FIELD.equals(groupField) &amp;&amp; groupField.getType() != groupByType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected groupByType: 「&quot;</span> + groupByType + <span class="string">&quot;」, but got: &quot;</span> + groupField.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 聚合字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!(tup.getField(aggregateIndex) <span class="keyword">instanceof</span> StringField)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected aggregateType: 「&quot;</span> + Type.STRING_TYPE + <span class="string">&quot;」, but got: &quot;</span> + tup.getField(aggregateIndex).getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、store</span></span><br><span class="line">    groupCalMap.put(groupField, <span class="built_in">this</span>.groupCalMap.getOrDefault(groupField, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2、cal</span></span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">curCalTuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(aggDesc);</span><br><span class="line">    <span class="keyword">if</span> (groupByIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        curCalTuple.setField(<span class="number">0</span>, groupField);</span><br><span class="line">        curCalTuple.setField(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(groupCalMap.get(groupField)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curCalTuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(groupCalMap.get(groupField)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、update</span></span><br><span class="line">    resultMap.put(groupField, curCalTuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回聚合结果的迭代器：<code>public OpIterator iterator()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OpIterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringAggTupIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>聚合结果的迭代器辅助类（同IntegerAggerator）</p>
</blockquote>
</li>
</ul>
<p><img src="image-7.png"></p>
<h3 id="Aggerator类"><a href="#Aggerator类" class="headerlink" title="Aggerator类"></a>Aggerator类</h3><p>对IntegerAggerator、StringAggerator类进行封装。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>需要聚合的tuples迭代器：<code>OpIterator[] children;</code></p>
</li>
<li><p>聚合字段的索引：<code>private int aggregateIndex;</code></p>
</li>
<li><p>分组字段的索引：<code>private int groupByIndex;</code></p>
</li>
<li><p>聚合操作（5种SQL聚合操作）：<code>private Op aggregateOp;</code></p>
</li>
<li><p>进行聚合操作的类（IntegerAggregator或StringAggregator）：<code>private Aggregator aggregator;</code></p>
</li>
<li><p>存放聚合结果的迭代器：<code>private OpIterator resultIterator;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Aggregate(OpIterator child, int afield, int gfield, Aggregator.Op aop)</code></p>
<p>注意为aggregator聚合操作赋值，判断是IntAggregate还是StringAggregate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Aggregate</span><span class="params">(OpIterator child, <span class="type">int</span> afield, <span class="type">int</span> gfield, Aggregator.Op aop)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">OpIterator</span>[] &#123;child&#125;;</span><br><span class="line">    <span class="built_in">this</span>.aggregateIndex = afield;</span><br><span class="line">    <span class="built_in">this</span>.groupByIndex = gfield;</span><br><span class="line">    <span class="built_in">this</span>.aggregateOp = aop;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">groupType</span> <span class="operator">=</span> gfield != Aggregator.NO_GROUPING ? child.getTupleDesc().getFieldType(gfield) : Type.STRING_TYPE;  <span class="comment">// 如果没有分组字段，则默认为字符串类型</span></span><br><span class="line">    <span class="keyword">if</span> (child.getTupleDesc().getFieldType(afield) == Type.INT_TYPE) &#123;</span><br><span class="line">        <span class="built_in">this</span>.aggregator = <span class="keyword">new</span> <span class="title class_">IntegerAggregator</span>(gfield, groupType, afield, aop);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aggregator = <span class="keyword">new</span> <span class="title class_">StringAggregator</span>(gfield, groupType, afield, aop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回分组的字段索引：<code>public int groupField()</code></p>
</li>
<li><p>返回分组的字段名：<code>public String groupFieldName()</code></p>
</li>
<li><p>返回聚合的字段索引：<code>public int aggregateField()</code></p>
</li>
<li><p>返回聚合的字段名：<code>public String aggregateFieldName()</code></p>
</li>
<li><p>返回聚合操作符：<code>public Aggregator.Op aggregateOp()</code></p>
</li>
<li><p>迭代器相关</p>
<ul>
<li><p>聚合操作的核心逻辑代码：<code>public void open()</code></p>
<p>将IntAggerator和StringAggerator聚合结果封装在resultIterator迭代器中。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException, DbException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">super</span>.open();</span><br><span class="line">    children[<span class="number">0</span>].open();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.children[<span class="number">0</span>].hasNext()) &#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">nextTuple</span> <span class="operator">=</span> children[<span class="number">0</span>].next();</span><br><span class="line">        aggregator.mergeTupleIntoGroup(nextTuple);  <span class="comment">// 逐行进行聚合操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    resultIterator = aggregator.iterator();</span><br><span class="line">    resultIterator.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>protected Tuple fetchNext()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (resultIterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> resultIterator.next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>public void close()</code></p>
</li>
<li><p><code>public void rewind()</code></p>
</li>
</ul>
</li>
<li><p>获取聚合结果的字段属性（<del>不是原tuples迭代器的字段属性</del>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> aggregator.iterator().getTupleDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-12.png"></p>
<p><img src="image-11.png"></p>
<h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><blockquote>
<p>实现HeapPage、HeapFile、BufferPool中的insertTuple、deleteTuple</p>
</blockquote>
<p>要实现对数据表数据的增添和删除，先从文件和物理页的层次开始。</p>
<p>Removing Tuples：要移除一个Tuple需要实现deleteTuple，Tuple包含RecordID能够帮助找到tuple存储的物理页，所以思路就是通过RecordID找到对应的物理页，并修改物理页的header。</p>
<p>Adding Tuples：对于文件层面，insertTuple方法负责添加一个tuple到HeapFile中，大致思路是：到页中找一个空闲的slot；如果HeapFile不存在这样的页就需要新建一个页，并添加新页到磁盘上。同时还要保证新添tuple的RecordID正确更新。</p>
<p><strong>在insert和delete中BufferPool、HeapFile、HeapPage的作用：</strong></p>
<p><img src="image-10.png"></p>
<p>对于BufferPool和HeapFile来说，是相互调用的关系：HeapFile调用BufferPool的getPage方法获取数据页：在页面存在于BufferPool中时直接从BufferPool获取；不存在时还需调用HeapFile的readPage方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="keyword">if</span>(!bufferPools.containsKey(pid)) &#123;</span><br><span class="line">        <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> file.readPage(pid);  <span class="comment">// 调用HeapFile的readPage方法</span></span><br><span class="line">        bufferPools.put(pid, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bufferPools.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HeapPage类"><a href="#HeapPage类" class="headerlink" title="HeapPage类"></a>HeapPage类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>脏页标志位：<code>private boolean dirtyFlag;</code></p>
</li>
<li><p>产生脏页的事务id：<code>private TransactionId dirtyTid;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>选择一个空slot插入tuple，同时修改该slot对应header的bitmap，表示该slot已被数据占用：<code>public void insertTuple(Tuple t)</code></p>
<p>插入数据的三个要点：① 设置slot的bitmap； ② 设置tuple在磁盘的位置recordID； ③ 向页面中插入真实数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">if</span> (getNumUnusedSlots() == <span class="number">0</span> || !t.getTupleDesc().equals(td)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;page is full or tupleDesc is mismatch.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">            markSlotUsed(i, <span class="literal">true</span>);  <span class="comment">// 设置slot的bitmap</span></span><br><span class="line">            t.setRecordId(<span class="keyword">new</span> <span class="title class_">RecordId</span>(pid, i));  <span class="comment">// 设置recordID</span></span><br><span class="line">            tuples[i] = t;  <span class="comment">// 向页面插入数据</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除指定的tuple，同时修改slot对应的bitmap，表示该slot已为空：<code>public void deleteTuple(Tuple t)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tid</span> <span class="operator">=</span> t.getRecordId().getTupleNumber();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tuples.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.equals(tuples[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;tuple slot is already empty&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            markSlotUsed(i, <span class="literal">false</span>);</span><br><span class="line">            tuples[tid] = <span class="literal">null</span>;  <span class="comment">// delete</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;the tuple is not on this page&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改脏页标志位：<code>public void markDirty()</code></p>
</li>
<li><p>如果该page是脏页则返回产生脏页的事务id：<code>public TransactionId isDirty()</code></p>
</li>
<li><p>修改page中的header，value为true表示在第i位设置为1，value为false表示在第i位设置为0：<code>private void markSlotUsed(int i, boolean value)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">markSlotUsed</span><span class="params">(<span class="type">int</span> i, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">iTh</span> <span class="operator">=</span> i / <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bitTh</span> <span class="operator">=</span> i % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">onBit</span> <span class="operator">=</span> (header[iTh] &gt;&gt; bitTh) &amp; <span class="number">1</span>;  <span class="comment">// 判断该slot位是否被使用</span></span><br><span class="line">    <span class="keyword">if</span> (onBit == <span class="number">0</span> &amp;&amp; value) &#123;</span><br><span class="line">        <span class="comment">// 未使用，现在使用</span></span><br><span class="line">        header[iTh] += (<span class="type">byte</span>) (<span class="number">1</span> &lt;&lt; bitTh);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onBit == <span class="number">1</span> &amp;&amp; !value) &#123;</span><br><span class="line">        <span class="comment">// 已使用，现在未使用</span></span><br><span class="line">        header[iTh] -= (<span class="type">byte</span>) (<span class="number">1</span> &lt;&lt; bitTh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-5.png"></p>
<h3 id="HeapFile类"><a href="#HeapFile类" class="headerlink" title="HeapFile类"></a>HeapFile类</h3><p><strong>方法：</strong></p>
<ul>
<li><p>将page写入磁盘，同时清除脏页标志：<code>public void writePage(Page page)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writePage</span><span class="params">(Page page)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">PageId</span> <span class="variable">pageId</span> <span class="operator">=</span> page.getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageId.getPageNumber();</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> pageNo * BufferPool.getPageSize();</span><br><span class="line">    <span class="type">byte</span>[] pageData = page.getPageData();</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    file.seek(offset);</span><br><span class="line">    file.write(pageData);</span><br><span class="line">    file.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除脏页</span></span><br><span class="line">    page.markDirty(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将tuple插入到HeapFile的page中，如果HeapFile的page都满了还要在HeapFile中创建一个新的page：<code>public List&lt;Page&gt; insertTuple(TransactionId tid, Tuple t)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Page&gt; <span class="title function_">insertTuple</span><span class="params">(TransactionId tid, Tuple t)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    ArrayList&lt;Page&gt; pageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numPages(); i++) &#123;</span><br><span class="line">        <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(getId(), i),</span><br><span class="line">                Permissions.READ_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (p.getNumUnusedSlots() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前页面没有空闲槽位</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.insertTuple(t);  <span class="comment">// 调用HeapPage的insertTuple方法</span></span><br><span class="line">        pageList.add(p);</span><br><span class="line">        <span class="keyword">return</span> pageList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到合适的页面，需要创建新的页面</span></span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f, <span class="literal">true</span>));</span><br><span class="line">    <span class="type">byte</span>[] emptyData = HeapPage.createEmptyPageData();</span><br><span class="line">    bos.write(emptyData);</span><br><span class="line">    bos.close();</span><br><span class="line">    <span class="comment">// 加载入BufferPool</span></span><br><span class="line">    <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(getId(), numPages()-<span class="number">1</span>),</span><br><span class="line">            Permissions.READ_WRITE);  <span class="comment">// pgNo: numPages()方法的返回值是基于文件当前的大小动态计算的</span></span><br><span class="line">    p.insertTuple(t);</span><br><span class="line">    pageList.add(p);</span><br><span class="line">    <span class="keyword">return</span> pageList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建新page时将<code>pageNo</code>设置为<code>numPages()-1</code>而不是<code>numPages()</code>是因为<code>numPages()</code>方法的返回值是基于文件当前的大小动态计算的，默认新page的pageNo是最后一个。</p>
<blockquote>
<p>BufferedInputStream和BufferedOutputStream类就是实现缓冲功能的输入/输出流，使用带缓冲的输入/输出流，效率更高、速度更快。</p>
<p>使用步骤：①创建FileOutputStream对象，构造方法中绑定要输出的目标文件； ②创建BufferOutputStream对象，使用write方法将数据写入内部缓冲区； ③使用BufferOutputStream的flush方法将缓冲区数据刷新到文件； ④释放资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>)) ;</span><br><span class="line">bos.write(<span class="string">&quot;hello&quot;</span>.getBytes());  <span class="comment">//写数据</span></span><br><span class="line">bos.close();  <span class="comment">//释放资源</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>将HeapFile中某一个page上的tuple从该page中删除：<code>public List&lt;Page&gt; deleteTuple(TransactionId tid, Tuple t)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Page&gt; <span class="title function_">deleteTuple</span><span class="params">(TransactionId tid, Tuple t)</span> <span class="keyword">throws</span> DbException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, t.getRecordId().getPageId(), Permissions.READ_WRITE);</span><br><span class="line">    p.deleteTuple(t);</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>根据tuple的RecordID属性也可以通过getPageId找到tuple所在的page页。</p>
<p><img src="image-8.png"></p>
<p>可以自行对比一下lab1和lab2中方法实现的区别：</p>
<p><img src="image-15.png"></p>
<h3 id="BufferPool类"><a href="#BufferPool类" class="headerlink" title="BufferPool类"></a>BufferPool类</h3><p>insert和delete这里BufferPool涉及到页面置换策略，其实也就是LRU策略。所以这部分实现放到Exercise5中一起来做。</p>
<h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><blockquote>
<p>实现Insert类、Delete类，对exercise3的功能进行封装</p>
</blockquote>
<p>实现Insert和Delete操作符，用于修改磁盘上的页数据，这些操作符返回受影响的tuples个数（受影响的行数）。</p>
<h3 id="Insert类"><a href="#Insert类" class="headerlink" title="Insert类"></a>Insert类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>执行插入操作的事务id：<code>private TransactionId tid;</code></p>
</li>
<li><p>待插入的tuples的迭代器：<code>private OpIterator[] children;</code></p>
</li>
<li><p>待插入的表id：<code>private int tableId;</code></p>
</li>
<li><p>fetchNext方法会返回一个标识插入了多少行的tuple结果，tupleDesc就是该tuple的属性行：<code>private TupleDesc tupleDesc;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.tupleDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;insertNums&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>插入受影响行数的tuple结果（最主要的作用是避免fetchNext方法无限制的向下取，保证只调用一次）：<code>private Tuple insertRes;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：<code>public Insert(TransactionId t, OpIterator child, int tableId)</code></p>
</li>
<li><p>执行插入操作，返回包含插入受影响行数的tuple：<code>protected Tuple fetchNext()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 保证只调用一次，多次调用返回null</span></span><br><span class="line">    <span class="keyword">if</span> (insertRes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">insertNums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (children[<span class="number">0</span>].hasNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Database.getBufferPool().insertTuple(tid, tableId, children[<span class="number">0</span>].next());</span><br><span class="line">            insertNums++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Insert tuples into database failed!&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insertRes = <span class="keyword">new</span> <span class="title class_">Tuple</span>(tupleDesc);  <span class="comment">// 计算插入操作影响的行数</span></span><br><span class="line">    insertRes.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(insertNums));</span><br><span class="line">    <span class="keyword">return</span> insertRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Delete类"><a href="#Delete类" class="headerlink" title="Delete类"></a>Delete类</h3><p>封装类的实现和Insert类完全相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tid</span> <span class="operator">=</span> t.getRecordId().getTupleNumber();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tuples.length; i++) &#123;</span><br><span class="line"><span class="comment">//            if (t.equals(tuples[i])) &#123;</span></span><br><span class="line">            <span class="keyword">if</span>(tuples[i] != <span class="literal">null</span> &amp;&amp; compareTuplesByFields(t, tuples[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;tuple slot is already empty&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                markSlotUsed(i, <span class="literal">false</span>);</span><br><span class="line">                tuples[tid] = <span class="literal">null</span>;  <span class="comment">// delete</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;the tuple is not on this page&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-4.png"></p>
<h2 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h2><blockquote>
<p>Eviction Policy有很多，可以自己选择，我选择的是最常见的LRU策略。</p>
</blockquote>
<p>Lab1中在BufferPool满后会抛出异常，这里实现了BufferPool的页面置换策略，采取的是LRU的策略（详见LeetCode中的实现 <a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2%5C&amp;envId=top-100-liked">https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2\&amp;envId=top-100-liked</a> ）。</p>
<h3 id="BufferPool类-1"><a href="#BufferPool类-1" class="headerlink" title="BufferPool类"></a>BufferPool类</h3><p>原先采用的是HashMap保存pageId和page的映射：<code>private final Map&lt;PageId, Page&gt; bufferPools = new ConcurrentHashMap&lt;&gt;();</code>，加入页面置换策略后改用自定义的LRUCache类（维护一个<strong>双向链表</strong>）来存储pageId和page的映射关系。</p>
<blockquote>
<p>同时还涉及exercise3中BufferPool的插入、删除操作。</p>
</blockquote>
<p><strong>参数：</strong></p>
<ul>
<li><p>LRUCache类：<code>private static class LRUCache</code></p>
<p>为了实现LRU算法，需要维护一个双向链表LRUCache，用于记录每个<em>PageId</em>的访问顺序<em>。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了实现LRU算法，需要维护一个双向链表，用于记录每个PageId的访问顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity, size;</span><br><span class="line">    ConcurrentHashMap&lt;PageId, Node&gt; map;</span><br><span class="line">    <span class="comment">// 头节点和尾节点：标志位无数据</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Page <span class="title function_">get</span><span class="params">(PageId key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="comment">// 定位到链表头</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(PageId key, Page val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 更新value</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.val = val;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加到链表头</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 移除链表尾</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(node.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到链表头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到链表头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从原位置删除node</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="comment">// 再将node插入链表头部</span></span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除node节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除尾部节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        PageId key;</span><br><span class="line">        Page val;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(PageId key, Page val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;PageId, Node&gt;&gt; getEntrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>方法：</strong></p>
<p><img src="image.png"></p>
<ul>
<li><p>调用HeapFile的<code>insertTuple</code>方法插入元组，将返回的结果保存到BufferPool：<code>public void insertTuple(TransactionId tid, int tableId, Tuple t)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTuple</span><span class="params">(TransactionId tid, <span class="type">int</span> tableId, Tuple t)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">DbFile</span> <span class="variable">f</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(tableId);</span><br><span class="line">    List&lt;Page&gt; updatePages = f.insertTuple(tid, t);</span><br><span class="line">    updateBufferPool(updatePages, tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用HeapFile的<code>deleteTuple</code>方法删除元组，将结果保存到BufferPool：<code>public void deleteTuple(TransactionId tid, Tuple t)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(TransactionId tid, Tuple t)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">DbFile</span> <span class="variable">f</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(t.getRecordId().getPageId().getTableId());</span><br><span class="line">    List&lt;Page&gt; updatePages = f.deleteTuple(tid, t);</span><br><span class="line">    updateBufferPool(updatePages, tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更新BufferPool的存储：<code>public void updateBufferPool(List&lt;Page&gt; updatePages, TransactionId id)</code></p>
<p>注意将页面设置为脏页，因为在BufferPool中修改page后，和磁盘中的page不一致了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBufferPool</span><span class="params">(List&lt;Page&gt; updatePages, TransactionId id)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Page page: updatePages) &#123;</span><br><span class="line">        page.markDirty(<span class="literal">true</span>, id);  <span class="comment">// 设置为脏页（因为在BufferPool中修改page后，和磁盘中的page不一致了）</span></span><br><span class="line">        <span class="comment">// update BufferPool</span></span><br><span class="line">        lruCache.put(page.getId(), page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从BufferPool中移除页面：<code>public synchronized void removePage (PageId pid)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removePage</span><span class="params">(PageId pid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="literal">null</span>) &#123;</span><br><span class="line">        lruCache.map.remove(pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将某个页面如果是脏页则刷新到磁盘：<code>private synchronized void flushPage(PageId pid)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(PageId pid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> lruCache.get(pid);</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TransactionId</span> <span class="variable">tid</span> <span class="operator">=</span> page.isDirty();</span><br><span class="line">    <span class="keyword">if</span> (tid != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> page.getBeforeImage();</span><br><span class="line">        Database.getLogFile().logWrite(tid, before, page);</span><br><span class="line">        Database.getCatalog().getDatabaseFile(pid.getTableId()).writePage(page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将所有脏页刷新到磁盘：<code>public synchronized void flushAllPages()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flushAllPages</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;PageId, LRUCache.Node&gt; group: lruCache.getEntrySet()) &#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> group.getValue().val;</span><br><span class="line">        <span class="keyword">if</span> (page.isDirty() != <span class="literal">null</span>) &#123;</span><br><span class="line">            flushPage(group.getKey());  <span class="comment">// 将不是脏页的页面刷新页面到磁盘</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-1.png"></p>
<p><img src="image-2.png"></p>
<p>要判断要删除的目标元组的字段是否和提供的相等，而不是地址相等：</p>
<p><img src="image-3.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6-5830-Lab4</title>
    <url>/2024/08/27/MIT6-5830-Lab4/</url>
    <content><![CDATA[<p>MIT6.5830 的数据库课程。Lab4 主要是完成数据库事务以及锁机制，在 Lab 中只是考虑设计了 page 级别锁。</p>
<span id="more"></span>

<ul>
<li><p><input checked="" disabled="" type="checkbox">  Exercise1</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise2</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise3</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise4</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise5</p>
</li>
</ul>
<blockquote>
<p>为了简化工作，Lab4采用了NO STEAL/FORCE缓冲区策略，不需要记录undo log和redo log日志（Lab6中完成）：</p>
<ul>
<li><p>NO STEAL：不允许一个未提交的事务将修改更新到磁盘，即磁盘中不会存在uncommitted数据，因此无需回滚操作，不需记录undo log。</p>
</li>
<li><p>FORCE：事务在提交之后必须将所有更新立刻持久化到磁盘（产生很多随机写，效率低），但无需记录redo log。</p>
</li>
</ul>
</blockquote>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><strong>事务：</strong>事务是一组以原子方式执行的数据库操作（读取、插入、删除），是不可分割的。</p>
<p><strong>事务的四大特性（ACID）</strong></p>
<ul>
<li><p>原子性（Atomicity）：事务是一个不可分割的单位。</p>
</li>
<li><p>一致性（Consistency）：事务执行是从一个一致状态到另一个一致状态，一致指的是：① 符合数据库的约束规则（主键、外键、非空、唯一性约束等等）； ② 符合业务逻辑规则（转出金额等于转入金额、购买数量不超过库存数量等等）。</p>
</li>
<li><p>隔离性 （Isolation）：并发执行的各个事务之间互不干扰，是完全隔离的。</p>
</li>
<li><p>持久性（Durability）：事务一旦提交，（甚至系统崩溃后）对数据库中数据的改变都是永久性的。</p>
</li>
</ul>
<p><strong>事务的并发执行遇到的问题</strong></p>
<ul>
<li><p>（脏写）</p>
</li>
<li><p>脏读：当一个事务正在访问数据并对该数据进行修改，但是修改还未提交到数据库，此时另一个事务访问到这个数据。违反了事务的原子性、隔离性、一致性。</p>
<p><img src="image-25.png"></p>
</li>
<li><p>不可重复读：在一个事务中多次读取同一个数据，在该事务两次读数据之间，由于另一个事务对该数据的访问和修改导致同一事务中两次读到的数据是不一致的。违反了事务的一致性。</p>
<p><img src="image-21.png"></p>
<blockquote>
<p>不可重复读和脏读的区别：脏读是读到了<strong>未提交</strong>的数据（压根这个数据就不存在所以是脏数据），不可重复读是读到了<strong>已提交</strong>的数据（因为是已提交的数据一般来说是可以被接受的）。</p>
</blockquote>
</li>
<li><p>幻读：在一个事务中多次查询符合条件的数据记录，出现了前后两次查询数据记录数量不一致的情况。幻读主要关注的是查询结果集发生了变化，因为有新的符合条件的行被插入或删除。&#x20;</p>
<p><img src="image-23.png"></p>
<blockquote>
<p>不可重复读和幻读的区别：不可重复读主要关注的是<strong>同一行数据</strong>在两次读取时发生了变化；幻读主要关注的是<strong>查询结果集</strong>发生了变化。</p>
</blockquote>
</li>
</ul>
<p><img src="image-19.png"></p>
<p><strong>事务隔离级别</strong></p>
<p>在事务并发执行的过程中可能会遇到脏读、不可重复读、幻读的现象，而他们的严重程度也从大到小。因此SQL标准提出了四种隔离级别来规避这些现象（隔离级别越高，性能越低）：</p>
<ul>
<li><p>读未提交（read uncommitted）：指一个事务还没提交时，它做的变更就能被其他事务看到；</p>
</li>
<li><p>读已提交（read committed）：指一个事务提交之后，它做的变更才能被其他事务看到；</p>
</li>
<li><p><strong>可重复读</strong>（repeatable read）：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的；<strong>MySQL InnoDB 引擎的默认隔离级别</strong></p>
</li>
<li><p>串行化（serializable）：多个事务对同一条记录进行读写操作时，会按照串行化的方式——后访问的事务等待前一个事务执行完成才能继续执行。</p>
</li>
</ul>
<p><img src="image.png" alt="SQL标准中规定的隔离级别允许的并发问题"></p>
<p><strong>事务隔离级别如何实现</strong></p>
<ul>
<li><p>读未提交：因为可以读到未提交事务修改的数据，所以直接读取最新的数据就可以；</p>
</li>
<li><p>串行化：通过加读写锁的方式来避免不同事务的并行访问；</p>
</li>
<li><p>读已提交、可重复读：通过Read View（数据快照）来实现，它们的区别在于创建Read View的时机不同——读提交是在每个语句执行前都会重新生成一个Read View，而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都在用这个Read View。</p>
</li>
</ul>
<blockquote>
<p>什么是Read View？Read View在MVCC中又是如何工作的？</p>
</blockquote>
<blockquote>
<p>复习一下MVCC：</p>
<p>多版本并发控制，MVCC在MySQL InnoDB中的实现主要是为了提高数据库的并发性能，通过版本链来控制并发事务访问同一个记录时的行为。</p>
</blockquote>
<p><strong>Read View的4个字段：</strong></p>
<p><img src="image-22.png"></p>
<p><img src="image-24.png" alt="聚簇索引中的隐藏列trx\_id和roll\_pointer"></p>
<p><strong>（重点）</strong>当一个事务去访问记录时，除了自己的更新记录可见之外，还有其他几种情况：</p>
<p><img src="image-17.png"></p>
<hr>
<p><strong>MySQL可重复读是如何一定程度上解决幻读的？</strong></p>
<ul>
<li><p>针对快照读（普通select语句），是通过MVCC方式解决幻读的：事务开始后（执行begin语句并且在执行第一条查询语句后），会创建一个Read View，后续查询会根据这个Read View到undo log版本链中找到相应的数据，所以事务每次查询数据的结果都是一样的。</p>
</li>
<li><p>针对当前读（update、insert、delete语句），当前读在执行前都会首先查询<strong>最新版本</strong>的数据（不会到undo log中查询事务开始时的数据版本），然后再做进一步操作。</p>
</li>
</ul>
<p>InnoDB为了解决在可重复读隔离级别下使用当前读出现的幻读现象，引入间隙锁：</p>
<p><strong>在可重复读中幻读被完全解决了吗？</strong></p>
<ul>
<li><p>特殊情况1：</p>
<p><img src="image-20.png"></p>
</li>
<li><p>特殊情况2：</p>
</li>
</ul>
<p><img src="image-16.png"></p>
<p>要避免此类场景下的幻读出现，就是尽可能在事务A开启之后马上执行<code>select * for update</code>语句，因为它会对记录加next-key-lock锁，避免其他事务插入新记录。</p>
<p><strong>总结：MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p>
<p>AUTO-INC的轻量级锁会在主从复制场景中出现数据不一致的情形</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><blockquote>
<p>如何对数据库进行备份</p>
</blockquote>
<ul>
<li><p>对于数据库的存储引擎<strong>支持可重复读</strong>的，可以在备份数据库之前先开启事务，整个事务执行期间使用同一个Read View，这样由于MVCC的支持在备份期间是可以对数据进行更新操作的（mysqldump工具）。</p>
</li>
<li><p>对于数据库的存储引擎<strong>不支持可重复读</strong>的，只能加全局锁将整个数据库设置为只读状态，但是会造成业务停滞。</p>
</li>
</ul>
<p><strong>常用的行级锁和表级锁</strong></p>
<ul>
<li>排他锁（eXclusive Lock，X锁）</li>
</ul>
<p>事务T对数据对象A加上X锁，则<strong>事务T可以读A也可以修改A</strong>，其他事务不能再对数据对象A加任何锁，直到T释放A上的锁。这保证了<strong>其他事务在T释放A上的锁之前不能再读取和修改A</strong>。</p>
<ul>
<li>共享锁（Shared Lock，S锁）</li>
</ul>
<p>事务T对数据对象A加上S锁，则<strong>事务T可以读A但不能修改A</strong>，其他事务只能再对A加S锁而不能加X锁。这保证了<strong>其他事务可以读A，但在T释放A上的S锁之前不能对其做任何修改</strong>。</p>
<blockquote>
<p><strong>S锁和X锁都是行级别(row-level)的行锁</strong>，加在索引记录上的，兼容与否是对于一条记录来说的。若想对1000万条数据加锁，需要判断每条数据是否有正在上锁，这个效率非常低。这个时候就希望锁的层次有区别，例如在加S、X锁在行级时先在<strong>表级别</strong>加锁——由此引入<strong>意向锁</strong>。</p>
</blockquote>
<ul>
<li>意向锁（Intention Lock，I锁）</li>
</ul>
<p>加意向锁的目的是为了表明某事务正在锁定一行，表示加锁的意图。</p>
<p><img src="image-13.png"></p>
<p>二阶段锁协议</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>锁的粒度从大到小分为 Database -&gt; Table -&gt; Page -&gt; Tuple，而本次实验只要求实现<strong>Page级别锁</strong>。</p>
<p><img src="image-14.png"></p>
<blockquote>
<p>实现的排他锁和共享锁应当满足以下条件：</p>
<ul>
<li><p>在一个事务读取一个对象前，应该要有其的共享锁。</p>
</li>
<li><p>在一个事务写入一个对象前，应该要有其的排它锁。</p>
</li>
<li><p>一个对象的共享锁可以被多个事务共享。</p>
</li>
<li><p>一个对象的排它锁只能被一个事务所拥有。</p>
</li>
<li><p>如果一个事务已经拥有了一个对象的共享锁，则其拥有的锁可以被升级为排它锁。</p>
</li>
</ul>
</blockquote>
<ol>
<li><p>创建页面级别的锁类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PageLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionId tid;  <span class="comment">// 获取锁的事务</span></span><br><span class="line">    <span class="keyword">private</span> PageId pid;  <span class="comment">// 锁所在的页面</span></span><br><span class="line">    <span class="keyword">private</span> LockType type;  <span class="comment">// 锁类型（S or X）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageLock</span><span class="params">(TransactionId tid, PageId pid, LockType type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tid = tid;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LockType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>锁类型LockType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHARED_LOCK (<span class="number">0</span>, <span class="string">&quot;共享锁&quot;</span>),</span><br><span class="line">EXCLUSIVE_LOCK (<span class="number">1</span>, <span class="string">&quot;排它锁&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>LockManager锁管理类（核心）</p>
<ol>
<li><p>一个页可以有多把锁（S锁），一把锁只能存在于一个页，即锁与页是<strong>多对一</strong>的关系；</p>
</li>
<li><p>一个事务中可以获取多把锁，一把锁只能被一个事务获取，即锁与事务也是<strong>多对一</strong>的关系；</p>
</li>
</ol>
<p>由a和b得出来设计<strong>存储锁的数据结构</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConcurrentHashMap&lt;PageId, ConcurrentHashMap&lt;TransactionId, PageLock&gt;&gt; lockMap;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在LockManager中还有一些比较重要的方法：</p>
<ul>
<li><p>判断指定事务tid在指定页面pid是否存在锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果指定的事务在指定的页面上有锁，则返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">holdsLock</span><span class="params">(TransactionId tid, PageId p)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    <span class="keyword">if</span> (lockMap.get(p) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lockMap.get(p).get(tid) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>申请锁流程</p>
</li>
</ul>
<p><img src="image-18.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(PageId pageId, TransactionId tid, LockType requestLock, <span class="type">int</span> reTry)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 重传达到3次</span></span><br><span class="line">    <span class="keyword">if</span> (reTry == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于打印log</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、页面上不存在锁</span></span><br><span class="line">    <span class="keyword">if</span> (lockMap.get(pageId) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 直接获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、页面上存在锁</span></span><br><span class="line">    ConcurrentHashMap&lt;TransactionId, PageLock&gt; tidLocksMap = lockMap.get(pageId);</span><br><span class="line">    <span class="keyword">if</span> (tidLocksMap.get(tid) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 页面上没有自己事务的锁</span></span><br><span class="line">        <span class="keyword">if</span> (requestLock == LockType.EXCLUSIVE_LOCK) &#123;</span><br><span class="line">            <span class="comment">// 2.1.1 请求的为X锁</span></span><br><span class="line">            wait(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> acquireLock(pageId, tid, requestLock, reTry + <span class="number">1</span>);  <span class="comment">// 不能获取页面上的X锁，等待一段时间后重试</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestLock == LockType.SHARED_LOCK) &#123;</span><br><span class="line">            <span class="comment">// 2.1.2 页面上的锁是否都是S锁：页面上的锁大于1个就都是S锁（因为X锁只能被一个事务占有）</span></span><br><span class="line">            <span class="keyword">if</span> (tidLocksMap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 都是读锁，直接获取</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Collection&lt;PageLock&gt; values = tidLocksMap.values();</span><br><span class="line">                <span class="comment">// values集合中只有一个元素</span></span><br><span class="line">                <span class="keyword">for</span> (PageLock value: values) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value.getType() == LockType.EXCLUSIVE_LOCK) &#123;</span><br><span class="line">                        wait(<span class="number">10</span>);</span><br><span class="line">                        <span class="keyword">return</span> acquireLock(pageId, tid, requestLock, reTry + <span class="number">1</span>);  <span class="comment">// 存在的锁为X锁，不能获取页面上的X锁，等待一段时间后重试</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 存在的锁为S锁，直接获取</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2 页面上有自己事务的锁（每次获取requestLock的时候要先remove掉原来的锁）</span></span><br><span class="line">        <span class="keyword">if</span> (requestLock == LockType.SHARED_LOCK) &#123;</span><br><span class="line">            <span class="comment">// 2.2.1 请求的为S锁</span></span><br><span class="line">            tidLocksMap.remove(tid);  <span class="comment">// 先移除自己的锁</span></span><br><span class="line">            <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 获取S锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.1 请求的为X锁</span></span><br><span class="line">            <span class="keyword">if</span> (tidLocksMap.get(tid).getType() == LockType.EXCLUSIVE_LOCK) &#123;</span><br><span class="line">                <span class="comment">// 判断自己的锁是否是X锁，如果是则直接获取</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断页面上是否还有其他事务的锁</span></span><br><span class="line">                <span class="keyword">if</span> (tidLocksMap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    wait(<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">return</span> acquireLock(pageId, tid, requestLock, reTry + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 只有自己拥有一个读锁，进行锁升级</span></span><br><span class="line">                    tidLocksMap.remove(tid);</span><br><span class="line">                    <span class="keyword">return</span> putLock(tid, pageId, requestLock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过BufferPool的<code>getPage</code>方法获取page级别的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    LockType lockType;</span><br><span class="line">    <span class="keyword">if</span> (perm == Permissions.READ_ONLY) &#123;</span><br><span class="line">        lockType = LockType.SHARED_LOCK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lockType = LockType.EXCLUSIVE_LOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果获取lock失败(reTry 3次)则直接放弃事务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lockManager.acquireLock(pid, tid, lockType, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，回滚事务</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionAbortedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;Method 「getPage」获取锁发生异常！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bufferPool应直接放在直接内存</span></span><br><span class="line">    <span class="keyword">if</span> (lruCache.get(pid) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> file.readPage(pid);  <span class="comment">// 调用HeapFile的readPage方法</span></span><br><span class="line">        lruCache.put(pid, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruCache.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-12.png"></p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><ul>
<li><p>HeapFile的insertTuple方法</p>
<p>在HeapFile的insertTuple方法中，首先要寻找页面是否存在空闲的slot，这一操作首先会获取页面上的X锁，一旦找到空闲的slot就写入。但是这种操作在S2PL协议下有时会大量占用资源：<strong>在没有空闲slot的情况下，会不断地获取每个页上的X锁而不释放</strong>。其实当页面没有空闲的slot时我们可以直接释放该页面的X锁，这虽然违反了S2PL协议，但由于我们没有对该页面上的数据进行更新，所以就算释放了页面上的X锁，也不会影响其他并发事务的操作。</p>
</li>
</ul>
<p><img src="image-15.png"></p>
<p>加入释放锁逻辑：</p>
<ul>
<li><p>HeapFile的deleteTuple方法</p>
<p><img src="image-10.png"></p>
</li>
</ul>
<p>什么时候做锁的释放逻辑</p>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><blockquote>
<p>完成NO STEAL策略：事务的修改必须在事务提交之后写入磁盘。</p>
</blockquote>
<p>这意味着在事务执行过程中，可以通过丢弃BufferPool中的脏页并从磁盘重新读取它们完成BufferPool的复原（回滚）来absort事务。所以脏页是完成BufferPool复原很重要的依据，<strong>因此在LRU策略中我们不能驱逐脏页</strong>。</p>
<ul>
<li>修改LRUCache中的put方法</li>
</ul>
<p><img src="image-11.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(PageId key, Page val)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="keyword">if</span> (contain(key)) &#123;</span><br><span class="line">        <span class="comment">// 更新value</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        node.val = val;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val);</span><br><span class="line">        map.put(key, newNode);</span><br><span class="line">        <span class="comment">// 添加到链表头</span></span><br><span class="line">        addToHead(newNode);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">            <span class="comment">// 移除链表尾(我们可以通过丢弃脏页并从磁盘重新读取来进行事务的回滚，因为我们不能在LRU中删除脏页)</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">            <span class="comment">// 丢弃的不能是脏页，是脏页则跳过</span></span><br><span class="line">            <span class="keyword">while</span> (removeNode.val.isDirty() != <span class="literal">null</span>) &#123;</span><br><span class="line">                removeNode = removeNode.prev;</span><br><span class="line">                <span class="keyword">if</span> (removeNode == newNode || removeNode == tail) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;没有合适的页存储空间或者所有页都为脏页！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意不能删除脏页</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> removeTail();</span><br><span class="line">            map.remove(node.key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><blockquote>
<p>事务结束后，调用BufferPool的transactionComplete方法，判断事务是成功完成还是失败需要回滚。</p>
</blockquote>
<ul>
<li><p>事务成功完成时，需要将BufferPool中的脏页全部刷新到磁盘；事务失败则需要回滚，将磁盘中的数据反向刷新到BufferPool中替换掉脏页。</p>
</li>
<li><p>释放掉事务所拥有的所有锁，完成S2PL的释放阶段。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 释放掉给定事务所有的锁   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionComplete</span><span class="params">(TransactionId tid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    transactionComplete(tid, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提交或中止给定的事务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionComplete</span><span class="params">(TransactionId tid, <span class="type">boolean</span> commit)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    <span class="comment">// 1.1 事务成功则刷新页面到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (commit) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flushPages(tid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.2 事务失败则回滚将磁盘反向刷新到BufferPool</span></span><br><span class="line">        rollBack(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、释放tid事务上所有的锁</span></span><br><span class="line">    lockManager.releasePageByTid(tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 事务回滚</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">rollBack</span><span class="params">(TransactionId tid)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;PageId, LRUCache.Node&gt; group: lruCache.getEntrySet()) &#123;</span><br><span class="line">        <span class="type">PageId</span> <span class="variable">pageId</span> <span class="operator">=</span> group.getKey();</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> group.getValue().val;</span><br><span class="line">        <span class="keyword">if</span> (tid.equals(page.isDirty())) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tableId</span> <span class="operator">=</span> pageId.getTableId();</span><br><span class="line">            <span class="type">DbFile</span> <span class="variable">table</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(tableId);</span><br><span class="line">            <span class="type">Page</span> <span class="variable">readPage</span> <span class="operator">=</span> table.readPage(pageId);</span><br><span class="line">            <span class="comment">// 将磁盘的页面反向刷新至BufferPool完成事务回滚</span></span><br><span class="line">            lruCache.removeByKey(pageId);</span><br><span class="line"><span class="comment">//            lruCache.put(pageId, readPage);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rollback没有将磁盘的内容反向刷新到bufferpool中为什么才能通过测试用例？</p>
<p><img src="image-8.png"></p>
</blockquote>
<p><img src="image-3.png"></p>
<p><img src="image-7.png"></p>
<p><img src="image-9.png"></p>
<p><img src="image-6.png"></p>
<p><img src="image-5.png"></p>
<p><img src="image-2.png"></p>
<p><img src="image-1.png"></p>
<p><img src="image-4.png"></p>
<h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><p>死锁就是多个并发进程因互相争夺系统资源而造成的相互等待的现象。</p>
<p><strong>死锁产生的四个必要条件</strong></p>
<ul>
<li><p>互斥条件：一个资源只能被一个进程获取，不允许其他进程访问；</p>
</li>
<li><p>请求和保持条件：一个进程因请求资源而发生阻塞时，不会释放自己占有的资源；</p>
</li>
<li><p>不可剥夺条件：进程已获得的资源，在未完成使用之前不能被其他进程剥夺，只能自己释放；</p>
</li>
<li><p>循环等待条件：若干进程之间形成头尾相连互相等待的环行资源。</p>
</li>
</ul>
<p><strong>死锁的处理方法</strong></p>
<ul>
<li><p>死锁检测与死锁恢复</p>
<p>在死锁之前不采取任何措施，只检测系统有没有发生死锁，发生了再采取一些措施解除死锁。</p>
<ul>
<li>死锁检测：死锁定理</li>
</ul>
<p>*</p>
</li>
<li><p>死锁预防</p>
</li>
<li><p>死锁避免</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6-5830-Lab3</title>
    <url>/2024/08/22/MIT6-5830-Lab3/</url>
    <content><![CDATA[<p>MIT6.5830 的数据库课程。Lab3 主要是完成数据库查询优化的成本优化器。</p>
<span id="more"></span>

<ul>
<li><p><input checked="" disabled="" type="checkbox">  Exercise1</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise2</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise3</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  Exercise4</p>
</li>
</ul>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p><strong>I/O成本：</strong></p>
<p>查询表中记录时，需要先把数据或索引加载到内存，从磁盘到内存的加载过程损耗时间。</p>
<p><strong>CPU成本：</strong></p>
<p>读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序操作损耗的时间。</p>
<h3 id="查询处理与查询优化"><a href="#查询处理与查询优化" class="headerlink" title="查询处理与查询优化"></a>查询处理与查询优化</h3><p>查询处理是指从数据库中提取数据所涉及的一系列活动，这些活动包括：</p>
<ul>
<li><p>语法分析与翻译：将高层数据库语言表示的查询语句翻译为能在文件系统的物理层上使用的表达形式；</p>
</li>
<li><p>优化：各种查询的优化转换；</p>
</li>
<li><p>查询的实际执行；</p>
</li>
</ul>
<p><img src="image-3.png"></p>
<blockquote>
<p>为了全面的说明如何执行查询，不仅要提供关系代数表达式，还要对表达式加上带指令的注释来说明如何执行每种运算。带有注释的关系代数运算称为<strong>执行源语</strong>，用于执行一个查询的原语操作序列称为<strong>查询执行计划</strong>。</p>
</blockquote>
<p>我们不能寄希望用户写出具有最高效率执行计划的查询语句，而构造具有最小执行代价的查询计划应当是系统的责任，系统的这项工作就叫做查询优化。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p><strong>基于规则的优化器（Rule-Based Optimization,RBO）</strong></p>
<p>硬编码在数据库中一系列的规则（比如索引的优先级大于全表扫描）来决定SQL的执行计划，无论数据表内容如何变化，执行计划也基本不会改变（RBO对数据不敏感）。</p>
<p>缺点：</p>
<ul>
<li><p>需要按照规则去写SQL语句，要求开发人员对RBO的规则非常了解，不熟悉规则的开发者写出的SQL性能可能非常差。</p>
</li>
<li><p>数据的量级也会影响SQL的性能。</p>
</li>
</ul>
<p><strong>基于代价的优化器（COST-Based Optimization,CBO）</strong></p>
<p>根据优化规则对关系表达式进行转换，生成多个执行计划，然后根据统计信息和代价模型计算各种执行计划的“代价COST”，从中选用COST最低的执行方案来实际执行。</p>
<p>CBO的主要流程：</p>
<ul>
<li><p>利用关于表的统计数据，来估计不同查询计划的cost（cost与join、selection的基数、filter的选择率和join的谓词有关）</p>
</li>
<li><p>使用数据来对join和select进行排序，选择最佳的实现方式</p>
</li>
</ul>
<h3 id="基数和选择性"><a href="#基数和选择性" class="headerlink" title="基数和选择性"></a>基数和选择性</h3><p><strong>基数（cardinality）</strong></p>
<p>某一列，不同键值的数量（主键列的基数=行数）。</p>
<p><strong>选择性（selectivity）</strong></p>
<p>选择性 = 基数 / 行数</p>
<p><strong>用途</strong></p>
<p>被当作是否建立索引的判断依据之一。基数和选择性越高的列越适合建立BTree索引，当基数和选择性都比较低时就要根据数据分布情况来决定是否建立BTree索引了。</p>
<blockquote>
<p>索引最重要的目标是尽可能地缩小匹配行的初始候选值，从而减少io提升查询性能。所以通常来说索引的选择性越高则查询效率越高，因为选择性高的索引可以让数据库在查找时过滤掉更多的行。</p>
</blockquote>
<p>CBO还使用选择率来估算对应结果集的基数。</p>
<p>补充</p>
<h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><blockquote>
<p>实现IntHistogram</p>
</blockquote>
<p>估计查询计划的代价最重要的依据就是数据的统计信息，lab采用为每一个字段建立直方图来对数据进行统计。</p>
<p><img src="image-9.png"></p>
<h3 id="直方图统计信息"><a href="#直方图统计信息" class="headerlink" title="直方图统计信息"></a>直方图统计信息</h3><p><strong>创建直方图</strong></p>
<p>步骤1：首先全表扫描一次，获取每个字段的最大值与最小值（获取区间范围）；</p>
<p>步骤2：再次扫描表，选择所有元组的所有字段，使用它们填充每个直方图的桶计数。</p>
<p><strong>计算选择率</strong></p>
<p>对于等值运算：<code>value=const</code>，首先需要找到包含该const值的桶，然后计算：<code>选择率=(value=const的记录数)/记录总数</code>，（假设数值在桶中是均匀分布的，<code>value=const</code>的记录数为<code>(桶高/桶宽)</code>），故选择率表示为：<code>(桶高/桶宽)/记录总数</code>。</p>
<p>对于非等值运算：<code>value&gt;const</code>，<code>value&gt;const</code>的记录数在直方图中由两部分构成：<code>(const, b.right]</code>的记录数<code>(h_b / w_b)*(const - b.right)</code>和<code>[b.right, max]</code>的记录数<code>后面桶高之和</code>。</p>
<p><img src="image.png"></p>
<h3 id="IntHistogram类"><a href="#IntHistogram类" class="headerlink" title="IntHistogram类"></a>IntHistogram类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>直方图中的桶，统计每个桶的高度：<code>private int[] buckets;</code></p>
</li>
<li><p>直方图的最大值：<code>private int max;</code></p>
</li>
<li><p>直方图的最小值：<code>private int min;</code></p>
</li>
<li><p>直方图的桶宽度：<code>private double width;</code></p>
</li>
<li><p>直方图的记录总数：<code>private int tupleCount;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntHistogram</span><span class="params">(<span class="type">int</span> buckets, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.buckets = <span class="keyword">new</span> <span class="title class_">int</span>[buckets];</span><br><span class="line">    <span class="built_in">this</span>.min = min;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.width = (<span class="type">double</span>) (max - min + <span class="number">1</span>) / buckets;  <span class="comment">// 注意桶宽度的设置</span></span><br><span class="line">    <span class="built_in">this</span>.tupleCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据value值获取桶的序号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) ((value - min) / width);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= buckets.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ((value - min) / width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向直方图添加数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (v &gt;= min &amp;&amp; v &lt;= max) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(v);</span><br><span class="line">        buckets[index]++;</span><br><span class="line">        tupleCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回估计该表上特定谓词和操作数的选择性：</p>
<p>例如，<code>op=</code><em><code>LESS_THAN</code>且<code>v=5</code>，则比较表达式为<code>LESS_THAN 5</code>。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateSelectivity</span><span class="params">(Predicate.Op op, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> LESS_THAN:</span><br><span class="line">            <span class="keyword">if</span> (v &lt;= min) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(v);</span><br><span class="line">                <span class="type">double</span> <span class="variable">tuples</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                    tuples += buckets[i];</span><br><span class="line">                &#125;</span><br><span class="line">                tuples += (buckets[index] / width) * (v - (min + index * width));  <span class="comment">// add 直方图index桶最后一部分</span></span><br><span class="line">                <span class="keyword">return</span> tuples / tupleCount;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - estimateSelectivity(Predicate.Op.LESS_THAN_OR_EQ, v);</span><br><span class="line">        <span class="keyword">case</span> EQUALS:</span><br><span class="line">            <span class="keyword">return</span> estimateSelectivity(Predicate.Op.LESS_THAN_OR_EQ, v) - estimateSelectivity(Predicate.Op.LESS_THAN, v);</span><br><span class="line">        <span class="keyword">case</span> NOT_EQUALS:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - estimateSelectivity(Predicate.Op.EQUALS, v);</span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN_OR_EQ:</span><br><span class="line">            <span class="keyword">return</span> estimateSelectivity(Predicate.Op.GREATER_THAN, v - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">case</span> LESS_THAN_OR_EQ:</span><br><span class="line">            <span class="keyword">return</span> estimateSelectivity(Predicate.Op.LESS_THAN, v + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Unsupported operation: &quot;</span> + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-8.png"></p>
<h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><blockquote>
<p>实现TableStats类</p>
</blockquote>
<p>根据tableId和每页的IO花销，构造每个字段的直方图，并利用Exercise1的方法得出每个直方图相关的选择性估计。</p>
<h3 id="TableStats类"><a href="#TableStats类" class="headerlink" title="TableStats类"></a>TableStats类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>进行数据统计的表：<code>private HeapFile dbFile;</code></p>
</li>
<li><p>访问每页的IO开销：<code>private int ioCostPerPage;</code></p>
</li>
<li><p>表中的总记录数，用于估算表基数：<code>private int totalTuples;</code></p>
</li>
<li><p>整型字段与直方图的映射：<code>private ConcurrentHashMap&lt;Integer, IntHistogram&gt; intHistograms;</code></p>
</li>
<li><p>字符串字段与直方图的映射：<code>private ConcurrentHashMap&lt;Integer, StringHistogram&gt; stringHistograms;</code></p>
</li>
<li><p>整型字段中与该字段最大值的映射：<code>Map&lt;Integer, Integer&gt; maxMap;</code></p>
</li>
<li><p>整型字段中与该字段最小值的映射：<code>Map&lt;Integer, Integer&gt; minMap;</code></p>
</li>
<li><p>表的属性行：<code>private TupleDesc tupleDesc;</code></p>
</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li><p>构造方法：根据给定的tableId为表各字段建立直方图</p>
<ul>
<li><p>整型字段：第一次扫描统计各个整型字段的最大最小值确定区间，第二次扫描生成各个字段的直方图</p>
</li>
<li><p>字符字段：无需通过最大最小值确定区间，所以一次扫描</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TableStats</span><span class="params">(<span class="type">int</span> tableid, <span class="type">int</span> ioCostPerPage)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; minMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; maxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.intHistograms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.stringHistograms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.dbFile = (HeapFile) Database.getCatalog().getDatabaseFile(tableid);</span><br><span class="line">    <span class="built_in">this</span>.ioCostPerPage = ioCostPerPage;</span><br><span class="line">    <span class="built_in">this</span>.tupleDesc = dbFile.getTupleDesc();</span><br><span class="line"></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">    tx.start();</span><br><span class="line">    <span class="type">DbFileIterator</span> <span class="variable">child</span> <span class="operator">=</span> dbFile.iterator(tx.getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        child.open();</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.totalTuples += <span class="number">1</span>;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tupleDesc.numFields(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tupleDesc.getFieldType(i) == Type.INT_TYPE) &#123;</span><br><span class="line">                    <span class="comment">// int类型，需要先统计各个属性的最大最小值</span></span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(i);</span><br><span class="line">                    <span class="comment">// 更新最小值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">min_value</span> <span class="operator">=</span> Math.min(minMap.getOrDefault(i, Integer.MAX_VALUE), field.getValue());</span><br><span class="line">                    minMap.put(i, min_value);</span><br><span class="line">                    <span class="comment">// 更新最大值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">max_value</span> <span class="operator">=</span> Math.max(maxMap.getOrDefault(i, Integer.MIN_VALUE), field.getValue());</span><br><span class="line">                    maxMap.put(i, max_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tupleDesc.getFieldType(i) == Type.STRING_TYPE) &#123;</span><br><span class="line">                    <span class="comment">// string类型，直接构造直方图</span></span><br><span class="line">                    <span class="type">StringHistogram</span> <span class="variable">strHis</span> <span class="operator">=</span> <span class="built_in">this</span>.stringHistograms.getOrDefault(i, <span class="keyword">new</span> <span class="title class_">StringHistogram</span>(NUM_HIST_BINS));</span><br><span class="line">                    <span class="type">StringField</span> <span class="variable">field</span> <span class="operator">=</span> (StringField) tuple.getField(i);</span><br><span class="line">                    strHis.addValue(field.getValue());</span><br><span class="line">                    <span class="built_in">this</span>.stringHistograms.put(i, strHis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int类型根据最小最大初始化直方图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tupleDesc.numFields(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minMap.get(i) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 初始化构造int型直方图</span></span><br><span class="line">                <span class="built_in">this</span>.intHistograms.put(i, <span class="keyword">new</span> <span class="title class_">IntHistogram</span>(NUM_HIST_BINS, minMap.get(i), maxMap.get(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新扫描表，往int直方图添加数据</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="comment">// 填充直方图的数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tupleDesc.numFields(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tupleDesc.getFieldType(i) == Type.INT_TYPE) &#123;</span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(i);</span><br><span class="line">                    <span class="type">IntHistogram</span> <span class="variable">intHis</span> <span class="operator">=</span> <span class="built_in">this</span>.intHistograms.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (intHis == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;获得直方图失败！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    intHis.addValue(field.getValue());</span><br><span class="line">                    <span class="built_in">this</span>.intHistograms.put(i, intHis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        child.close();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-1.png"></p>
<ul>
<li><p>估计扫描表的IO成本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateScanCost</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 文件页数 * IO代价</span></span><br><span class="line">    <span class="keyword">return</span> dbFile.numPages() * ioCostPerPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回给定选择率的基数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">estimateTableCardinality</span><span class="params">(<span class="type">double</span> selectivityFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.totalTuples * selectivityFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回指定字段的平均选择率：<code>public double avgSelectivity(int field, Predicate.Op op)</code></p>
</li>
<li><p>返回在特定谓词和操作符下字段的选择率：<code>public double estimateSelectivity(int field, Predicate.Op op, Field constant)</code></p>
</li>
<li><p>返回表中元组行数：<code>public int totalTuples()</code></p>
</li>
</ul>
<p><img src="image-10.png"></p>
<h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><blockquote>
<p>实现JoinOptimizer类的estimateJoinCost、estimateJoinCardinality方法</p>
</blockquote>
<p>由目标也可以看出，exercise3目的是估算Join连接操作的开销以及估算Join之后的基数。</p>
<h3 id="JoinOptimizer类"><a href="#JoinOptimizer类" class="headerlink" title="JoinOptimizer类"></a>JoinOptimizer类</h3><p><strong>方法：</strong></p>
<ul>
<li><p>估计连接成本：<code>card1</code>是左表的基数，<code>cost1</code>是扫描左表的成本，<code>card2</code>是右表的基数，<code>cost2</code>是扫描右表的成本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">循环嵌套的连接成本如下：</span><br><span class="line">joincost(t1 join t2) = scancost(t1) + tupsNum(t1) * scancost(t2)  <span class="comment">// IO cost</span></span><br><span class="line">                   + tupsNum(t1) * tupsNum(t2)  <span class="comment">// CPU cost</span></span><br><span class="line">t1的扫描成本：cost1</span><br><span class="line">t2的扫描成本：t1中每一条数据都要和t2中所有数据进行连接，每从t1取出一条数据都要对t2进行全表扫描，</span><br><span class="line">故扫描成本是 card1*cost2</span><br><span class="line">t1与t2的连接成本：card1*card2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateJoinCost</span><span class="params">(LogicalJoinNode j, <span class="type">int</span> card1, <span class="type">int</span> card2,</span></span><br><span class="line"><span class="params">                               <span class="type">double</span> cost1, <span class="type">double</span> cost2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (j <span class="keyword">instanceof</span> LogicalSubplanJoinNode) &#123;</span><br><span class="line">        <span class="comment">// A LogicalSubplanJoinNode represents a subquery.</span></span><br><span class="line">        <span class="comment">// You do not need to implement proper support for these for Lab 3.</span></span><br><span class="line">        <span class="keyword">return</span> card1 + cost1 + cost2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert your code here.</span></span><br><span class="line">        <span class="keyword">return</span> cost1 + card1 * cost2 + card1 * card2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>估算两张表连接后的基数：</strong></p>
<ul>
<li><p>对于等值连接</p>
<ul>
<li>当一个属性是primary key时，把non-primary key属性的记录数作为连接后的基数。</li>
</ul>
<p><img src="image-2.png"></p>
<ul>
<li><p>当两个属性都是primary key时，去字段中记录数较小的当作基数。</p>
</li>
<li><p>没有primary key时，很难估计连接结果的基数。Lab中采用简单的估计方式，即连接后的记过基数是两表中较大的基数。</p>
</li>
</ul>
</li>
<li><p>对于非等值连接：基数也很难估计，本Lab采用两表基数乘积 * 0.3 作为非等值连接的基数估计。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">estimateTableJoinCardinality</span><span class="params">(Predicate.Op joinOp,</span></span><br><span class="line"><span class="params">      String table1Alias, String table2Alias, String field1PureName,</span></span><br><span class="line"><span class="params">      String field2PureName, <span class="type">int</span> card1, <span class="type">int</span> card2, <span class="type">boolean</span> t1pkey,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> t2pkey, Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">      Map&lt;String, Integer&gt; tableAliasToId)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">card</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 连接结果的基数</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (joinOp == Predicate.Op.EQUALS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1pkey &amp;&amp; !t2pkey) &#123;</span><br><span class="line">            card = card2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!t1pkey &amp;&amp; t2pkey) &#123;</span><br><span class="line">            card = card1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1pkey &amp;&amp; t2pkey) &#123;</span><br><span class="line">            card = Math.min(card1, card2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            card = Math.max(card1, card2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        card = (<span class="type">int</span>) (card1 * card2 * <span class="number">0.3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> card &lt;= <span class="number">0</span> ? <span class="number">1</span> : card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-7.png"></p>
<h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><blockquote>
<p>完成JoinOptimizer类</p>
</blockquote>
<p>根据多表连接的代价，选择出代价最小的连接顺序。</p>
<p>对于一个复杂的连接查询，<code>r1⋈r2⋈……⋈rn</code>，对于n个关系来说存在<code>(2(n-1))! / (n-1)!</code>种不同的连接次序。随着n的增加，这个数量迅速增长。但是我们不必产生与给定表达式等价的所有表达式，假设我们希望找到以下表达式的最佳连接次序：<code>(r1⋈r2⋈r3)⋈r4⋈r5</code>，<code>r1⋈r2⋈r3</code>有12种不同的次序，其计算结果与<code>r4⋈r5</code>又有12种连接次序。基于这种思想，采用一种用于连接次序优化的<strong>动态规划DP算法</strong>。</p>
<h3 id="JoinOptimizer类-1"><a href="#JoinOptimizer类-1" class="headerlink" title="JoinOptimizer类"></a>JoinOptimizer类</h3><p><strong>参数：</strong></p>
<ul>
<li><p>一系列join节点的集合，而不是需要连接的表集合：<code>final List&lt;LogicalJoinNode&gt; joins;</code></p>
<p>比如<code>r1⋈r2⋈r3</code>，有<code>logicalJoinNode1=r1⋈r2</code>，<code>logicalJoinNode2=r2⋈r3</code>。</p>
</li>
</ul>
<p><strong>辅助类和方法：</strong></p>
<ul>
<li><p>CostCard类</p>
<ul>
<li><p>按照某一顺序连接的查询计划：<code>public List&lt;LogicalJoinNode&gt; plan;</code></p>
</li>
<li><p>最优连接顺序下的代价：<code>public double cost;</code></p>
</li>
<li><p>最优连接顺序下产生的基数：<code>public int card;</code></p>
</li>
</ul>
</li>
<li><p>PlanCache类：类似于DP数组</p>
<ul>
<li><p>关系集合与最优连接顺序的映射：<code>final Map&lt;Set&lt;LogicalJoinNode&gt;, List&lt;LogicalJoinNode&gt;&gt; bestOrders = new HashMap&lt;&gt;();</code></p>
</li>
<li><p>关系集合与最优连接顺序代价的映射：<code>final Map&lt;Set&lt;LogicalJoinNode&gt;, Double&gt; bestCosts = new HashMap&lt;&gt;();</code></p>
</li>
<li><p>关系集合与最优连接顺序基数的映射：<code>final Map&lt;Set&lt;LogicalJoinNode&gt;, Integer&gt; bestCardinalities = new HashMap&lt;&gt;();</code></p>
</li>
</ul>
</li>
<li><p>生成所有给定size大小的子集集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; <span class="title function_">enumerateSubsets</span><span class="params">(List&lt;T&gt; v, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    Set&lt;Set&lt;T&gt;&gt; els = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    els.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Set&lt;Set&lt;T&gt;&gt; newels = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; s : els) &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : v) &#123;</span><br><span class="line">                Set&lt;T&gt; news = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(s);</span><br><span class="line">                <span class="keyword">if</span> (news.add(t))</span><br><span class="line">                    newels.add(news);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        els = newels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> els;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>计算子计划的查询代价：<code>private CostCard computeCostAndCardOfSubplan(Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; filterSelectivities, LogicalJoinNode joinToRemove, Set&lt;LogicalJoinNode&gt; joinSet, double bestCostSoFar, PlanCache pc)</code></p>
</li>
<li><p>将连接计划进行显示的图形表示：<code>private void printJoins(List&lt;LogicalJoinNode&gt; js, PlanCache pc, Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; selectivities)</code></p>
</li>
</ul>
<p><strong>方法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(</span></span><br><span class="line"><span class="params">        Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">        Map&lt;String, Double&gt; filterSelectivities, <span class="type">boolean</span> explain)</span></span><br><span class="line">        <span class="keyword">throws</span> ParsingException &#123;</span><br><span class="line">    <span class="comment">// Not necessary for labs 1 and 2.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">CostCard</span> <span class="variable">bestCostCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CostCard</span>();</span><br><span class="line">    <span class="type">PlanCache</span> <span class="variable">planCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlanCache</span>();</span><br><span class="line">    <span class="comment">// 思路：通过辅助方法获取每个size下最优的连接顺序，不断加入planCache中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= joins.size(); i++) &#123;</span><br><span class="line">        Set&lt;Set&lt;LogicalJoinNode&gt;&gt; subsets = enumerateSubsets(joins, i);</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;LogicalJoinNode&gt; set: subsets) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">bestCostSoFar</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">            bestCostCard = <span class="keyword">new</span> <span class="title class_">CostCard</span>();</span><br><span class="line">            <span class="keyword">for</span> (LogicalJoinNode join: set) &#123;</span><br><span class="line">                <span class="comment">// 根据子计划找出最优方案</span></span><br><span class="line">                <span class="type">CostCard</span> <span class="variable">costCard</span> <span class="operator">=</span> computeCostAndCardOfSubplan(stats, filterSelectivities, join, set, bestCostSoFar, planCache);</span><br><span class="line">                <span class="keyword">if</span> (costCard == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bestCostSoFar = costCard.cost;</span><br><span class="line">                bestCostCard = costCard;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bestCostSoFar != Double.MAX_VALUE) &#123;</span><br><span class="line">                planCache.addPlan(set, bestCostCard.cost, bestCostCard.card, bestCostCard.plan);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (explain) &#123;</span><br><span class="line">        printJoins(bestCostCard.plan, planCache, stats, filterSelectivities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果joins传进来长度为0，则计划为空</span></span><br><span class="line">    <span class="keyword">if</span> (bestCostCard.plan != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bestCostCard.plan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-6.png"></p>
<h2 id="Extra-Credit"><a href="#Extra-Credit" class="headerlink" title="Extra Credit"></a>Extra Credit</h2><blockquote>
<p>改进子集迭代器<code>enumerateSubsets</code>方法的性能</p>
</blockquote>
<p><strong>原方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; <span class="title function_">enumerateSubsets</span><span class="params">(List&lt;T&gt; v, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    Set&lt;Set&lt;T&gt;&gt; els = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    els.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Set&lt;Set&lt;T&gt;&gt; newels = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; s : els) &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : v) &#123;</span><br><span class="line">                Set&lt;T&gt; news = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(s);</span><br><span class="line">                <span class="keyword">if</span> (news.add(t))</span><br><span class="line">                    newels.add(news);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        els = newels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> els;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进：</strong></p>
<p>原先求子集的方法，需要不断的创建新对象，当size很大时时间复杂度非常高。此问题的本质实际上就是类似Leetcode利用回溯的组合问题。原方法的时间复杂度是<code>o(n^3)</code>，回溯的时间复杂度是<code>o(n*2^n)</code>，主要是看剪纸的效率如何。</p>
<p><img src="image-5.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; <span class="title function_">enumerateSubsets</span><span class="params">(List&lt;T&gt; v, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    Set&lt;Set&lt;T&gt;&gt; els = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(els, v, size, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> els;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Set&lt;Set&lt;T&gt;&gt; els, List&lt;T&gt; v, <span class="type">int</span> size, <span class="type">int</span> curIdx, Deque&lt;T&gt; path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        els.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curIdx; i &lt; v.size(); i++) &#123;</span><br><span class="line">        path.addLast(v.get(i));</span><br><span class="line">        dfs(els, v, size, i + <span class="number">1</span>, path);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-4.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven进阶</title>
    <url>/2023/06/22/Maven%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>Maven就是是专门为Java项目打造的管理和构建工具，它 提供了一套标准化的项目结构、提供了一套标准化的构建流程等等。</p>
<span id="more"></span>

<h2 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h2><h3 id="分模块开发设计"><a href="#分模块开发设计" class="headerlink" title="分模块开发设计"></a>分模块开发设计</h3><p>1、按照功能拆分：如果把不同业务场景的模块代码放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动，从而导致多个业务都无法正常运行。所以我们会<strong>按照功能</strong>将项目进行拆分。</p>
<p>2、按照模块拆分：比如电商的项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期的维护成本就比较高。我们就想能不能将它们公共的部分抽取成一个独立的模块，其他模块要想使用可以像添加第三方jar包依赖一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就说我们所说的<strong>按照模块</strong>拆分。</p>
<p>我们可以将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享：</p>
<img src="image-20230622151943596.png" alt="image-20230622151943596" style="zoom:77%;" />

<p>这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。</p>
<h3 id="分模块开发实现"><a href="#分模块开发实现" class="headerlink" title="分模块开发实现"></a>分模块开发实现</h3><p>这里就基于SSM整合的项目来实现对项目的拆分。</p>
<p><strong>环境准备</strong>（之前ssm整合的框架）</p>
<img src="image-20230622160806750.png" alt="image-20230622160806750" style="zoom:77%;" />

<h4 id="抽取domain层"><a href="#抽取domain层" class="headerlink" title="抽取domain层"></a>抽取domain层</h4><p>步骤1：创建新模块maven_03_pojo</p>
<p>步骤2：项目中创建domain包，将Book实体类复制进来</p>
<p>步骤3：删除原项目(maven_02_ssm)中的domain包</p>
<p><img src="image-20230622161341910.png" alt="image-20230622161341910"></p>
<p>这时在原项目中用到Book实体类的地方都会出现报错。<strong>解决问题的办法是在maven_02_ssm中添加maven_03_pojo的依赖。</strong></p>
<p>步骤4：建立依赖关系</p>
<p>在maven_02_ssm项目的pom.xml添加maven_03_pojo的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤5：编译maven_02_ssm模块</p>
<p>这时虽然不再报错了，但是不意味着程序可以正常运行。报错提醒我们在maven_02_ssm模块中找不到maven_03_pojo的jar包：</p>
<p><img src="image-20230622163816397.png" alt="image-20230622163816397"></p>
<p>那么为什么找不到呢？因为Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包，所以我们需要手动将maven_03_pojo项目安装到本地仓库即</p>
<p>可。</p>
<p>步骤6：将项目安装到本地仓库</p>
<p><img src="image-20230622164033568.png" alt="image-20230622164033568"></p>
<p>此时maven_02_ssm模块就可以编译成功了。</p>
<h4 id="抽取dao层"><a href="#抽取dao层" class="headerlink" title="抽取dao层"></a>抽取dao层</h4><p>步骤1：创建新模块并在项目中创建dao包</p>
<p><img src="image-20230622164526229.png" alt="image-20230622164526229"></p>
<p>这时候存在两个问题：</p>
<p>1）实体类Book类不存在：添加maven_03_pojo的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）Mybatis在dao层的增删改查注解无法识别：添加mybatis和mysql依赖</p>
<p><img src="image-20230622164827822.png" alt="image-20230622164827822"></p>
<p>步骤2：删除原项目(maven_02_ssm)的dao包，添加maven_04_dao的依赖</p>
<h4 id="分模块开发总结"><a href="#分模块开发总结" class="headerlink" title="分模块开发总结"></a>分模块开发总结</h4><p>1、创建Maven模块</p>
<p>2、书写模块代码</p>
<p>分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</p>
<p>3、通过maven指令安装模块到本地仓库(install 指令)</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>依赖指当前项目运行所需的jar，一个项目可以设置多个依赖。在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用标签来进行jar包的引入即可。</p>
<p>依赖的格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">	<span class="comment">&lt;!--设置具体的依赖--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!--依赖所属群组id--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--依赖所属项目id--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--依赖版本号--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="依赖传递与依赖冲突问题"><a href="#依赖传递与依赖冲突问题" class="headerlink" title="依赖传递与依赖冲突问题"></a>依赖传递与依赖冲突问题</h3><p><strong>依赖传递</strong></p>
<p>这个jar包下面还包含有其他的jar包：</p>
<p><img src="image-20230622165753892.png" alt="image-20230622165753892"></p>
<p>会发现有两个maven_03_pojo的依赖被加载到Dependencies中，那么maven_04_dao中的maven_03_pojo能不能使用呢？答案是可以的。</p>
<img src="image-20230622165918814.png" alt="image-20230622165918814" style="zoom:67%;" />

<p>A依赖了B和C，B和C又分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递。</p>
<blockquote>
<p>依赖传递有直接依赖和间接依赖（相对的概念）：相对于A来说，A直接依赖B和C，间接依赖了D1,E1,G,F,D2和E2。</p>
</blockquote>
<p><strong>依赖冲突</strong></p>
<p>因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题。这里所说的<strong>依赖冲突</strong>是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p>
<p>情况一：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</p>
<p><img src="image-20230622170145521.png" alt="image-20230622170145521"></p>
<p>情况二：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高。</p>
<p>情况三：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。</p>
<p>​    关于依赖冲突的规则我们不需要记住，可以在面板上查看详细的依赖关系包括版本信息等：</p>
<img src="image-20230622170357301.png" alt="image-20230622170357301" style="zoom:77%;" />

<h3 id="可选依赖和排除依赖"><a href="#可选依赖和排除依赖" class="headerlink" title="可选依赖和排除依赖"></a>可选依赖和排除依赖</h3><p>maven_02_ssm 依赖了 maven_04_dao，maven_04_dao 依赖了 maven_03_pojo，因为现在有依赖传递，所以maven_02_ssm能够使用到maven_03_pojo的内容。但是如果说现在不想让maven_02_ssm依赖到maven_03_pojo，有哪些解决方案?</p>
<img src="image-20230622170710475.png" alt="image-20230622170710475" style="zoom:67%;" />

<p><strong>方案一：可选依赖</strong></p>
<p>可选依赖指对外隐藏当前所依赖的资源。</p>
<p>对于我们的需求是：不想让maven_02_ssm依赖到maven_03_pojo。我们可以在maven_04_dao的pom.xml中在引入maven_03_pojo的时候，添加<code>optional</code>从而切断依赖传递。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二：排除依赖</strong></p>
<p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。</p>
<p>前面我们已经通过可选依赖实现了阻断maven_03_pojo的依赖传递。对于排除依赖，则是maven_02_ssm项目中已经通过依赖传递用到了maven_03_pojo，此时我们需要做的是将其进行排除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.Lijiacheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>A依赖B，B依赖C，C通过依赖传递会被A使用到，现在要想办法让A不去依赖C：</p>
<ul>
<li><p>可选依赖是在B上设置<code>&lt;optional&gt;</code>， A不知道有C的存在；</p>
</li>
<li><p>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>，A知道有C的存在，主动将其排除掉。</p>
</li>
</ul>
<h2 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><img src="image-20230622213742753.png" alt="image-20230622213742753" style="zoom:67%;" />

<p>缺点一：分模块开发后，需要将这几个项目都安装到本地仓库，目前我们只能通过项目Maven面板的install来安装，并且需要安装多个，如果我们的项目足够多，那么一个个安装起来还是比较麻烦的。</p>
<p>缺点二：如果几个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他项目模块，我们需要对所有的模块进行重新编译。</p>
<p>解决方案：所以我们就想能不能抽取一个项目，把所有的项目管理起来，以后我们要想操作这些项目，只需要操作这一个项目，这就用到了我们接下来要讲解的<strong>聚合</strong>——将多个模块组织成一个整体，同时进行项目构建的过程称为聚合。聚合工程通常是一个不具有业务功能的空工程（有且仅有一个pom文件）。</p>
<p>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</p>
<p>步骤1：创建一个空的Maven工程</p>
<p>步骤2：将项目的打包方式改为<strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前我们接触到的项目打包方式有三种：</p>
<p>① jar：默认情况，说明该项目为java项目； ② war：说明该项目为web项目； ③ pom：说明该项目为聚合或继承项目。</p>
</blockquote>
<p>步骤3：pom.xml添加所要管理的项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤4：使用聚合统一管理项目</p>
<p><img src="image-20230623093529641.png" alt="image-20230623093529641"></p>
<p>测试发现，当maven_01_parent的compile被点击后，所有被其管理的项目都会被执行编译操作，这就是聚合工程的作用。</p>
<blockquote>
<p><strong>说明：</strong>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序，和配置的顺序无关。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>接下来我们再来考虑多模块开发存在的另外一个问题，依赖的重复配置。</p>
<p>问题一：spring-webmvc、spring-jdbc在三个项目模块中都有出现，这样就出现了重复的内容；</p>
<p>问题二：spring-test只在部分项目模块中出现，而在某些项目模块中没有出现，这里是部分重复的内容；</p>
<p>问题三：我们使用的spring版本目前是5.2.24.RELEASE ,假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高。</p>
<p>面对上面的这些问题，我们就得用到接下来要学习的<strong>继承</strong>（简化配置、减少版本冲突）：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p>
<p>步骤1：创建一个空Maven工程并将打包方式设置为<code>pom</code></p>
<p>步骤2：在子项目中设置其父项目</p>
<blockquote>
<p>java里面的继承，也是在子类声明它继承的父类。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可选项：设置父项目pom.xml位置路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤3：优化子项目共有依赖导入问题</p>
<p>1）将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中 </p>
<p>2）删除子项目中已经被抽取到父项目的pom.xml中的jar包，如在maven_02_ssm的pom.xml中将已经出现在父项目的jar包删除掉</p>
<p>将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。</p>
<p>步骤4：优化子项目依赖版本问题</p>
<p>如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。</p>
<p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p>
<p>在父工程mavne_01_parent的pom.xml来定义依赖管理<code>&lt;dependencyManagement&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖。<font color="blue">子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code> </font>。</p>
<blockquote>
<p>这样做的好处就是当父工程dependencyManagement标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化。</p>
</blockquote>
<p><strong>继承总结</strong>：父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</p>
<p>1）将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发</p>
<p>2）将所有项目的jar包配置到父工程的dependencyManagement标签下，实现版本管理，方便维护</p>
<h3 id="聚合和继承的区别"><a href="#聚合和继承的区别" class="headerlink" title="聚合和继承的区别"></a>聚合和继承的区别</h3><h4 id="聚合和继承的区别-1"><a href="#聚合和继承的区别-1" class="headerlink" title="聚合和继承的区别"></a>聚合和继承的区别</h4><p>聚合用于快速构建项目，对项目进行管理；继承用于快速配置和管理子项目中所使用jar包的版本。</p>
<ul>
<li><p>聚合和继承的相同点</p>
<ul>
<li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li>
<li>聚合与继承均属于设计型模块，并无实际的模块内容</li>
</ul>
</li>
<li><p>聚合和继承的不同点</p>
<ul>
<li>聚合是在当前模块中配置关系<code>&lt;modules&gt;</code>，聚合可以感知到参与聚合的模块有哪些</li>
<li>继承是在子模块中配置关系<code>&lt;parent&gt;</code>，父模块无法感知哪些子模块继承了自己</li>
</ul>
</li>
</ul>
<h4 id="IDEA构建聚合与继承工程"><a href="#IDEA构建聚合与继承工程" class="headerlink" title="IDEA构建聚合与继承工程"></a>IDEA构建聚合与继承工程</h4><p>步骤1：创建一个空的Maven项目，可以将项目中的src目录删除掉，这个项目作为聚合工程和父工程</p>
<p>步骤2：创建子项目，该项目可以继承并聚合父工程。</p>
<img src="image-20230623101441961.png" alt="image-20230623101441961" style="zoom:77%;" />

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>如果我们现在想更新Spring的版本，你会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。我们可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方，就会跟着修改。</p>
<img src="image-20230623120509297.png" alt="image-20230623120509297" style="zoom:67%;" />

<p>步骤1：父工程中定义属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤2：修改依赖的version</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<p>我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护。</p>
<h3 id="配置文件的属性加载"><a href="#配置文件的属性加载" class="headerlink" title="配置文件的属性加载"></a>配置文件的属性加载</h3><p>想让Maven对于属性的管理范围能更大些，比如我们之前项目中的jdbc.properties，这个配置文件中的属性，能不能也来让Maven进行管理呢？</p>
<p>步骤1：父工程定义属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤2：jdbc.properties文件中引用属性</p>
<p>在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.url</span>=<span class="string">$&#123;jdbc.url&#125;</span></span><br></pre></td></tr></table></figure>

<p>步骤3：设置maven过滤文件范围</p>
<p>Maven在默认情况下是从当前项目的”src\main\resources”下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置maven过滤文件范围 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>../maven_02_ssm/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤4：测试是否生效</p>
<p>测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为父工程中Maven配置的内容。</p>
<p><img src="image-20230623125438205.png" alt="image-20230623125438205"></p>
<p>如果不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢？</p>
<p>方式一：使用多个<code>&lt;resource&gt;</code>标签在下面继续配置；</p>
<p>方式二：<code>$&#123;project.basedir&#125;</code>，当前项目所在目录。子项目继承了父项目， 相当于所有的子项目都添加了资源目录的过滤：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置maven过滤文件范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- &lt;directory&gt;../maven_02_ssm/src/main/resources&lt;/directory&gt;--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main.resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面我们所使用的都是Maven的自定义属性，除了<code>$&#123;project.basedir&#125;</code>，它属于Maven的内置系统属性。</p>
</blockquote>
<h2 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h2><h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><img src="image-20230623130112191.png" alt="image-20230623130112191" style="zoom:67%;" />

<p>不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，要想实现不同环境之间的配置切换又该如何来实现呢？</p>
<p>Maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。</p>
<p>步骤1：父工程配置多个环境，并指定默认激活环境：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多开发环境配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开发环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生产环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢?</p>
<p>步骤2：命令行实现环境切换（这里我反正是测试失败了。。。）</p>
<img src="image-20230623132355560.png" alt="image-20230623132355560" style="zoom:77%;" />

<h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>前面在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test，对于test来说有它存在的意义：可以确保每次打包或者安装的时候，程序的正确性。但是有时候，功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</p>
<p>方式一：IDEA工具</p>
<p><img src="image-20230623132550500.png" alt="image-20230623132550500"></p>
<p>方式二：命令行跳过测试</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mvn 指令 <span class="literal">-D</span> skipTests</span><br></pre></td></tr></table></figure>

<p>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</p>
<h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><p>公司或者团队一般会搭建自己的私服，这里暂时先不展开实践了，就简单了解一下什么是私服以及配置私服的原理。</p>
<img src="image-20230623132904112.png" alt="image-20230623132904112" style="zoom:67%;" />

<p>Maven的中央仓库不允许私人上传自己的jar包，那么自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用。私服就是公司内部搭建的用于存储Maven资源的服务器，用于解决团队内部的资源共享与资源同步问题。</p>
<p>搭建Maven私服的方式有很多，其中一种使用量比较大的实现方式：Nexus。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Algorithm01 数组</title>
    <url>/2022/12/18/algorithm01/</url>
    <content><![CDATA[<p>说在前面：之前刷题都没有按照知识点分类整理过，最近在网上看到推荐<strong>代码随想录</strong>的算法讲义，就想按照他的推荐系统的把算法这一块拾起来，在自己的博客里做一个记录，也当做日后自己复习的笔记了。</p>
<span id="more"></span>

<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p>数组是非常基础的数据结构。</p>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>首先要知道数组在内存中的存储方式：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>数组可以方便的通过下标索引的方式获取到下标下对应的数据，举一个字符数组的例子，如图所示：</p>
<img src="pic1.png" alt="img" style="zoom:80%;" />

<blockquote>
<p>需要两点注意的是：</p>
<ul>
<li><strong>数组下标都是从0开始的</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
</blockquote>
<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p>
<img src="pic2.png" alt="img" style="zoom:67%;" />

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><blockquote>
<p> Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。</p>
</blockquote>
<p>在 <em>Java</em> 当中，<strong>二维数组</strong>的存储空间实际上并不是连续的，而是这样的：</p>
<p><img src="pic3.png" alt="img"></p>
<p><strong>一维数组</strong>在堆上连续的内存空间直接存储值，<strong>二维数组</strong>在连续的地址上存储一维数组的引用地址，一维数组与一维数组并不一定靠在一起，但是这些一维数组内部的值是在连续地址上的。更高维的数组继续以此类推，只有最后一维数组在连续地址上保存值，其他纬度均在连续地址上保存下一维度的引用地址。</p>
<p>可以通过代码验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_arr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的地址为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[I@36baf30c</span><br><span class="line">[I@7a81197d</span><br><span class="line">[I@5ca881b5</span><br><span class="line">[I@24d46ca6</span><br></pre></td></tr></table></figure>

<p>这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="704、二分查找"><a href="#704、二分查找" class="headerlink" title="704、二分查找"></a>704、二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">题目链接</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1        </span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>你可以假设 nums 中的所有元素是不重复的。</li>
<li>n 将在 [1, 10000]之间。</li>
<li>nums 的每个元素都将在 [-9999, 9999]之间。</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong></p>
<ul>
<li><code>while (left &lt;= right)</code> 要使用 &lt;= ，因为<code>left == right</code>是有意义的，所以使用 &lt;=</li>
<li><code>if (nums[middle] &gt; target)</code>  right 要赋值为 middle - 1，因为当前这个<code>nums[middle]</code>一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h4><ul>
<li><p><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></p>
</li>
<li><p><strong><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 寻找左边界</span></span><br><span class="line">        ans[<span class="number">0</span>] = findLeftIndex(nums,target);</span><br><span class="line">        <span class="comment">// 寻找右边界</span></span><br><span class="line">        ans[<span class="number">1</span>] = findRightIndex(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLeftIndex</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">                ans=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRightIndex</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">                ans=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://leetcode.cn/problems/sqrtx/">69.x 的平方根</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/valid-perfect-square/">367.有效的完全平方数</a></p>
</li>
</ul>
<h3 id="27、移除元素（双指针）"><a href="#27、移除元素（双指针）" class="headerlink" title="27、移除元素（双指针）"></a>27、移除元素（双指针）</h3><p><a href="https://leetcode.cn/problems/remove-element/">题目链接</a></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p>示例 2: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p>
<p>思路1：</p>
<p>因为数组中的元素大小都在0~50之间，而且不计返回新数组的元素顺序，可以把数组中元素等于<code>val</code>的值设为一个大于50的值，然后对原数组sort操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 与val相同的元素数</span></span><br><span class="line">        <span class="keyword">if</span>(val &gt; <span class="number">50</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                nums[i] = <span class="number">100</span>;   <span class="comment">// 一个不可能在nums中出现的数</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> len-count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：</p>
<p>两个for循环的暴力法——第一个for遍历每个元素，第二个for将数组中元素等于val的值之后的元素前移一位。</p>
<p><img src="pic4.gif" alt="27.移除元素-暴力解法"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)&#123;  </span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                i--; <span class="comment">// 因为i以及之后的元素都向前移动了一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路3：</strong></p>
<p>快慢指针法：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新新数组下标的位置</li>
</ul>
<p><img src="pic5.gif" alt="27.移除元素-双指针法"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> leftIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> rightIndex=<span class="number">0</span>;rightIndex&lt;nums.length;rightIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[rightIndex]==val)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[leftIndex++]=nums[rightIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftIndex;  <span class="comment">// 新数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：第一种思路改变了元素的相对位置，而暴力法和快慢指针法并没有改变新数组元素之间的相对位置。</p>
</blockquote>
<h4 id="相关题目推荐-1"><a href="#相关题目推荐-1" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h4><p>双指针有两种，一种是同侧的快慢指针，一种是异侧的双指针，要注意使用的情景。使用双指针往往能将暴力法<code>O(n^2)</code>的时间复杂度降到<code>O(n)</code>。</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除排序数组中的重复项</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串</a>  </p>
</li>
<li><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方</a></p>
</li>
</ul>
<h3 id="977、有序数组的平方"><a href="#977、有序数组的平方" class="headerlink" title="977、有序数组的平方"></a>977、有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目链接</a></p>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>思路1：排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度<code>O(nlogn)</code></li>
</ul>
<p>思路2：双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ans.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left] &gt;= nums[right]*nums[right])&#123;</span><br><span class="line">                ans[i] = nums[left]*nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = nums[right]*nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度<code>O(n)</code></li>
</ul>
<h3 id="209、长度最小的子数组"><a href="#209、长度最小的子数组" class="headerlink" title="209、长度最小的子数组"></a>209、长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 <code>≥ target </code> 的长度最小的 <strong>连续子数组</strong> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>思路1：暴力解法 – 据说后面更新了题目数据用例，暴力解法已经超时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MinCount</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    MinCount = MinCount&gt;count ? count : MinCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MinCount = MinCount==Integer.MAX_VALUE ? <span class="number">0</span> : MinCount;</span><br><span class="line">        <span class="keyword">return</span> MinCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：滑动窗口</p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p>
<p>那么滑动窗口如何用一个for循环来完成这个操作呢？</p>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。在快慢指针中，我们用for循环记录快指针的索引，其实滑动窗口本质上也是一种双指针，只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>所以我们用一个for循环，那么应该表示 滑动窗口的<strong>终止位置</strong>。</p>
<ul>
<li><p>窗口就是： 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
</li>
<li><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
</li>
<li><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p>
</li>
</ul>
<p>解题的关键在于 <strong>窗口的起始位置</strong> 如何移动，如图所示：</p>
<img src="pic6.png" alt="leetcode_209" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length; </span><br><span class="line">       <span class="type">int</span> slowIndex=<span class="number">0</span>,fastIndex;</span><br><span class="line">       <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">       <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(fastIndex=<span class="number">0</span>;fastIndex&lt;len;fastIndex++)&#123;</span><br><span class="line">           sum += nums[fastIndex];</span><br><span class="line">           <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">               result = result &lt; fastIndex-slowIndex+<span class="number">1</span> ? result : fastIndex-slowIndex+<span class="number">1</span>;</span><br><span class="line">               sum -= nums[slowIndex];</span><br><span class="line">               slowIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">return</span> <span class="variable">result</span> <span class="operator">=</span> result==Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于时间复杂度是<code>O(n)</code>的一些疑问——</p>
<p>不要以为for里放一个while就以为是<code>O(n^2)</code>啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是<code>O(n)</code>。</p>
</blockquote>
<h4 id="相关题目推荐-2"><a href="#相关题目推荐-2" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h4><ul>
<li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮</a>   </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超时？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MaxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftIndex=<span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; kind = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> rightIndex=<span class="number">0</span>;rightIndex&lt;fruits.length;rightIndex++)&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            kind.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=leftIndex;i&lt;=rightIndex;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(kind.size()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                    leftIndex++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                kind.add(fruits[i]);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            MaxCount = MaxCount&lt;count ? count : MaxCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Right Answer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> fruits.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            cnt.put(fruits[right], cnt.getOrDefault(fruits[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                cnt.put(fruits[left], cnt.get(fruits[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(fruits[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></strong></li>
</ul>
<blockquote>
<p><strong>Java中String和char的相互转换：</strong></p>
<p>String转换成char：</p>
<ol>
<li>使用<code>String.charAt(index)</code>（返回值为char）可以得到String中某一指定位置的char。</li>
<li>使用<code>String.toCharArray()</code>（返回值为char[]）可以得到将包含整个String的char数组。这样我们就能够使用从0开始的位置索引来访问string中的任意位置的元素。</li>
</ol>
<p>char转换成String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//效率最高的方法</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;c&#x27;</span>&#125;); <span class="comment">//将一个char数组转换成String</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Character.toString(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Character.toString(char)方法实际上直接返回String.valueOf(char)</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;c&#x27;</span>).toString();</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="comment">// 虽然这个方法很简单，但这是效率最低的方法</span></span><br><span class="line"><span class="comment">// Java中的String Object的值实际上是不可变的，是一个final的变量。</span></span><br><span class="line"><span class="comment">// 所以我们每次对String做出任何改变，都是初始化了一个全新的String Object并将原来的变量指向了这个新String。</span></span><br><span class="line"><span class="comment">// 而Java对使用+运算符处理String相加进行了方法重载。</span></span><br><span class="line"><span class="comment">// 字符串直接相加连接实际上调用了如下方法：</span></span><br><span class="line"><span class="comment">// new StringBuilder().append(&quot;&quot;).append(&#x27;c&#x27;).toString();</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;c&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="59-螺旋矩阵II（模拟）"><a href="#59-螺旋矩阵II（模拟）" class="headerlink" title="59.螺旋矩阵II（模拟）"></a>59.螺旋矩阵II（模拟）</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">题目链接</a></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p>示例1：</p>
<p><img src="pic7.png" alt="1242D48E-772B-4C40-BE9E-CB05A136147C"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>模拟顺时针画矩阵的过程:</p>
<p>① 填充上行从左到右  ② 填充右列从上到   ③ 填充下行从右到左   ④ 填充左列从下到上</p>
<p>一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的<strong>左闭右开</strong>的原则，这样这一圈才能按照统一的规则画下来。</p>
<img src="pic8.png" alt="image-20221220165427845" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 填充的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 每一轮循环开始的位置</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop++ &lt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 模拟从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(j=start;j&lt;n-loop;j++)&#123;</span><br><span class="line">                ans[start][j]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(i=start;i&lt;n-loop;i++)&#123;</span><br><span class="line">                ans[i][j]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟从右到左</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;=loop;j--)&#123;</span><br><span class="line">                ans[i][j]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟从下到上</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;=loop;i--)&#123;</span><br><span class="line">                ans[i][start]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// n是奇数 -- 中间置位</span></span><br><span class="line">            ans[n/<span class="number">2</span>][n/<span class="number">2</span>]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关题目推荐-3"><a href="#相关题目推荐-3" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h4><ul>
<li><a href="https://leetcode.cn/problems/spiral-matrix/">54.螺旋矩阵</a></li>
<li><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/?favorite=xb9nqhhg">剑指Offer 29.顺时针打印矩阵</a></li>
</ul>
<h2 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h2><p>回顾一下数组的四种经典题型，每一种题型都对应着一种思想。</p>
<h3 id="数组必会知识"><a href="#数组必会知识" class="headerlink" title="数组必会知识"></a>数组必会知识</h3><p>1、在《Java核心技术》中对数组的定义是：<strong>一种可以用来存储同一类型值的集合。</strong></p>
<p>2、数组的内存空间分配：</p>
<ul>
<li>一维数组：存放在连续内存空间上</li>
<li>二维（高维）数组：最后一个维度的元素存放在连续的内存空间上</li>
</ul>
<p>3、数组不能删除单一元素，只能覆盖。</p>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。</p>
<p>可以使用暴力解法，如果追求更优的算法，建议试一试用二分法，来解决这道题目。</p>
<ul>
<li>暴力解法时间复杂度：<code>O(n)</code></li>
<li>二分法时间复杂度：<code>O(logn)</code></li>
</ul>
<p><strong>二分法是算法面试中的常考题，建议吃透上面列举的二分题目，锻炼自己手撕二分的能力</strong>。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<ul>
<li>暴力解法时间复杂度：<code>O(n^2)</code></li>
<li>双指针时间复杂度：<code>O(n)</code></li>
</ul>
<p>这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：</p>
<ul>
<li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放。</li>
</ul>
<p>双指针法（快慢指针法）在<strong>数组和链表</strong>的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>本题介绍了数组操作中的另一个重要思想：滑动窗口。</p>
<ul>
<li>暴力解法时间复杂度：<code>O(n^2)</code></li>
<li>滑动窗口时间复杂度：<code>O(n)</code></li>
</ul>
<p>本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p>
<p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p>
<p>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p>
<h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p>模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。</p>
<p>相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实<strong>真正解决题目的代码都是简洁的，或者有原则性的</strong>，大家可以在这道题目中体会到这一点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA中集成git</title>
    <url>/2023/06/30/IDEA%E4%B8%AD%E9%9B%86%E6%88%90git/</url>
    <content><![CDATA[<p>这篇博客主要记录git的常用命令以及在IDE中集成git简化版本控制操作。</p>
<span id="more"></span>

<p>git安装以及更新（macOS）：<a href="https://docs.brew.sh/Installation">安装Homebrew</a></p>
<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="git全局设置"><a href="#git全局设置" class="headerlink" title="git全局设置"></a>git全局设置</h3><ul>
<li><p>git版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;KiCheng&quot;</span><br><span class="line">git config --global user.email &quot;lijiacehng053@gmail.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>查看配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h3><ul>
<li><p>在本地初始化一个git仓库（不常用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li><p>从远程仓库克隆（常用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone [URL]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h3><ul>
<li><p>查看文件状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li><p>将文件的修改加入暂存区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [文件名] / git add .</span><br></pre></td></tr></table></figure></li>
<li><p>将暂存区的文件取消暂存或者是切换到指定版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset [文件名] / git reset .</span><br><span class="line">git reset --hard [版本号]</span><br></pre></td></tr></table></figure></li>
<li><p>将暂存区的文件修改提交到本地版本库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;[注释内容]&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><ul>
<li><p>查看远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote / git remote -v</span><br></pre></td></tr></table></figure></li>
<li><p>连接到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add [远程仓库名(通常是origin)] [URL]</span><br></pre></td></tr></table></figure></li>
<li><p>从远程仓库克隆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone [URL]</span><br></pre></td></tr></table></figure></li>
<li><p>从远程仓库拉取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull [远程仓库名] [分支名]</span><br></pre></td></tr></table></figure></li>
<li><p>推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [远程仓库名] [分支名]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul>
<li><p>查看分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li>
<li><p>创建分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch [分支名]</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout [分支名]</span><br></pre></td></tr></table></figure></li>
<li><p>推送至远程仓库分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [远程仓库名] [分支名]</span><br></pre></td></tr></table></figure></li>
<li><p>合并分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge [分支名]</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>分支合并时冲突：手动处理合并冲突再重新<code>add</code> +<code> commit -i</code>.</p>
</blockquote>
<h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><ul>
<li><p>列出已有标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li>
<li><p>创建标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag [标签名]</span><br></pre></td></tr></table></figure></li>
<li><p>将标签推送至远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag [远程仓库名] [标签名]</span><br></pre></td></tr></table></figure></li>
<li><p>创建新分支检出标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b [新建分支名] [标签名]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="IDEA中集成git"><a href="#IDEA中集成git" class="headerlink" title="IDEA中集成git"></a>IDEA中集成git</h2><img src="image-20230630182031051.png" alt="image-20230630182031051" style="zoom:77%;" />

<h3 id="获取本地仓库-1"><a href="#获取本地仓库-1" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h3><h4 id="方法一：本地初始化仓库"><a href="#方法一：本地初始化仓库" class="headerlink" title="方法一：本地初始化仓库"></a>方法一：本地初始化仓库</h4><img src="image-20230630182255719.png" alt="image-20230630182255719" style="zoom:77%;" />

<p>路径选择IDE中的demo目录即可。</p>
<h4 id="方法二：从远程仓库克隆"><a href="#方法二：从远程仓库克隆" class="headerlink" title="方法二：从远程仓库克隆"></a>方法二：从远程仓库克隆</h4><p><img src="image-20230630182549048.png" alt="image-20230630182549048"></p>
<p><img src="image-20230630182656435.png" alt="image-20230630182656435"></p>
<h3 id="本地仓库操作-1"><a href="#本地仓库操作-1" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h3><ul>
<li><p>将文件加入暂存区</p>
<p>IDEA会弹出提示框，自动把新建或修改的文件add到暂存区，也可以手动添加。</p>
</li>
</ul>
<blockquote>
<p>未加入暂存区的文件是红色的，加入暂存区的文件是绿色的：</p>
<p><img src="image-20230630183314045.png" alt="image-20230630183314045"></p>
</blockquote>
<ul>
<li>将暂存区的文件提交到版本库</li>
</ul>
<p>​                                        <img src="image-20230630183737356.png" alt="image-20230630183737356" style="zoom: 50%;" /></p>
<ul>
<li>查看日志</li>
</ul>
<p><img src="image-20230630184053887.png" alt="image-20230630184053887"></p>
<h3 id="远程仓库操作-1"><a href="#远程仓库操作-1" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><ul>
<li>查看并添加远程仓库</li>
</ul>
<img src="image-20230630193049503.png" alt="image-20230630193049503" style="zoom:67%;" />

<img src="image-20230630193130607.png" alt="image-20230630193130607" style="zoom:87%;" />

<ul>
<li>推送至远程仓库</li>
</ul>
<img src="image-20230630184015304.png" alt="image-20230630184015304" style="zoom:77%;" />

<ul>
<li>从远程仓库拉取</li>
</ul>
<h3 id="分支操作-1"><a href="#分支操作-1" class="headerlink" title="分支操作"></a>分支操作</h3><p><img src="image-20230630193635799.png" alt="image-20230630193635799"></p>
<ul>
<li><p>将分支推送到远程仓库</p>
<img src="image-20230630193920080.png" alt="image-20230630193920080" style="zoom:87%;" /></li>
<li><p>合并分支</p>
</li>
</ul>
<img src="image-20230630194033825.png" alt="image-20230630194033825" style="zoom:80%;" />
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm02 哈希表</title>
    <url>/2022/12/21/algorithm02/</url>
    <content><![CDATA[<p>说在前面：之前刷题都没有按照知识点分类整理过，最近在网上看到推荐<strong>代码随想录</strong>的算法讲义，就想按照他的推荐系统的把算法这一块拾起来，在自己的博客里做一个记录，也当做日后自己复习的笔记了。</p>
<span id="more"></span>

<h2 id="哈希表基础知识"><a href="#哈希表基础知识" class="headerlink" title="哈希表基础知识"></a>哈希表基础知识</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表（或散列表），是根据关键码的值而直接进行访问的数据结构。</p>
<p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>例如要查询一个名字是否在这所学校里：要枚举的话时间复杂度是<code>O(n)</code>，但如果使用哈希表的话， 只需要<code>O(1)</code>就可以做到。</p>
<p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p>
<p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p>
<p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032313031303432333438343831382e706e67.png" alt="哈希函数" style="zoom:67%;" />

<p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p>
<p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p>
<p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p>
<p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p>
<h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>对不同的关键字可能得到同一哈希地址，即<strong>key1≠key2，而h(key1)=h(key2)</strong> ，这种现象称为<strong>冲突</strong>（collision）。</p>
<p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032313031303432333439343838342e706e67.png" alt="哈希表3" style="zoom:67%;" />

<p>解决哈希碰撞的方案有很多，常用的有两种——<strong>拉链法</strong>和<strong>线性探测法</strong>。</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>发生冲突的元素都被存储在链表中。</p>
<p>要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130343233353031353232362e706e67.png" alt="哈希表4" style="zoom:67%;" />



<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>使用线性探测法，<strong>一定要保证tableSize大于dataSize</strong>。 我们需要依靠哈希表中的空位来解决碰撞问题。</p>
<p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130343233353130393935302e706e67.png" alt="哈希表5" style="zoom:67%;" />

<h3 id="Set和List的区别"><a href="#Set和List的区别" class="headerlink" title="Set和List的区别"></a>Set和List的区别</h3><ul>
<li>1、<strong>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</strong></li>
<li>2、Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。</li>
<li>3、List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。</li>
</ul>
<p><strong>遍历ArrayList：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;HAHAHAHA&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用 For-Each 遍历 List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把List变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  for(String str:strArray) 这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。</p>
<p><strong>遍历HashMap：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242.有效的字母异位词</a></h3><p><img src="image-20230115210900748.png" alt="image-20230115210900748"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1、利用数组的特性排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] char_s = stringToChar(s);</span><br><span class="line">        <span class="type">char</span>[] char_t = stringToChar(t);</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(char_s,char_t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] stringToChar(String str)&#123;</span><br><span class="line">        <span class="type">char</span>[] CharStr = str.toCharArray();</span><br><span class="line">        Arrays.sort(CharStr);</span><br><span class="line">        <span class="keyword">return</span> CharStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>知识点：</strong></p>
<p>1、String.toCharArray()可以将String类型转换成char数组，此操作通常用用来对String字符串中每个字符进行排序操作。</p>
<p>2、Arrays.equals(a,b)用来比较两个数组的元素是否完全对应相同。</p>
</blockquote>
<p>2、哈希表解法</p>
<p>（1）<strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p>
<p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。</p>
<p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p>
<p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做 +1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong> 这样就将字符串s中字符出现的次数，统计出来了。</p>
<img src="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3234322e2545362539432538392545362539352538382545372539412538342545352541442539372545362541462538442545352542432538322545342542442538442545382541462538442e676966.gif" alt="242.有效的字母异位词"  />

<p>那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做 -1 的操作。</p>
<p>那么最后检查一下，record数组如果有的元素不为0，说明字符串s和t一定是谁多了字符或者谁少了字符，<code>return false</code>；如果元素全部为0，则<code>return true</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">      <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">          record[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t.length();j++)&#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(j);</span><br><span class="line">          record[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">26</span>;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(record[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为<code>O(n)</code>，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为<code>O(1)</code>。</p>
<p>（2）HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s_str</span> <span class="operator">=</span> String.valueOf(s.charAt(i));</span><br><span class="line">            map.put(s_str,map.getOrDefault(s_str,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t.length();j++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">t_str</span> <span class="operator">=</span> String.valueOf(t.charAt(j));</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(t_str))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(t_str);</span><br><span class="line">                value--;</span><br><span class="line">                map.replace(t_str,value);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 最后map的所有value应该都是0</span></span><br><span class="line">       <span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">           <span class="keyword">if</span>(map.get(key)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String.valueOf(char)将char字符类型转换成String类型，这个操作通常在哈希中比较常见，因为char类型不能作为HashMap、HashSet的泛型数据类型。</p>
<p>熟悉一下<strong>HashMap的主要函数</strong>：</p>
<p>(1) 查找是否存在key关键字：map.containsKey(key)</p>
<p>(2) 查找是否存在value键值对的值：map.containsValue(value)</p>
<p>(3) 获取key对应的value值：map.get(key)</p>
<p>(4) get函数进阶版，如果map中没有key关键字，就添加key关键字并赋值value：map.getOrDefault(key,value)</p>
<p>(5) 替换map中的value：map.replace(key,value)</p>
</blockquote>
<h3 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a><a href="https://leetcode.cn/problems/find-common-characters/">1002. 查找常用字符</a></h3><p>给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的<strong>共用字符</strong>（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>为 words 里每一个字符串创建一个长度为26的数组作为哈希表，所以我们new一个大小为 <code>[words.length][26]</code>的二维数组。</p>
<p>找出所有字符串的共用字符，即交集，只需要找出二维数组每一列（代表26个字母）的最小值即可，用一个长度为26的一维数组储存结果。</p>
<img src="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f313030322e2545362539462541352545362538392542452545352542382542382545372539342541382545352541442539372545372541432541362e706e67.png" alt="1002.查找常用字符" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">commonChars</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=words.length;</span><br><span class="line">        ArrayList&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[][] index = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] character = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            String word=words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;word.length();j++)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(j);</span><br><span class="line">                index[i][c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 每一列找最小的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                min=min&lt;index[j][i]?min:index[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">            character[i]=min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(character[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf((<span class="type">char</span>)(i+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                res.add(str);</span><br><span class="line">                character[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java 里面int类型的范围为：-2^31 ~ 2^31-1，表示为—— <strong>Integer.MIN_VALUE、Integer.MAX_VALUE</strong>.</p>
</blockquote>
<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349.两个数组的交集</a></h3><p><img src="image-20230112195548480.png" alt="image-20230112195548480"></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>1、双指针的排序思想</p>
<p>​        因为是求交集，所以<code>while</code>循环的终止条件是两个指针任一个到达最后。因为题目要求答案中的元素是唯一的，所以在两指针指向的元素相同时还要进行一个唯一性判断，也就是说如果这个元素在答案数组中没有出现才能加入进去。</p>
<p><strong>唯一性判断：</strong><code>if(index==0 || nums1[i]!=res[index-1])</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length+nums2.length];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=nums1.length-<span class="number">1</span> &amp;&amp; j&lt;=nums2.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&gt;nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(index==<span class="number">0</span> || nums1[i]!=res[index-<span class="number">1</span>])&#123;</span><br><span class="line">                    res[index++]=nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Arrays.copyOfRange(array,begin,end)：拷贝一个新数组，存储array数组从begin索引到end索引的元素。</p>
</blockquote>
<p>2、用<strong>HashSet</strong>作为哈希结构</p>
<p>​    题目要求答案中的每个元素都是<strong>唯一</strong>的，所以考虑到HashSet的<strong>不重复性</strong>，利用HashSet中的<code>contains()</code>，将符合的集合元素add到答案集合当中，最后再创建答案集合size大小的数组进行存储并输出。</p>
<blockquote>
<p>要注意的是，数组在初始化时要么静态初始化指定每个元素的初始值，系统决定数组的长度；要么动态初始化，指定数组的大小。<strong>所以数组不像ArrayList那样可以随着元素的增多而扩充大小</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = intToSet(nums1);</span><br><span class="line">        Set&lt;Integer&gt; set2 = intToSet(nums2);</span><br><span class="line">        Set&lt;Integer&gt; interset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:set1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set2.contains(num))&#123;</span><br><span class="line">                interset.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[interset.size()];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:interset)&#123;</span><br><span class="line">            res[index++]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Integer&gt; <span class="title function_">intToSet</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、用<strong>HashMap</strong>作为哈希结构</p>
<p>​    key为元素，value为元素出现的次数，遍历<code>nums1</code>存储<code>nums1</code>的元素以及出现的次数；再遍历<code>nums2</code>，如果遍历到的元素在HashMap中<strong>存在且value大于0</strong>，则<code>value-1</code>，并把该元素加入到答案数组当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">           map.put(nums1[i],map.getOrDefault(nums1[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums2.length;j++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums2[j];</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(num);</span><br><span class="line">               count--;</span><br><span class="line">               map.replace(num,count);</span><br><span class="line">               <span class="comment">// 将num元素放到输出的答案数组当中 -- 此时数组的大小不确定，不能直接创建 -- 用set</span></span><br><span class="line">               set.add(num);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">       <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:set)&#123;</span><br><span class="line">           ans[index++] = num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h3><p><img src="image-20230112213141536.png" alt="image-20230112213141536"></p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p>
<p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是<code>return false</code>， 否则一直找到sum为1为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(set.contains(sum))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 说明无限循环了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(sum);</span><br><span class="line">                n = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">            n *= n;</span><br><span class="line">            sum += n;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><p><img src="image-20230113225349418.png" alt="image-20230113225349418"></p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>1、暴力法 时间复杂度<code>O(n^2)</code></p>
<p>2、<strong>HashMap</strong>：考虑到<code>nums</code>中的两数之和等于target，我们可以遍历一次<code>nums</code>，在哈希结构中查找<strong>target - num1</strong>，如果存在<strong>num2</strong>那么就输出num1和num2的数组索引下标。考虑到需要输出数组的索引下标，所以在哈希要存储元素以及对应的数组下标，就用到了<strong>HashMap</strong>。</p>
<p>我们用key存储元素还是存储数组下标呢？我们总结一下如何应用HashMap：遍历<code>nums</code>中的元素，每次在HashMap中进行查找，查找到就返回数组下标，没有查找到就将该元素put到HashMap当中；因为根据元素查找成功后，要通过元素找到对应的数组下标进行返回，而HashMap的Key和Value只有<strong>单向映射关系</strong>，所以key为元素，value为数组下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                <span class="comment">// 查找成功，返回结果</span></span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap将查找的时间复杂度从<code>O(n)</code>降低到<code>O(1)</code>，相较于暴力法，使用哈希查找的算法时间复杂度下降到<code>O(n)</code>。</p>
<h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h3><p><img src="image-20230115110922496.png" alt="image-20230115110922496"></p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>因为只需要输出结果数，不用具体列举每个结果。</p>
<p>①首先定义 一个HashMap，key放a和b两数之和，value 放a和b两数之和出现的次数。</p>
<p>②遍历A和B数组，统计两个数组元素之和，和出现的次数，放到map中。</p>
<p>③定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</p>
<p>④在遍历C和D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</p>
<p>⑤最后返回统计值 count 就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;  <span class="comment">// 统计出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums2.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> nums1[i]+nums2[j];</span><br><span class="line">                map.put(sum1,map.getOrDefault(sum1,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums4.length;j++)&#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> nums3[i] + nums4[j];</span><br><span class="line">                 <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">0</span> - sum2;</span><br><span class="line">                 <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">                     count+=map.get(key);  <span class="comment">// 可以重复</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h3><p><img src="image-20230115130717327.png" alt="image-20230115130717327"></p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>换言之就是判断magazine是否包含ransomNote。因为每个字符只能使用一次，所以在哈希结构中除了要统计字符之外，还要统计该字符出现的次数，使用HashMap。</p>
<p>判断是否包含的条件：如果在HashMap当中<strong>没有该key值或key对应的value值为0</strong>，则不包含。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;magazine.length();i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(magazine.charAt(i));</span><br><span class="line">            map.put(str,map.getOrDefault(str,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ransomNote.length();i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(ransomNote.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(s) || map.get(s)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(s);</span><br><span class="line">            count--;</span><br><span class="line">            map.put(s,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><p><img src="image-20230115131814327.png" alt="image-20230115131814327"></p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>1、哈希解法</p>
<p>​    两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组，<strong>去重很复杂！</strong></p>
<p>2、双指针解法</p>
<p><img src="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f31352e2545342542382538392545362539352542302545342542392538422545352539322538432e676966.gif" alt="15.三数之和"></p>
<p>​    <strong>双指针解法首先将数组进行排序</strong>。求三数之和：外层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p>
<p>​    定义的左右指针，当<code>nums[i]+nums[left]+nums[right]&gt;0</code>时，三数之和需要减小，故<code>right--</code>;当<code>nums[i]+nums[left]+nums[right]&lt;0</code>时，三数之和需要增大，故<code>left++</code>;当<code>nums[i]+nums[left]+nums[right]==0</code>时，找到答案，<code>left++</code>同时<code>right--</code>。</p>
<p>​    要注意<strong>去重逻辑</strong>：答案要求不能包含重复的三元组。</p>
<p>​    其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]。</p>
<p>​    去重①：a 如果重复了怎么办，a 是nums里遍历的元素，那么应该直接跳过去。<strong>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</strong>这两种写法是否都正确呢？</p>
<p>如果我们的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123; <span class="comment">// 去重操作</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p>
<p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p>
<p>所以应该这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    去重②：如果b和c重复了怎么办，b和c是设定的左右双指针，去重逻辑应该放在找到一个三元组答案后。在a确定的前提下，b或者c有一个出现重复，则最终得到的三元组也是重复的需要被舍弃的，故直接跳过。同时为了防止数组越界，加入限定条件<code>left&lt;right</code>（如果<code>left&gt;=right</code>，那这一轮双指针循环就已经结束了），这里要多加思考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">   left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right+<span class="number">1</span>])&#123;</span><br><span class="line">   right--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;<span class="number">0</span> || nums[nums.length-<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 去重①</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left=i+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;  <span class="comment">// 不能 &#x27;&lt;=&#x27;</span></span><br><span class="line">                List&lt;Integer&gt; NumList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[left] + nums[right] + nums[i];</span><br><span class="line">                <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    NumList.add(nums[left]);</span><br><span class="line">                    NumList.add(nums[i]);</span><br><span class="line">                    NumList.add(nums[right]);</span><br><span class="line">                    list.add(NumList);</span><br><span class="line">                    right--; left++;</span><br><span class="line">                    <span class="comment">// 去重②</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right+<span class="number">1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加答案可以使用<strong>Arrays.asList()<strong>函数精简成：</strong>result.add(Arrays.asList(nums[i], nums[left], nums[right]));</strong></p>
<p>注意：双指针的while循环条件是<code>left&lt;right</code>，而不是<code>left&lt;=right</code>。</p>
</blockquote>
<p>双指针法的时间复杂度<code>O(n^2)</code>.</p>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3><p><img src="image-20230115173231917.png" alt="image-20230115173231917"></p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>和三数之和思路相同，要多一层for循环。<strong>去重逻辑</strong>仍然是对a、b、c、d四个数分别考虑去重，逻辑比较简单这里就不一一赘述了。</p>
<p>注意这里的一步剪枝操作（本题用例中不剪枝会造成无法通过全部用例）：如果nums中可遍历的最小元素大于0且大于target值，那么无论如何都不会出现四数之和等于target了，所以直接返回结果即可。<strong>（nums[i]&gt;0是否多余？– 如果nums[i]是负数且大于target呢，可以直接剪枝吗？）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span> &amp;&amp; nums[i]&gt;target)&#123;</span><br><span class="line">    <span class="keyword">return</span> AnsList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; AnsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span> &amp;&amp; nums[i]&gt;target)&#123;  <span class="comment">// 剪枝操作</span></span><br><span class="line">                <span class="keyword">return</span> AnsList;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j]==nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[j] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        AnsList.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        left++;  right--;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right+<span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AnsList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【比较】我们可以思考一下，同样是求四个数的和，<a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a>为什么可以使用哈希法解题，而本题更适合用双指针解法呢？其实在上题中已经说过了，就是重复的问题。454题是4个独立的数组，从每一个数组中找出一个元素，答案可以包含所有重复的四元组；本题是在一个数组中，要求四元组不重复，且构成四元组的a、b、c、d互不相同，可想而知使用哈希进行查找得到的答案进行去重会比较繁琐。</p>
<h2 id="哈希表总结"><a href="#哈希表总结" class="headerlink" title="哈希表总结"></a>哈希表总结</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！</p>
<p>这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p>
<p>在<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383.赎金信</a>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！</p>
<p>383题和242题很像，<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>是求 字符串a 和 字符串b 是否可以相互组成，在<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383.赎金信</a>中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。</p>
<p>一些同学可能想，用数组干啥，都用map不就完事了。</p>
<p><strong>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</strong></p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>在<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a>中我们给出了什么时候用数组就不行了，需要用set。</p>
<p>这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p>
<p><strong>主要因为如下两点：</strong></p>
<ul>
<li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li>
<li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li>
</ul>
<p>所以此时一样的做映射的话，就可以使用set了。</p>
<p>在<a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">202.快乐数</a>中，我们再次使用了HashSet来判断一个数是否重复出现过。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>可参考 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></p>
</blockquote>
<p>在<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和</a>中map正式登场。</p>
<p>来说一说：使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>map是一种<code>&lt;key, value&gt;</code>的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p>
<p>在<a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加</a>中我们提到了其实需要哈希的地方都能找到map的身影。</p>
<p>一看好像和<a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18. 四数之和</a>，<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和</a>差不多，其实差很多！</p>
<p><strong>关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而<a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18. 四数之和</a>，<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和</a>是一个数组（集合）里找到和为0的组合，可就难很多了！</strong></p>
<p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p>
<p>在<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和</a>中我给出了哈希法和双指针两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。</p>
<p>所以18. 四数之和，15.三数之和都推荐使用双指针法！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>MybatisPlus</title>
    <url>/2023/07/07/MybatisPlus/</url>
    <content><![CDATA[<p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。使用原生的Mybatis编写持久层逻辑时，所需要的代码是比较繁琐的，需要定义Mapper接口和Mapper.xml文件，每一个方法都需要编写对应的sql语句，会存在很多大量的重复工作，使用MP之后，对通用的方法做了高度的抽取，避免了很多重复工作，可以非常快速的实现了单表的各种增、删、改、查操作。</p>
<span id="more"></span>

<p>博客主要讲解Springboot项目下的MybatisPlus框架的核心功能，详细的可参考MP的<a href="https://baomidou.com/">中文开发文档</a>。</p>
<h2 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h2><ul>
<li><p>创建Springboot工程（在IDEA中集成功能）</p>
<ul>
<li><p>引入 Spring Boot Starter 父工程：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>	 </span><br></pre></td></tr></table></figure></li>
<li><p>引入 <code>spring-boot-starter</code>、<code>spring-boot-starter-test</code>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- web工程也要导入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>引入<code>mybatis-plus-boot-starter</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>引入数据库依赖（在IDEA中集成功能）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 可选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><p><code>@TableName</code>：表名注解，标识实体类对应的表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>@TableId</code>：主键注释，标识实体类主键字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">主键字段名</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">Enum</td>
<td align="center">否</td>
<td align="center">IdType.NONE</td>
<td align="center">指定主键类型</td>
</tr>
</tbody></table>
<ul>
<li><p><code>IdType</code>的属性</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AUTO</td>
<td align="left">数据库 ID 自增</td>
</tr>
<tr>
<td align="left">NONE</td>
<td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td>
</tr>
<tr>
<td align="left">INPUT</td>
<td align="left">insert 前自行 set 主键值</td>
</tr>
<tr>
<td align="left">ASSIGN_ID</td>
<td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td>
</tr>
<tr>
<td align="left">ASSIGN_UUID</td>
<td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认 default 方法)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>@TableField</code>：字段注解（非主键）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>value</code>：数据库字段名</p>
</li>
<li><p><code>fill</code>：字段自动填充策略</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEFAULT</td>
<td align="left">默认不处理</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="left">插入时填充字段</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="left">更新时填充字段</td>
</tr>
<tr>
<td align="left">INSERT_UPDATE</td>
<td align="left">插入和更新时填充字段</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="CRUD-接口"><a href="#CRUD-接口" class="headerlink" title="CRUD 接口"></a>CRUD 接口</h3><h4 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a>Service CRUD 接口</h4><p>通用 Service CRUD 封装 IService 接口，进一步封装 CRUD 采用 <code>get 查询单行</code> ，<code>remove 删除</code>， <code>list 查询集合</code> ，<code>page 分页</code> 前缀命名方式区分 Mapper 层避免混淆。</p>
<ul>
<li><p><code>Save</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;  <span class="comment">// batchSize:插入批次数量</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>SaveOrUpdate</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Remove</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;  <span class="comment">// 主键ID</span></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;  <span class="comment">// idList:主键ID列表</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Update</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Get</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>List</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Page</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Count</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Mapper-CRUD-接口"><a href="#Mapper-CRUD-接口" class="headerlink" title="Mapper CRUD 接口"></a>Mapper CRUD 接口</h4><p>通用 CRUD 封装 BaseMapper 接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器。</p>
<ul>
<li><p><code>Insert</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Delete</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Update</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Select</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p><strong>AbstractWrapper</strong>是QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类，用于生成 sql 的 where 条件。</p>
<blockquote>
<p>以下方法在入参中出现的<code>R</code>为泛型，在普通wrapper中是<code>String</code>，在<code>LambdaWrapper</code>中是<strong>函数</strong>(例:<code>Entity::getId</code>，<code>Entity</code>为实体类，<code>getId</code>为字段<code>id</code>的<strong>getter Method</strong>)。</p>
</blockquote>
<ul>
<li><p><code>allEq</code>：全部eq（或个别isNull）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allEq(Map&lt;R, V&gt; params)</span><br><span class="line">allEq(Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>params</code> : <code>key</code>为数据库字段名，<code>value</code>为字段值<br><code>null2IsNull</code> : 为<code>true</code>则在<code>map</code>的<code>value</code>为<code>null</code>时调用<code>isNull</code>方法，为<code>false</code>时则忽略<code>value</code>为<code>null</code>的值</p>
<ul>
<li>例1: <code>allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;)</code>—&gt;<code>id = 1 and name = &#39;老王&#39; and age is null</code></li>
<li>例2: <code>allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;, false)</code>—&gt;<code>id = 1 and name = &#39;老王&#39;</code></li>
</ul>
</blockquote>
</li>
<li><p><code>eq</code>：等于 =</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eq(R column, Object val)</span><br><span class="line">eq(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure></li>
<li><p><code>ne</code>：不等于 &lt;&gt; (或 !=)</p>
</li>
<li><p><code>gt</code>：大于 &gt;</p>
</li>
<li><p><code>ge</code>：大于等于 &gt;=</p>
</li>
<li><p><code>lt</code>：小于 &lt;</p>
</li>
<li><p><code>le</code>：小于等于 &lt;=</p>
</li>
<li><p><code>between</code>：BETWEEN 值1 AND 值2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">between(R column, Object val1, Object val2)</span><br><span class="line">between(<span class="type">boolean</span> condition, R column, Object val1, Object val2)</span><br><span class="line"><span class="comment">// between(&quot;age&quot;, 18, 30)---&gt;age between 18 and 30</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>notBetween</code>：NOT BETWEEN 值1 AND 值2</p>
</li>
<li><p><code>like</code></p>
</li>
<li><p><code>notLike</code></p>
</li>
<li><p><code>likeLeft</code></p>
</li>
<li><p><code>likeRight</code></p>
</li>
<li><p><code>isNull</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isNull(R column)</span><br><span class="line">isNull(<span class="type">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure></li>
<li><p><code>isNotNull</code></p>
</li>
<li><p><code>in</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">in(R column, Collection&lt;?&gt; value)</span><br><span class="line">in(<span class="type">boolean</span> condition, R column, Collection&lt;?&gt; value)</span><br></pre></td></tr></table></figure></li>
<li><p><code>groupBy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">groupBy(R... columns)</span><br><span class="line">groupBy(<span class="type">boolean</span> condition, R... columns)</span><br><span class="line"><span class="comment">// groupBy(&quot;id&quot;, &quot;name&quot;)---&gt;group by id,name</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>orderByAsc</code>：升序排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">orderByAsc(R... columns)</span><br><span class="line">orderByAsc(<span class="type">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure></li>
<li><p><code>orderByDesc</code>：升序排序</p>
</li>
<li><p><code>or</code>：主动调用<code>or</code>表示紧接着下一个<strong>方法</strong>不是用<code>and</code>连接!(不调用<code>or</code>则默认为使用<code>and</code>连接)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br><span class="line"><span class="comment">// eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)---&gt;id = 1 or name = &#x27;老王&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>不是全部，条件构造器API：<a href="https://baomidou.com/pages/10c804/#querywrapper%E3%80%82">https://baomidou.com/pages/10c804/#querywrapper。</a></p>
</blockquote>
<p><strong>QueryWrapper</strong>或者<strong>LambdaQueryWrapper</strong>，继承自 AbstractWrapper 。</p>
<ul>
<li><p><code>select</code>：设置查询字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line"><span class="comment">// select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>UpdateWrapper</strong>或者<strong>LambdaUpdateWrapper</strong>，也继承自 AbstractWrapper。</p>
<ul>
<li><p><code>set</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="type">boolean</span> condition, String column, Object val)</span><br><span class="line"><span class="comment">// set(&quot;name&quot;, &quot;老李头&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>setSql</code>：设置 SET 部分 SQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setSql(String sql) </span><br><span class="line"><span class="comment">// setSql(&quot;name = &#x27;老李头&#x27;&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>lambda</code>：获取 <code>LambdaWrapper</code>，在<code>QueryWrapper</code>中是获取<code>LambdaQueryWrapper</code>在<code>UpdateWrapper</code>中是获取<code>LambdaUpdateWrapper</code>。</p>
</li>
</ul>
<h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p><strong>安装</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<p><a href="https://baomidou.com/pages/779a6e/#%E4%BD%BF%E7%94%A8">https://baomidou.com/pages/779a6e/#%E4%BD%BF%E7%94%A8</a></p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm03 链表</title>
    <url>/2023/02/03/algorithm03/</url>
    <content><![CDATA[<p>说在前面：之前刷题都没有按照知识点分类整理过，最近在网上看到推荐<strong>代码随想录</strong>的算法讲义，就想按照他的推荐系统的把算法这一块拾起来，在自己的博客里做一个记录，也当做日后自己复习的笔记了。</p>
<span id="more"></span>

<h2 id="链表基础知识"><a href="#链表基础知识" class="headerlink" title="链表基础知识"></a>链表基础知识</h2><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。</p>
<p>如图所示：</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343532393831352e706e67.png" alt="链表1" style="zoom:67%;" />

<h3 id="链表类型"><a href="#链表类型" class="headerlink" title="链表类型"></a>链表类型</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表中的指针域只能指向节点的下一个节点。上面说的就是单链表。</p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343535393331372e706e67.png" alt="链表2" style="zoom:67%;" />

<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表，顾名思义，就是链表首尾相连。（解决约瑟夫环问题）</p>
<img src="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343632393630332e706e67.png" alt="链表4" style="zoom:67%;" />

<h3 id="链表存储方式"><a href="#链表存储方式" class="headerlink" title="链表存储方式"></a>链表存储方式</h3><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<img src="image-20230530204103935.png" alt="image-20230530204103935" style="zoom:67%;" />

<h3 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h3><p>下面我给出java定义链表节点的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    ListNode() &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h3><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除D节点，只要将C节点的next指针指向E结点就可以了。Java语言有自己的内存回收机制，就不用像C++那样手动释放D结点了。</p>
<img src="image-20230530204626695.png" alt="image-20230530204626695" style="zoom:67%;" />

<h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p>链表的增添和删除都是O(1)操作，也不会影响到其他结点。</p>
<img src="image-20230530205536030.png" alt="image-20230530205536030" style="zoom:67%;" />

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><img src="image-20230530205917354.png" alt="image-20230530205917354" style="zoom:67%;" />

<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3><p><img src="image-20230530230242484.png" alt="image-20230530230242484"></p>
<p>这里以链表1-&gt;4-&gt;2-&gt;4，删除元素4为例来说明：</p>
<img src="image-20230530230421437.png" alt="image-20230530230421437" style="zoom:67%;" />

<p>在这种情况下，只需要记录被删除结点的前一个结点p，将p的next结点设为p的next的next结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.next = p.next.next;</span><br></pre></td></tr></table></figure>

<p>如果删除的是头结点呢？</p>
<p>我们可以对原链表直接操作，但写代码的时候会发现，需要单独写一段逻辑来处理移除头结点的情况。更好的方式是设置一个虚拟的头结点再进行删除操作，以一种统一的逻辑来移除链表的结点：</p>
<img src="image-20230530231107124.png" alt="image-20230530231107124" style="zoom:67%;" />

<p>但是别忘记在算法最后返回链表结果的时候，返回的头结点是<code>dummyNode-&gt;next</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val==val)&#123; </span><br><span class="line">                <span class="comment">// 删除操作，记录待删除结点的前一个节点</span></span><br><span class="line">                p.next=p.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h3><p><img src="image-20230601192641111.png" alt="image-20230601192641111"></p>
<p><strong>思路：</strong>这道题涵盖了链表的几大基础操作：增、删、查，很基础，很重要。链表操作有两种方式：一种是直接使用原有的链表进行操作，另一种方式是设置一个哑结点再进行操作，我们对链表来操作通常都是通过第二种方式。</p>
<p>定义结点类的代码就不再解释了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.next=next;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我直接展示题目的代码，结合代码在注释中梳理思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode dummy;</span><br><span class="line">		<span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 这里定义的头结点，是一个虚拟的哑结点，需要注意哑结点通常用dummy变量或dummyNode变量表示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取到第index个节点数值:如果index是非法数值直接返回-1，注意index是从0开始的，index=0的结点实际是dummy.next结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;index)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在链表最后面添加一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在第index个结点之前插入一个新结点</span></span><br><span class="line">    <span class="comment">// 如果index等于链表的长度，则说明是新插入的结点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// 如果index小于0，则在头部插入结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        index = Math.max(<span class="number">0</span>,index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = p.next;</span><br><span class="line">        p.next = node; </span><br><span class="line">        size++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除第index个结点，如果index非法，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.next=next;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作总结：</strong></p>
<ul>
<li>增添一个结点——在C结点之后、D结点之前添加一个结点F：</li>
</ul>
<img src="algorithm03/image-20230601195348122.png" alt="image-20230601195348122" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F.next = C.next;</span><br><span class="line">C.next = F;</span><br></pre></td></tr></table></figure>

<p>由此我们可以发现，如果要在index结点前插入一个新结点，需要关注的是index-1个结点的位置。</p>
<ul>
<li>删除一个结点——删除结点D</li>
</ul>
<img src="image-20230601195839274.png" alt="image-20230601195839274" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C.next = C.next.next;</span><br></pre></td></tr></table></figure>

<p>由此我们可以发现，如果要删除index结点，需要关注的还是index-1个结点的位置。</p>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><img src="image-20230601200400257.png" alt="image-20230601200400257"  />

<p><strong>思路1：</strong>迭代方法</p>
<p>在遍历链表时，将当前结点<code>curr</code>的next指针改为指向前一个结点，由于结点没有引用其前一个结点，因此必须事先存储其前一个结点<code>prev</code>。在更改引用之前，还需要存储后一个节点<code>next</code>。最后返回新的头引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 要记录当前结点的next位置，因为一旦当前结点翻转后，就无法引用next位置的结点了</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;  <span class="comment">// 当前结点的next指针改为指向前一个结点</span></span><br><span class="line">            <span class="comment">// 为下一次循环更新prev和curr的位置：后移一位</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;  <span class="comment">//返回的是翻转后的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2：</strong>递归方法（空间复杂度O(n)）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// newHead存储的是反转后的头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">            第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                      把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        head.next.next = head;  </span><br><span class="line">        head.next = <span class="literal">null</span>;  <span class="comment">// 断开双向指针</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3><p><img src="image-20230601203345561.png" alt="image-20230601203345561"></p>
<p>题目的本质和上一题翻转链表是一样的，核心就是记录<code>temp</code>、<code>start</code>、<code>end</code>三个结点，交换start和end结点的位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp.next = end;</span><br><span class="line"> start.next = end.next;</span><br><span class="line"> end.next = start;</span><br><span class="line"> temp = start;</span><br></pre></td></tr></table></figure>

<p>程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    	  <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p><img src="image-20230601205710711.png" alt="image-20230601205710711"></p>
<p><strong>思路1：</strong>计算链表的长度</p>
<p>最容易想到的方法就是计算链表的长度，随后我们再从头结点开始对链表进行一次遍历，当遍历到第Length−n+1个节点时，它就是我们需要删除的节点。</p>
<p>计算单链表的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           p = p.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>易得代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> length-n+<span class="number">1</span>;  </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;              </span><br><span class="line">        <span class="comment">// p为待删除结点的前一个结点</span></span><br><span class="line">        p.next = p.next.next;      </span><br><span class="line">        <span class="keyword">return</span> dummy.next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2：</strong>双指针法</p>
<p>由于我们需要找到倒数第n个节点，因此我们可以使用两个指针first和second同时对链表进行遍历，并且 <em>first比second超前n个节点</em> 。当first遍历到链表的末尾时，second就恰好处于倒数第n个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针法first second</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy, second = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 待删除的结点是second的next结点</span></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p><img src="image-20230601211248800.png" alt="image-20230601211248800"></p>
<p><strong>思路1：</strong>哈希Set，这个属于是比较容易想到的笨办法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单方法 -- 哈希表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">        HashSet&lt;ListNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pA != <span class="literal">null</span>)&#123;</span><br><span class="line">            nodes.add(pA);</span><br><span class="line">            pA = pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pB != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.contains(pB))&#123;</span><br><span class="line">                <span class="comment">// 题意告诉我们：当前的结点重复时，后面的所有结点都是重复的</span></span><br><span class="line">                <span class="keyword">return</span> pB;</span><br><span class="line">            &#125;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2：</strong>思维性比较高，注重理解</p>
<p>pA走过的路径为A链+B链；pB走过的路径为B链+A链；pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。</p>
<p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p><img src="image-20230601220031508.png" alt="image-20230601220031508"></p>
<p><strong>思路1：</strong>哈希Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        HashSet&lt;ListNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.contains(p))&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            nodes.add(p);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2：</strong>双指针法</p>
<p>我们主要判断两个问题：① 判断链表是否有环；② 如果有环，如何找到这个环的入口；</p>
<p>① 判断链表是否有环：可以使用快慢指针法，分别定义fast和slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果fast和 slow指针在途中相遇 ，说明这个链表有环。</p>
<p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢？因为无论怎么追赶最后都会是下图这种情况：</p>
<p><img src="image-20230601222337720.png" alt="image-20230601222337720"></p>
<p>② 如果有环，如何找到这个环的入口：</p>
<p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到fast指针与slow指针相遇节点 节点数为y。 从相遇节点再到环形入口节点节点数为 z。</p>
<img src="image-20230601222628871.png" alt="image-20230601222628871" style="zoom:67%;" />

<p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code> x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：<code>(x + y) * 2 = x + y + n (y + z)</code>.</p>
<p>因为要找环形的入口，那么要求的是x，因为x表示头结点到环形入口节点的距离：<code>x = (n - 1)(y + z) + z, n&gt;=1</code>.</p>
<p>当n为1的时候，公式就化解为 <code>x = z</code>，这就意味着，<strong>从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点</strong>。也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是环形入口的节点。</p>
<p><img src="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3134322e2545372538452541462545352542442541322545392539332542452545382541312541384949254546254243253838254536254231253832254535253835254135254535253846254133.gif" alt="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3134322e2545372538452541462545352542442541322545392539332542452545382541312541384949254546254243253838254536254231253832254535253835254135254535253846254133"></p>
<p>n如果大于1时，一样可以通过这个方法找到环形的入口节点，只不过，index1 指针在环里多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm04 字符串</title>
    <url>/2023/06/05/algorithm04-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串比较简单，直接来看题目！</p>
<span id="more"></span>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>字符串很简单，这里我就记录一下几个字符串、数组、char类型相互转化的方法。</p>
<p>toCharArray()</p>
<p>String.ValueOf()</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p><img src="algorithm04-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230605205843387.png" alt="image-20230605205843387"></p>
<p>双指针，没什么可说的，重拳出击！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>;left&lt;right;left++,right--)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h3><p><img src="algorithm04-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230605210330082.png" alt="image-20230605210330082"></p>
<p>这种题目属于模拟类问题，模拟类问题要进行明确的分情况讨论：</p>
<p>情况①：字符串剩余字符小于k个 → 全部翻转   </p>
<p>情况②：字符串剩余字符大于等于k个，且少于2k个 → 翻转前k个   </p>
<p>情况③：字符串剩余字符大于2k个 → 正常翻转前k个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            if(i+k &lt;= len)&#123;</span></span><br><span class="line"><span class="comment">                reverse(chs, i, i+k-1);</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                reverse(chs, i, len-1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             reverse(chs, i, Math.min(i+k-<span class="number">1</span>,len-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chs[left];</span><br><span class="line">            chs[left] = chs[right];</span><br><span class="line">            chs[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3><p><img src="algorithm04-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230607113006876.png" alt="image-20230607113006876"></p>
<p>写一个函数实现该方法：<code>s.replace(&quot; &quot;, &quot;%20&quot;);</code>  </p>
<p>思路1：使用额外的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span> == s.charAt(i))&#123;</span><br><span class="line">                strs[i] = <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strs[i] = String.valueOf(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            ans += strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：如果要将这道题做到极致，就不要用额外的辅助空间了</p>
<p>思路是用双指针，首先使用数组扩充为每个空格填充为”%20”之后的大小（java数组在创建之后不可以改变大小，但是cpp中vector的resize可以），然后<strong>从后向前</strong>（从前向后的话每次填充”%20”后都要将后面的数组元素向后移动）替换空格，i指向新长度的末尾，j指向旧长度的末尾。</p>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h3><img src="algorithm04-字符串/image-20230621211906665.png" alt="image-20230621211906665" style="zoom:87%;" />

<p>思路：和C++语言字符串可变的特性不同，Java语言的字符串是不可变的，所以必须要开辟可变的辅助空间来完成这道题目。主要采用的思路是这样的，先去掉字符串中多余的空格，再将整个数组倒置（这时每个单词也都是倒序的），再对每个单词的字母进行倒置，就完成了题目的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line">        reverse(sb, <span class="number">0</span> ,sb.length()-<span class="number">1</span>);</span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除字符串多余的空格</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        s = s.trim();  <span class="comment">// 删除头尾的空白</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除中间多余的空白</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sb.charAt(sb.length()-<span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 将字符串倒序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串中的每个单词倒序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span>&#123;</span><br><span class="line">        sb.append(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 防止最后一个单词不被倒序</span></span><br><span class="line">        <span class="comment">// 快慢指针法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(fast = <span class="number">0</span>;fast &lt; sb.length();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(fast) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                reverse(sb, slow, fast-<span class="number">1</span>);</span><br><span class="line">                slow = fast + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我初次做法，感觉也不错：单独把每个单词取出来放入一个list中，再倒序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(end=<span class="number">0</span>;end&lt;s.length();end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span> == s.charAt(end) &amp;&amp; start == end)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span> == s.charAt(end) &amp;&amp; start != end)&#123;</span><br><span class="line">                lists.add(s.substring(start,end));</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(end == s.length()-<span class="number">1</span> &amp;&amp; s.charAt(end) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                lists.add(s.substring(start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += lists.get(lists.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lists.size()-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans = ans + <span class="string">&quot; &quot;</span> + lists.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p><img src="algorithm04-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230621223954771.png" alt="image-20230621223954771"></p>
<p>法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">startStr</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">endStr</span> <span class="operator">=</span> s.substring(n);</span><br><span class="line">        <span class="keyword">return</span> endStr + startStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;s.length();i++)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="字符串总结"><a href="#字符串总结" class="headerlink" title="字符串总结"></a>字符串总结</h2><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p>
<img src="algorithm04-字符串/image-20230621223422926.png" alt="image-20230621223422926" style="zoom:77%;" />

<p>StringBuilder的父类和String实现了相同的接口，所以StringBuilder可以使用String所有的方法，除此之外比较常用的有：</p>
<p>1）append</p>
<p>2）修改字符串的元素：<code>setCharAt(索引，修改的元素)</code></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm05-二叉树</title>
    <url>/2023/07/18/algorithm05-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<ul>
<li><p>前序遍历</p>
<p>按照访问<strong>根节点→左子树→右子树</strong>的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traversal(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        traversal(node.left, res);</span><br><span class="line">        traversal(node.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历</p>
<p>按照访问<strong>左子树→根节点→右子树</strong>的方式遍历这棵树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traversal(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traversal(node.left, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        traversal(node.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历</p>
<p>按照访问<strong>左子树→右子树→根节点</strong>的方式遍历这棵树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traversal(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traversal(node.left, res);</span><br><span class="line">        traversal(node.right, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来。相较于递归方法，迭代遍历的代码更难理解一些，但是本质都是相同的。</p>
<ul>
<li><p>前序遍历</p>
<p>首先我们应该创建一个 Stack 用来存放节点，首先我们想要打印根节点的数据，此时 Stack 里面的内容为空，所以我们优先将头结点加入 Stack，然后打印。之后我们应该先打印左子树，然后右子树。所以先加入 Stack 的就是右子树，然后左子树。</p>
<img src="algorithm05-二叉树/image-20230719140417818.png" alt="image-20230719140417818" style="zoom:87%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="comment">// 一定要先压入右子树，再压入左子树，注意Stack的先进后出特性</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历</p>
<p>按 左子树→根节点→右子树 的顺序输出节点。尽可能的将这个节点的左子树压入 Stack，此时栈顶的元素是最左侧的元素（也就是最左侧的一个节点），并且在寻找的过程中记录了来源，才能返回上层，同时在返回上层的时候已经处理完毕左子树了。如果有右节点，其也要进行中序遍历。</p>
<p><img src="algorithm05-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230719155425374.png" alt="image-20230719155425374"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;  <span class="comment">// 将这个节点的左子树压入Stack</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 出内循环是root一定为null，如果node没有右子树就会回退一层</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;  <span class="comment">// 如果有右节点，其也要进行中序遍历</span></span><br><span class="line">                root = node.right;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 后序遍历</p>
</li>
</ul>
<p>  后序遍历和中序一样，都要先找到二叉树最左侧的节点，但是由于后序遍历的顺序是 左子树→右子树→根节点，所以和中序还略有不同——找到最左侧节点后不能马上输出，要先判断该节点是否有右子树：如果有右子树，要将右子树的根节点重复执行前面的步骤；如果没有右子树，则输出该节点并回退一层继续寻找右子树。需要注意的是，由于在<strong>压出右子树后进行回退时</strong>根节点（左右子树的根，严格意义上的中间节点）仍在栈中，所以要记录右子树节点为<code>prev</code>才能将根节点压出（<strong>压出节点的条件是该节点没有右子树或者右子树已经输出完</strong>），否则会造成死循环。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行内循环后root取为最左侧节点，但不能马上将其输出，要先考虑该节点是否有优先级更高的右子树</span></span><br><span class="line">            root = stack.peek();</span><br><span class="line">            <span class="comment">// 压出节点的条件是该节点 没有右子树 或者 右子树已经输出完</span></span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="literal">null</span> || root.right == prev)&#123;  </span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                prev = root;  <span class="comment">// 记录刚输出的节点</span></span><br><span class="line">                root = <span class="literal">null</span>;  <span class="comment">// 回退上层的标志</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p>
<img src="algorithm05-二叉树/image-20230719164248920.png" alt="image-20230719164248920" style="zoom:67%;" />

<p>这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。BFS ，广度优先搜索，遍历使用<strong>队列</strong>数据结构。而这里的层序遍历，就是 BFS 的应用场景之一。在层序遍历中，要记录每一层节点的个数，然后通过内置for循环一口气将这一层的节点处理完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.size();  <span class="comment">// 记录每一层节点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                r.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BFS 广度优先搜索，需要解决以下三类问题：<ul>
<li>BFS遍历</li>
<li>层序遍历</li>
<li>最短路径</li>
</ul>
</li>
</ul>
<p>最后来讲一下BFS 的最短路径问题。BFS 属于图算法，这里就先简单讲一下。在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p>
<img src="algorithm05-二叉树/image-20230720103507226.png" alt="image-20230720103507226" style="zoom:77%;" />

<h2 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h2><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<img src="algorithm05-二叉树/image-20230720104416605.png" alt="image-20230720104416605" style="zoom:87%;" />

<p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invert</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            invert(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            invert(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看过题解后，发现可以将递归程序写的更优雅：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<img src="algorithm05-二叉树/image-20230720111019386.png" alt="image-20230720111019386" style="zoom:77%;" />

<p><strong>递归方法</strong><font color="blue">（重点掌握递归法即可）</font></p>
<p>对称二叉树的递归思路是，要保证当前两节点的值相等，并且递归调用左右节点另其镜像相等，只要有一处镜像不对称，那就输出<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 树中节点数目在范围 [1, 1000] 内</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代方法</strong></p>
<p>手动维护一个队列结构，根据层序遍历的思想对每一层进行检验：每次拿出的两个元素， 就是镜像位置的元素，进行比较即可。<code>Deque</code>接口的<code>offer</code>方法不会报空指针异常（此方法通常优于<code>add</code>仅通过抛出异常来插入元素失败的方法），可酌情选择使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> || root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.addLast(p);</span><br><span class="line">        queue.addLast(q);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">if</span>(num % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                p = queue.removeFirst();</span><br><span class="line">                q = queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(p.left);</span><br><span class="line">                queue.offer(q.right);</span><br><span class="line">                queue.offer(p.right);</span><br><span class="line">                queue.offer(q.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<img src="algorithm05-二叉树/image-20230720152910048.png" alt="image-20230720152910048" style="zoom:87%;" />

<p><strong>广度优先搜索BFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 层序遍历求深度</span></span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深度优先搜索DFS</strong></p>
<p>如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为<code>max(l,r)+1</code>。而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用 深度优先搜索 的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 算出当前二叉树的最大深度。递归在访问到空节点时退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<img src="algorithm05-二叉树/image-20230720154135014.png" alt="image-20230720154135014" style="zoom:77%;" />

<p><strong>广度优先搜索BFS</strong></p>
<p>当我们找到一个叶子节点时，直接返回这个叶子节点的深度，广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深度优先搜索DFS</strong></p>
<p>对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止条件是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            min = Math.min(minDepth(root.left), min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            min = Math.min(minDepth(root.right), min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm06-回溯算法</title>
    <url>/2023/07/21/algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>

<img src="algorithm06-回溯算法/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231393139323035303636362e706e67.png" alt="回溯算法大纲" style="zoom: 50%;" />

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230815163034834.png" alt="image-20230815163034834"></p>
<p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230721155109453.png" alt="image-20230721155109453"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> begin, Deque&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=n;i++)&#123;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            dfs(n, k, i+<span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> begin, Deque&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前可选的数 小于 path剩余的size，则剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(k - path.size() - <span class="number">1</span> &gt; n - i)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            dfs(n, k, i+<span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230815163058336.png" alt="image-20230815163058336"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMap</span><span class="params">()</span>&#123;</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        buildMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        dfs(digits, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String digits, <span class="type">int</span> depth, String path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == digits.length())&#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> digits.charAt(depth);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str_ch</span> <span class="operator">=</span> map.get(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str_ch.length();i++)&#123;</span><br><span class="line">            path += str_ch.charAt(i);</span><br><span class="line">            dfs(digits, depth+<span class="number">1</span>, path);</span><br><span class="line">            path = path.substring(<span class="number">0</span>, path.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3><p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230815163405787.png" alt="image-20230815163405787"></p>
<p>组合类回溯问题使用 <code>begin</code> 状态位限制重复出现的答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(candidates, target - candidates[i], i, path);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> begin, Deque&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; candidates[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], i, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h3><p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230817104851768.png" alt="image-20230817104851768"></p>
<p>和39题的区别有二：① <code>candidates[i]</code>在每个组合中只能使用一次； ② <code>candidates</code>数组在本题中包含了重复元素。</p>
<p>① 解决方案：纵向限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(candidates, target - candidates[i], i+<span class="number">1</span>, path);</span><br></pre></td></tr></table></figure>

<p>② 解决方案：横向限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i-<span class="number">1</span> &gt;= begin &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> begin, Deque&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; candidates[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">1</span> &gt;= begin &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], i+<span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h3><p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230817111908237.png" alt="image-20230817111908237"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> k, <span class="type">int</span> begin, Deque&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">          	<span class="comment">// ----可剪枝----</span></span><br><span class="line">            path.addLast(i);</span><br><span class="line">            dfs(target - i, k, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(k - path.size() &gt; <span class="number">9</span> - i + <span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h3><p><img src="algorithm06-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20230829151735071.png" alt="image-20230829151735071"></p>
<p>93</p>
]]></content>
  </entry>
  <entry>
    <title>algorithm07-dp之股票系列</title>
    <url>/2023/08/05/algorithm07-dp%E4%B9%8B%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><p><img src="algorithm07-dp%E4%B9%8B%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97/image-20230805115618486.png" alt="image-20230805115618486"></p>
<p>只能买卖<strong>一次</strong>，所以维护一个历史最低价<code>minprice</code>变量，意为在第i天时，[0, …, i-1]天中的最底价。这是一种动态规划的思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minprice</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxprofit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            minprice = minprice &lt;= prices[i] ? minprice : prices[i];</span><br><span class="line">            maxprofit = maxprofit &gt;= (prices[i] - minprice) ? maxprofit : (prices[i] - minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><p><img src="algorithm07-dp%E4%B9%8B%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97/image-20230805120302626.png" alt="image-20230805120302626"></p>
<p>可以买卖任意次数，这里通过二维数组<code>dp[prices.length][2]</code>表示每个状态，<code>dp[i][j]</code> 表示到下标为 <code>i</code> 的这一天，持股状态为 <code>j</code> 时，我们<strong>手上拥有的最大现金数</strong>。<code>dp[][0]</code>表示持有现金，<code>dp[][1]</code>表示持有股票。</p>
<p>每一天状态可以转移，也可以不动。状态转移用下图表示：</p>
<p><img src="algorithm07-dp%E4%B9%8B%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97/image-20230805121048597.png" alt="image-20230805121048597"></p>
<p>状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 状态位：dp[][0]表示持有现金  dp[][1]表示持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在状态转移方程中我们仅需参考上一位状态，所以可以采用滚动数组的思想进行空间优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">precash</span> <span class="operator">=</span> cash;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prestock</span> <span class="operator">=</span> stock;</span><br><span class="line">            cash = Math.max(precash, prestock + prices[i]);</span><br><span class="line">            stock = Math.max(prestock, precash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><p><img src="algorithm07-dp%E4%B9%8B%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97/image-20230805160417623.png" alt="image-20230805160417623"></p>
<p>限定只能买卖<strong>两次</strong>。因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p>
<p>① 未进行过任何操作；② 只进行过一次买操作；③ 进行了一次买操作和一次卖操作，即完成了一笔交易；④ 在完成了一笔交易的前提下，进行了第二次买操作；⑤ 完成了全部两笔交易。</p>
<p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为<code>buy1</code>, <code>sell1</code>, <code>buy2</code> 以及<code>sell2</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];  </span><br><span class="line">        <span class="type">int</span> <span class="variable">sell1</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);  <span class="comment">// 第一次买入的状态</span></span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);  <span class="comment">// 第一次卖出的状态</span></span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);  <span class="comment">// 第二次买入的状态</span></span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);  <span class="comment">// 第二次卖出的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这种解法仅作为一种<strong>思路参考</strong>，只能限定于2次买卖的情况，不具有股票问题的普适性，而且个人感觉该思路比较别扭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];  <span class="comment">// 表示第i天以及之前区间所获得的最大利润</span></span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];  <span class="comment">// 表示第i天开始到最后一天所获得的最大利润</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> prices[<span class="number">0</span>], maxVal = prices[prices.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp1.length;i++)&#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i-<span class="number">1</span>], prices[i]-minVal);</span><br><span class="line">            minVal = prices[i] &lt; minVal ? prices[i] : minVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp2[dp2.length-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=dp2.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp2[i] = Math.max(dp2[i+<span class="number">1</span>], maxVal-prices[i]);</span><br><span class="line">            maxVal = prices[i] &gt; maxVal ? prices[i] : maxVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            max = Math.max(dp1[i] + dp2[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h3><p><img src="algorithm07-dp%E4%B9%8B%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97/image-20230805163734130.png" alt="image-20230805163734130"></p>
<p>思路与 <strong>买卖股票的最佳时机 III</strong> 完全一致！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        Arrays.fill(buy, -prices[<span class="number">0</span>]);</span><br><span class="line">        Arrays.fill(sell, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            buy[<span class="number">0</span>] = Math.max(buy[<span class="number">0</span>], -prices[i]);  </span><br><span class="line">            sell[<span class="number">0</span>] = Math.max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + prices[i]);  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;k;j++)&#123;</span><br><span class="line">                buy[j] = Math.max(buy[j], sell[j-<span class="number">1</span>] - prices[i]);</span><br><span class="line">                sell[j] = Math.max(sell[j], buy[j] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>algorithm08-dp之子序列</title>
    <url>/2023/08/11/algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<span id="more"></span>

<img src="algorithm08-dp之子序列/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732fe58aa8e68081e8a784e588922de5ad90e5ba8fe58897e997aee9a298e680bbe7bb932e6a7067.jpeg" alt="img" style="zoom: 50%;" />

<h2 id="不连续子序列"><a href="#不连续子序列" class="headerlink" title="不连续子序列"></a>不连续子序列</h2><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811103401752.png" alt="image-20230811103401752"></p>
<p>定义 <code>dp[i]</code> 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 <code>nums[i]</code> 必须被选取。</p>
<p>我们从小到大计算 <code>dp</code> 数组的值，在计算 <code>dp[i]</code> 之前，我们已经计算出 <code>dp[0…i−1]</code> 的值，则状态转移方程为：<br>$$<br>dp[i]=max⁡(dp[j])+1,其中 0≤j&lt;i 且 num[j]&lt;num[i]<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = Math.max(dp[i], maxans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811110006614.png" alt="image-20230811110006614"></p>
<p>最长公共子序列问题是典型的二维动态规划问题。</p>
<p>假设字符串 <code>text1</code> 和 <code>text2</code>的长度分别为 m 和 n，创建 m 行 n 列的二维数组<code>dp</code>，其中 <code>dp[i][j]</code>表示 <code>text1[0:i]</code>和 <code>text2[0:j]</code>的最长公共子序列的长度。</p>
<p>当 <code>i&gt;0 且 j&gt;0</code> 时，考虑 <code>dp[i][j] </code>的计算：</p>
<ul>
<li><p>当 <code>text1[i] = text2[j]</code>时，将这两个相同的字符称为公共字符，考虑 <code>text1[0:i−1]</code> 和 <code>text2[0:j−1]</code>的最长公共子序列，再增加一个字符（即公共字符）即可得到 <code>text1[0:i]</code>和 <code>text2[0:j]</code>的最长公共子序列，因此 <code>dp[i][j] = dp[i−1][j−1]+1</code>。</p>
</li>
<li><p>当 <code>text1[i] ≠ text2[j]</code> 时，考虑以下两项：</p>
<ul>
<li><p><code>text1[0:i−1]</code> 和 <code>text2[0:j] </code> 的最长公共子序列；</p>
</li>
<li><p><code>text1[0:i]</code> 和 <code>text2[0:j−1]</code> 的最长公共子序列；</p>
</li>
</ul>
</li>
</ul>
<p>由此可以得到如下状态转移方程：</p>
<p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811112053495.png" alt="image-20230811112053495"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i) == text2.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                stage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = stage == <span class="literal">true</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(<span class="number">0</span>) == text2.charAt(j))&#123;</span><br><span class="line">                stage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][j] = stage == <span class="literal">true</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = text1.charAt(i) == text2.charAt(j) ? dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span> : max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h3><p>高情商版本的最长子序列问题，与1143题一模一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == nums2[<span class="number">0</span>])&#123;</span><br><span class="line">                stage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = stage == <span class="literal">true</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[<span class="number">0</span>] == nums2[j])&#123;</span><br><span class="line">                stage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][j] = stage == <span class="literal">true</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连续子序列"><a href="#连续子序列" class="headerlink" title="连续子序列"></a>连续子序列</h2><h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h3><p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811114008992.png" alt="image-20230811114008992"></p>
<p><code>dp[i]</code>代表以<code>nums[i]</code>为结尾的递增序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = nums[i-<span class="number">1</span>] &lt; nums[i] ? dp[i-<span class="number">1</span>]+<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            maxans = Math.max(dp[i], maxans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811161804773.png" alt="image-20230811161804773"></p>
<p><code>dp[i][j]</code>表示以<code>nums1[i]</code>和<code>nums2[j]</code>为结尾的子数组的公共子数组长度。当<code>nums1[i] == nums2[j]</code>时，<code>dp[i][j]</code>由<code>dp[i-1][j-1]</code>状态转移过来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">// init </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = nums1[i] == nums2[<span class="number">0</span>] ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            maxans = Math.max(dp[i][<span class="number">0</span>], maxans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = nums1[<span class="number">0</span>] == nums2[j] ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            maxans = Math.max(dp[<span class="number">0</span>][j], maxans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = nums1[i] == nums2[j] ? dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">                maxans = Math.max(dp[i][j], maxans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811164122670.png" alt="image-20230811164122670"></p>
<p><code>dp[i]</code>表示以<code>nums[i]</code>为结尾的子数组的最大和，通过比较<code>dp[i-1]+nums[i]</code>和<code>nums[i]</code>的状态转移到<code>dp[i]</code>上来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h3><p><img src="algorithm08-dp%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97/image-20230811164503300.png" alt="image-20230811164503300"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            stage = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=count;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;</span><br><span class="line">                    stage = <span class="literal">true</span>;</span><br><span class="line">                    count = j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stage == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>OpenCV特征检测</title>
    <url>/2023/03/10/opencv01/</url>
    <content><![CDATA[<p>​        前段时间在研究Android开发，以及对第三方库的JNI编程和交叉编译，本想把FFmpeg和JNI先整理成博客发出来，奈何实在太懒了，可能还要过一段时间才能整理完了。正好这几天项目里用到了OpenCV里Detection的一些算法，就去学习了一下。</p>
<span id="more"></span>

<h1 id="OpenCV-Canny边缘检测、HoughLinesP直线检测"><a href="#OpenCV-Canny边缘检测、HoughLinesP直线检测" class="headerlink" title="[OpenCV]Canny边缘检测、HoughLinesP直线检测"></a>[OpenCV]Canny边缘检测、HoughLinesP直线检测</h1><h2 id="边缘检测Edge-detection"><a href="#边缘检测Edge-detection" class="headerlink" title="边缘检测Edge detection"></a>边缘检测Edge detection</h2><p>​        边缘检测算法是指利用灰度值的不连续性质，以灰度突变为基础分割出目标区域。大概原理是计算图像中每个像素点的梯度值和梯度方向。使用边缘检测算子计算图像在x和y方向上的一阶导数，然后计算每个像素点的梯度幅值和梯度方向；再利用NMS和阈值检测将边缘点标记和连接。</p>
<p>​        最后的输出一定是一个二值图像，其中白色像素表示边缘，黑色像素表示非边缘。</p>
<p>​        Canny边缘检测算法的优点是能够检测到比较细的边缘，且对噪声比较鲁棒。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Canny算法参数：</span><br><span class="line">   	InputArray 	image,  //输入图像，要求为灰度图</span><br><span class="line">   	OutputArray 	edges, //canny检测后的输出图像</span><br><span class="line">   	double 	threshold1, //阈值1,低阈值</span><br><span class="line">   	double 	threshold2, //阈值2，高阈值，低/高=比值1:2~1:3尤佳</span><br><span class="line">   	int 	apertureSize = 3,  //Sobel算子的孔径大小</span><br><span class="line">   	bool 	L2gradient = false  //计算梯度幅度值的标识，默认为false</span><br></pre></td></tr></table></figure>

<p>​        实验代码，参数可以自行调整。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	Mat src, dst;</span><br><span class="line">   	src = <span class="built_in">imread</span>(<span class="string">&quot;../../pictureRepo/people.jpg&quot;</span>);</span><br><span class="line">   	<span class="built_in">Canny</span>(src, dst, <span class="number">50</span>, <span class="number">200</span>, <span class="number">3</span>);</span><br><span class="line">   	<span class="built_in">namedWindow</span>(<span class="string">&quot;Orgin&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   	<span class="built_in">imshow</span>(<span class="string">&quot;Orgin&quot;</span>, src);</span><br><span class="line">   	<span class="built_in">namedWindow</span>(<span class="string">&quot;Canny&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   	<span class="built_in">imshow</span>(<span class="string">&quot;Canny&quot;</span>, dst);</span><br><span class="line">   	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        网上随便找了一张图，实验结果是这样的。值得注意的是：Canny算法的output是二值图像，其中白色像素表示边缘，黑色像素表示非边缘。</p>
<img src="result1.png" alt="result1" style="zoom:67%;" />

<h2 id="直线检测Line-detection"><a href="#直线检测Line-detection" class="headerlink" title="直线检测Line detection"></a>直线检测Line detection</h2><p>​        霍夫变换直线检测是最基本的算法，也是今天学习和使用到的。他有<code>HoughLines</code>和<code>HoughLinesP</code>两种，后者是前者的优化，但并不意味着<code>HoughLines</code>完全被取代，他们适用于不同的场景，大家可以根据实际需要自行选择。</p>
<p>​        需要我们注意的是霍夫直线检测是从二值图像中检测直线(线段)，所以在调用<code>HoughLines</code>或<code>HoughLinesP</code>算法前，要先将图像转换成二值图像，通常在之前先使用<code>Canny</code>将其简化成只有边缘特征的二值图像。</p>
<p>​        这里我使用了OpenCV官方文档提供的示例代码进行测试。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">HoughLinesP算法参数：</span><br><span class="line"><span class="code">	InputArray 	image,  //  8位的单通道二值图像。对于其他类型，在进行霍夫变换之前，需要将其修改为这个指定的格式</span></span><br><span class="line"><span class="code">	OutputArray lines,  // 输出的直线集合</span></span><br><span class="line"><span class="code">	double 	rho,  // 以像素为单位的距离 r 的精度。一般情况下，使用的精度是 1</span></span><br><span class="line"><span class="code">	double 	theta,  // 角度 θ 的精度。一般情况下，使用的精度是 pi/180，表示要搜索可能的角度</span></span><br><span class="line"><span class="code">	int 	threshold,  // 阈值。该值越小，判定出的直线越多；值越大，判定出的直线就越少</span></span><br><span class="line"><span class="code">	double 	minLineLength = 0,  // 控制「接受直线的最小长度」的值，默认值为 0</span></span><br><span class="line"><span class="code">	double 	maxLineGap = 0  // 控制接受共线线段之间的最小间隔，默认值为 0</span></span><br></pre></td></tr></table></figure>

<p>​        实验代码，参数可以自行调整。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	Mat src, dst, color_dst;</span><br><span class="line">   	src = <span class="built_in">imread</span>(<span class="string">&quot;../../pictureRepo/building.jpg&quot;</span>);</span><br><span class="line">   	<span class="built_in">Canny</span>(src, dst, <span class="number">50</span>, <span class="number">200</span>, <span class="number">3</span>);</span><br><span class="line">   	<span class="built_in">cvtColor</span>(dst, color_dst, COLOR_GRAY2BGR);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   COLOR_GRAY2BGR参数表示将灰度图像转换为3通道的BGR彩色图像。</span></span><br><span class="line"><span class="comment">   经过该转换后，color_dst中每个像素的R、G、B三个分量的值都相同，即为该像素的灰度值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   	vector&lt;Vec4i&gt; lines;</span><br><span class="line">   	<span class="built_in">HoughLinesP</span>(dst, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">200</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">   	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++)</span><br><span class="line">   	&#123;</span><br><span class="line">       	<span class="built_in">line</span>(color_dst, <span class="built_in">Point</span>(lines[i][<span class="number">0</span>], lines[i][<span class="number">1</span>]),</span><br><span class="line">           	<span class="built_in">Point</span>(lines[i][<span class="number">2</span>], lines[i][<span class="number">3</span>]), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="built_in">namedWindow</span>(<span class="string">&quot;Orgin&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   	<span class="built_in">imshow</span>(<span class="string">&quot;Orgin&quot;</span>, src);</span><br><span class="line">   	<span class="built_in">namedWindow</span>(<span class="string">&quot;HoughLinesP&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   	<span class="built_in">imshow</span>(<span class="string">&quot;HoughLinesP&quot;</span>, color_dst);</span><br><span class="line">   	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        实验结果如下。</p>
<p>​        这是一个OpenCV官方文档提供的示例图片:</p>
<img src="result2_1.png" alt="result2_1" style="zoom: 25%;" />

<p>​        这是上述程序在概率霍夫变换后的输出：</p>
<img src="result2_2.png" alt="result2_2" style="zoom:25%;" />

<p>​        这是用<code> HoughLinesP</code>的结果，使用<code>HoughLines</code>进行检测出现比较严重的误判。我猜想的原因是这样的：根据官方文档的描述，<code> HoughLinesP</code>检测出来的是一条条可以控制长短的线段，而<code> HoughLines</code>只能检测出完整的直线。所以除了一些特殊的情景外，使用<code> HoughLinesP</code>的检测结果会更精确。</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud02</title>
    <url>/2023/12/19/springcloud02/</url>
    <content><![CDATA[<p>springcloud入门笔记。</p>
<span id="more"></span>

<h2 id="1、Nacos配置管理"><a href="#1、Nacos配置管理" class="headerlink" title="1、Nacos配置管理"></a>1、Nacos配置管理</h2><p>Nacos除了可以做注册中心，还可以进行配置管理。</p>
<h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><p>当微服务部署的实例越来越多时，逐个修改微服务实例的配置太过繁琐，所以我们需要一种统一配置管理的方案，可以集中管理所有实例的配置。</p>
<img src="image-20231127102521377.png" alt="image-20231127102521377" style="zoom:50%;" />

<p>Nacos一方面可以做配置的集中管理，另一方面可以在配置变更时及时通知微服务进行配置的热更新。</p>
<h4 id="在nacos中添加配置文件"><a href="#在nacos中添加配置文件" class="headerlink" title="在nacos中添加配置文件"></a>在nacos中添加配置文件</h4><p><img src="image-20231127103043283.png" alt="image-20231127103043283"></p>
<p>在弹出的表单中填写配置信息：</p>
<p><img src="image-20231127103445612.png" alt="image-20231127103445612"></p>
<blockquote>
<p>项目的核心配置，需要<strong>热更新的配置</strong>才有放到nacos配置中心管理的必要；基本不会变更的基础配置还是要保存在微服务本地。</p>
</blockquote>
<h4 id="从微服务中拉取配置"><a href="#从微服务中拉取配置" class="headerlink" title="从微服务中拉取配置"></a>从微服务中拉取配置</h4><p>微服务需要拉取nacos中管理的配置，并且与本地application配置文件中的配置合并，才能完成项目的启动。</p>
<p>从微服务拉取配置我们需要先访问nacos再读取本地配置，但是nacos的地址是配置在本地application.yml配置文件中的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>    </span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure>

<p>尚未读取application.yml配置，无法知道nacos的地址，因此spring引入了一种新的配置文件：<code>bootstrap.yaml</code>文件，会在application.yml之前被读取：</p>
<p><img src="image-20231127104303113.png" alt="image-20231127104303113"></p>
<ul>
<li><p>引入nacos-config依赖</p>
<p>首先在user-service服务中，引入nacos-config的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加bootstrap.yaml文件</p>
<p>这里会根据<code>spring.cloud.nacos.server-addr</code>获取nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;. $&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id来读取配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span>  <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境，这里是dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>  <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span>  <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure></li>
</ul>
<img src="image-20231127111629380.png" alt="image-20231127111629380" style="zoom: 67%;" />

<ul>
<li><p>读取nacos配置</p>
<p>在user-service中的Controller层中添加业务逻辑，读取nacos配置中心的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径： /user/110</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/time&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面访问可以看到效果：</p>
<p><img src="image-20231127164135719.png" alt="image-20231127164135719"></p>
</li>
</ul>
<h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>配置热更新是指修改nacos的配置后，微服务中无需重启即可让配置生效。</p>
<p>要实现配置的热更新，有两种方式：</p>
<h4 id="方式一（不推荐）"><a href="#方式一（不推荐）" class="headerlink" title="方式一（不推荐）"></a>方式一（不推荐）</h4><p>在<code>@Value</code>注入的变量所在类上添加注释<code>@RefreshScope</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span>  <span class="comment">// 在新版springcloud应该已经不支持了，而且本身就不推荐使用 -- 改用config配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><ul>
<li><p>步骤一</p>
<p>使用<code>@ConfigurationProperties</code>注释代替<code>@Value</code>注释：在user-service服务中，添加一个类来读取<code>pattern.dateformat</code>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span>  <span class="comment">// pattern.dateformat的pattern前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>步骤二</p>
<p>在Controller层使用<code>PatternProperties</code>类代替<code>@Value</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line"><span class="comment">//    private String dateformat;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/time&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 从@Value的变量值改为：patternProperties.getDateformat() </span></span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    <img src="image-20231127170830419.png" alt="image-20231127170830419"></p>
<h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><p>微服务在启动时，会从nacos中读取多个配置文件如：</p>
<ul>
<li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：<code>userservice-dev.yaml</code>；</p>
</li>
<li><p><code>[spring.application.name].yaml</code>，例如：<code>userservice.yaml</code>，像这个配置文件不包含环境，因此可以被多个环境所共享。</p>
</li>
</ul>
<p>通过案例来实现配置共享：</p>
<ul>
<li><p>添加一个环境共享配置</p>
<img src="image-20231127171406884.png" alt="image-20231127171406884" style="zoom:50%;" /></li>
<li><p>在微服务中读取共享配置</p>
<ul>
<li><p>在user-service服务中，在<code>PatternProperties</code>配置类中添加读取新的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String envSharedValue;  <span class="comment">// 新添加的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Controller层中添加新的mapping方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取共享配置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/prop&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PatternProperties <span class="title function_">properties</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> patternProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>UserServiceApplication(8081)使用的profiles是<code>dev</code>（在<code>bootstrap.yaml</code>文件中定义了dev环境），UserServiceApplication(8082)使用的profiles是<code>test</code>：</p>
<img src="image-20231127172329802.png" alt="image-20231127172329802" style="zoom:67%;" />

<p>所以从8082端口进行访问是无法得到<code>userservice-dev.yaml</code>配置文件中的配置信息的：</p>
<img src="image-20231127172534020.png" alt="image-20231127172534020" style="zoom:67%;" />

<p>尽管如此，在<code>userservice.yaml</code>中的配置是共享的，无论在dev还是在test环境中都可以读取到：</p>
<img src="image-20231127173139114.png" alt="image-20231127173139114" style="zoom:67%;" />

<p><strong>配置共享的优先级</strong></p>
<p>当nacos、服务本地出现相同属性时，优先级：</p>
<img src="image-20231127174022871.png" alt="image-20231127174022871" style="zoom:67%;" />

<h2 id="2、Feign远程调用"><a href="#2、Feign远程调用" class="headerlink" title="2、Feign远程调用"></a>2、Feign远程调用</h2><p>先前我们在服务消费者（order-service）中利用<code>RestTemplate</code>发起远程调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 url地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line"><span class="comment">// 2.2 通过restTemplate发起调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br></pre></td></tr></table></figure>

<p>缺点：① 代码可读性差； ② 参数复杂URL难以维护.</p>
<blockquote>
<p>比如我在搜索引擎搜索“java”，就有很复杂的URL参数。</p>
<p><img src="image-20231128085844270.png" alt="image-20231128085844270"></p>
</blockquote>
<p>Feign是一个<strong>声明式的http客户端</strong>，官方地址：<a href="https://github.com/OpenFeign/feign%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%97%B6%E5%AE%9E%E7%8E%B0HTTP%E8%AF%B7%E6%B1%82%E3%80%82">https://github.com/OpenFeign/feign，作用是帮助我们远程调用时实现HTTP请求。</a></p>
<h3 id="Feign代替RestTemplate"><a href="#Feign代替RestTemplate" class="headerlink" title="Feign代替RestTemplate"></a>Feign代替RestTemplate</h3><ul>
<li><p>步骤1：引入依赖</p>
<p>在服务消费者（order-service）中引入Feign依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>步骤2：启动类添加注解开启功能</p>
<p>在服务消费者（order-service）的启动类添加注解开启Feign功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.lijiacheng.order.dao&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>  <span class="comment">// 开启Feign</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>步骤3：编写Feign客户端</p>
<p>在服务消费者（order-service）中新建一个接口（客户端），基于SpringMVC注解来声明远程调用的信息：</p>
<ul>
<li>服务名称：userservice</li>
<li>请求方式：GET</li>
<li>请求路径：<code>/user/&#123;id&#125;</code></li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>步骤4：利用 Feign远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;  <span class="comment">// Feign的客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderDao.findById(orderId);</span><br><span class="line">    <span class="comment">// 2.Feign远程调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userClient.findById(order.getUserId());</span><br><span class="line">    <span class="comment">// 3.存入order</span></span><br><span class="line">    order.setUser(u);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign. Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注解</td>
</tr>
<tr>
<td>feign. Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。有两种方式进行Feign配置的自定义：</p>
<h4 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h4><p>基于配置文件的方式修改Feign配置可以针对单个服务或针对所有服务：</p>
<ul>
<li><p>单个服务</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">	<span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">userservice:</span>  <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">            <span class="attr">logger-level:</span> <span class="string">full</span>  <span class="comment"># 日志级别</span></span><br></pre></td></tr></table></figure></li>
<li><p>所有服务</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">	<span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">default:</span>  <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">            <span class="attr">logger-level:</span> <span class="string">full</span>  <span class="comment"># 日志级别</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>而日志的级别分为四种：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
</blockquote>
<h4 id="java代码方式"><a href="#java代码方式" class="headerlink" title="java代码方式"></a>java代码方式</h4><p>声明一个配置类，再在配置类里声明一个<code>Logger.Level</code>的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC;  <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是<strong>局部生效</strong>，则把它放到对应的<code>@FeignClient</code>这个注解中：</p>
<img src="image-20231128150240572.png" alt="image-20231128150240572" style="zoom:67%;" />

<p>如果是<strong>全局生效</strong>，则把它放到启动类的<code>@EnableFeignClients</code>注解中：</p>
<img src="image-20231128150457749.png" alt="image-20231128150457749" style="zoom: 67%;" />

<h3 id="Feign使用优化"><a href="#Feign使用优化" class="headerlink" title="Feign使用优化"></a>Feign使用优化</h3><p>Feign底层发起http请求依赖于其他的框架，其底层客户端实现包括：</p>
<ul>
<li>URLConnection：默认实现，不支持连接池</li>
<li>Apache HttpClient：支持连接池</li>
<li>OKHttp：支持连接池</li>
</ul>
<p>因此提高Feign性能的主要手段就是使用连接池代替默认的URLConnection，这里使用Apache的HttpClient来展示：</p>
<p>1）引入HttpClient依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）配置连接池</p>
<p>在服务消费者order-service的application.yml配置文件中添加配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">userservice:</span>  <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">            <span class="attr">logger-level:</span> <span class="string">full</span>  <span class="comment"># 日志级别</span></span><br><span class="line">      <span class="attr">httpclient:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 开启feign对于HttpClient的支持</span></span><br><span class="line">        <span class="attr">max-connections:</span> <span class="number">200</span>  <span class="comment"># 最大的连接数</span></span><br><span class="line">        <span class="attr">max-connections-per-route:</span> <span class="number">50</span>  <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Feign的优化总结：</p>
<p>1、日志级别尽量用basic</p>
<p>2、使用HttpClient或OKHttp代替URLConnection框架</p>
<p>①  引入feign-httpClient依赖</p>
<p>②  配置文件开启httpClient功能，设置连接池参数</p>
</blockquote>
<h3 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h3><p>Feign的客户端与服务提供者的controller代码非常相似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式（不常用）"><a href="#继承方式（不常用）" class="headerlink" title="继承方式（不常用）"></a>继承方式（不常用）</h4><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p>
<p>2）Feign客户端和Controller都集成改接口</p>
<img src="image-20231128152458984.png" alt="image-20231128152458984" style="zoom: 67%;" />

<ul>
<li>优缺点<ul>
<li>优点：简单、实现了代码共享</li>
<li>缺点：服务提供方、服务消费方紧密耦合；参数列表中的注解映射（上图是<code>id</code>）不会继承，因此在Controller层必须再次声明方法、参数列表和注解。</li>
</ul>
</li>
</ul>
<h4 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h4><p>将Feign的Cilent抽取为独立的模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。例如，将UserClient、User、Feign的默认配置都抽取到一个<code>feign-api</code>包中，所有微服务引用该依赖包，即可直接使用。</p>
<img src="image-20231128152852645.png" alt="image-20231128152852645" style="zoom:50%;" />

<h4 id="实现基于抽取的最佳实践"><a href="#实现基于抽取的最佳实践" class="headerlink" title="实现基于抽取的最佳实践"></a>实现基于抽取的最佳实践</h4><ul>
<li>抽取</li>
</ul>
<p>在feign-api中然后引入feign的starter依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在order-service中编写的UserClient、User、DefaultFeignConfiguration都移到feign-api项目中：</p>
<img src="image-20231128153729213.png" alt="image-20231128153729213" style="zoom:67%;" />

<ul>
<li>在order-service中使用feign-api</li>
</ul>
<p>在order-service中引入feign-api的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lijiacheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包。</p>
<ul>
<li>启动测试</li>
</ul>
<p>服务出现报错：意思是bean没有注册到Spring容器当中。</p>
<p><img src="image-20231128154751428.png" alt="image-20231128154751428"></p>
<p>这是因为<code>UserClient</code>现在在com.lijiacheng.feign.clients包下，而order-service的<code>@EnableFeignClients</code>注解是在com.lijiacheng.order包下，不在同一个包无法扫描到<code>UserClient</code>。</p>
<p><img src="image-20231128155324183.png" alt="image-20231128155324183"></p>
<p><img src="image-20231128155433928.png" alt="image-20231128155433928"></p>
<p><strong>解决包扫描的问题：</strong></p>
<ul>
<li><p>方式一：指定Feign应该扫描的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.lijiacheng.feign.client&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20231128155717559.png" alt="image-20231128155717559"></p>
</li>
<li><p>方式二：指定需要加载的cilents端口<strong>（精准）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20231128155925781.png" alt="image-20231128155925781"></p>
</li>
</ul>
<h2 id="3、Gateway服务网关"><a href="#3、Gateway服务网关" class="headerlink" title="3、Gateway服务网关"></a>3、Gateway服务网关</h2><h3 id="网关是什么"><a href="#网关是什么" class="headerlink" title="网关是什么"></a>网关是什么</h3><p>Gateway网关是所有微服务的统一入口。</p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li>
<li><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由（路由的目标服务有多个时，还需要做负载均衡）。</li>
<li><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</li>
</ul>
<img src="image-20231129195513315.png" alt="image-20231129195513315" style="zoom: 50%;" />

<blockquote>
<p>SpringCloud中网关的实现有gateway和Zuul两种，Zuul是基于Servlet的实现，gateway是基于Spring5提供的WebFlux，具备更好的性能。</p>
</blockquote>
<h3 id="gateway快速入门"><a href="#gateway快速入门" class="headerlink" title="gateway快速入门"></a>gateway快速入门</h3><p>测试一下gateway最主要的路由功能。</p>
<img src="image-20231129203831263.png" alt="image-20231129203831263" style="zoom: 50%;" />

<ul>
<li><p>创建gateway服务，引入依赖</p>
<p><font color="red">如果不导入loadbalancer负载均衡依赖网关会无法使用<code>lb://服务名称</code>.</font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--高版本的SpringCloud需要导入负载均衡依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写基础配置和路由规则</p>
<p>创建application.yml配置文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span>  <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span>  <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>  <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">    <span class="comment"># ===============网关路由配置===============</span></span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span>  <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称 </span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">predicates:</span>  <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>  <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​        将符合断言<code>Path</code>的一切请求，都代理到<code>uri</code>参数指定的地址。本例就是将<code>/user/**</code>开头的请求，代理到userservice服务并根据服务名拉取服务实现负载均衡。</p>
<ul>
<li><p>重启测试</p>
<p>访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1：</a></p>
<p><img src="image-20231129203544994.png" alt="image-20231129203544994"></p>
</li>
</ul>
<h3 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h3><p><code>Predicate Factory</code>读取并处理，转变为路由判断的条件，例如Path=/user/**是按照路径匹配，这个规则是由PathRoutePredicateFactory类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个，我们只需要掌握Path这种路由断言就可以：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>- Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>- Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>- Method=GET,POST</td>
</tr>
<tr>
<td><strong>Path</strong></td>
<td>请求路径必须符合指定规则</td>
<td>- Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>- Query=name, Jack或者-  Query=name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>- RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td></td>
</tr>
</tbody></table>
<h3 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h3><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p>
<img src="image-20231129204438690.png" alt="image-20231129204438690" style="zoom:50%;" />

<h4 id="路由过滤器的种类"><a href="#路由过滤器的种类" class="headerlink" title="路由过滤器的种类"></a>路由过滤器的种类</h4><p>Spring提供了31种不同的路由过滤器工厂，例如：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody></table>
<h4 id="请求头过滤器"><a href="#请求头过滤器" class="headerlink" title="请求头过滤器"></a>请求头过滤器</h4><p>以AddRequestHeader 为例，需求是：给所有进入userservice的请求添加一个请求头：Truth, ljc is a good coder!（“键, 值”形式）</p>
<p>只需要在gateway服务的application配置文件中配置路由过滤即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  <span class="comment"># 路由id</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://userservice</span>  </span><br><span class="line">  <span class="attr">predicates:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/user/**</span>  </span><br><span class="line">  <span class="attr">filters:</span>  <span class="comment"># 过滤器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">ljc</span> <span class="string">is</span> <span class="string">a</span> <span class="string">good</span> <span class="string">coder!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure>

<p>当前过滤器写在userservice路由下，所以仅对访问userservice的请求有效。</p>
<p>在user-service的contoller层加入添加请求头的验证功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加过滤器添加请求头验证功能</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@RequestHeader(value = &quot;Truth&quot;, required = false)</span> String header)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Truth:&quot;</span> + header);</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@RequestHeader</code>表示获取请求头信息，<code>value</code>是获取相应键的请求头信息，<code>required</code>是false允许无此请求头信息，在控制台打印出来。</p>
</blockquote>
<img src="image-20231130100027536.png" alt="image-20231130100027536" style="zoom:67%;" />

<p><img src="image-20231130095800873.png" alt="image-20231130095800873"></p>
<h4 id="默认过滤器"><a href="#默认过滤器" class="headerlink" title="默认过滤器"></a>默认过滤器</h4><p>如果要对<strong>所有的路由都生效</strong>，则可以将过滤器工厂写到default下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span>  <span class="comment"># 网关路由配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  </span><br><span class="line">      <span class="attr">uri:</span> <span class="string">lb://userservice</span>  </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>  </span><br><span class="line">  <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">ljc</span> <span class="string">is</span> <span class="string">a</span> <span class="string">good</span> <span class="string">coder!</span> </span><br></pre></td></tr></table></figure>

<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>网关提供了31种过滤器，但每一种过滤器的作用都是固定的。如果我们希望拦截请求做特定的业务逻辑则没办法实现。全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。<strong>区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</strong></p>
<p>在filter中通过实现<code>GloabalFilter</code>接口编写自定义逻辑，可以实现下列功能：</p>
<ul>
<li>登录状态判断</li>
<li>权限校验</li>
<li>请求限流等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span>  <span class="comment">// 定义过滤器的优先级</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;  <span class="comment">// 定义方式是实现GlobalFilter接口</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange  请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain  用来把请求委托给下一个过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、获取请求参数</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; requestQueryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">// 2、获取authorization请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> requestQueryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、校验</span></span><br><span class="line">        <span class="keyword">if</span>(author.equals(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、拦截</span></span><br><span class="line">        <span class="comment">// 禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);  <span class="comment">// 401</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="image-20231130101732232.png" alt="image-20231130101732232" style="zoom: 67%;" />

<p><img src="image-20231130101748204.png" alt="image-20231130101748204"></p>
<p>在加入正确的请求参数后，过滤器放行，user-service微服务访问生效：</p>
<img src="image-20231130101904495.png" alt="image-20231130101904495" style="zoom:67%;" />

<h3 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter。请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p>
<img src="image-20231130102155750.png" alt="image-20231130102155750" style="zoom: 50%;" />

<p>排序的规则：</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定。</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是<strong>按照声明顺序</strong>从1递增。</li>
<li>当过滤器的order值一样时，会按照 <strong>defaultFilter &gt; 路由过滤器 &gt; GlobalFilter</strong>的顺序执行（想让GlobalFilter先执行将order值调到负数即可）。</li>
</ul>
<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p>
<ul>
<li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p>
</li>
<li><p>域名相同，端口不同：localhost:8080和localhost:8081</p>
</li>
</ul>
<p>跨域问题：<strong>浏览器禁止</strong>请求的发起者与服务端发生跨域<strong>ajax请求</strong>，请求被浏览器拦截的问题；解决方案：CORS。</p>
]]></content>
      <categories>
        <category>SpingCloud</category>
      </categories>
  </entry>
  <entry>
    <title>springcloud02</title>
    <url>/2023/12/06/springcloud01/</url>
    <content><![CDATA[<p>springcloud入门笔记。</p>
<span id="more"></span>

<h2 id="1、微服务"><a href="#1、微服务" class="headerlink" title="1、微服务"></a>1、微服务</h2><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h4><img src="image-20231030145916724.png" alt="image-20231030145916724" style="zoom: 43%;" />

<p><strong>优点：</strong></p>
<ul>
<li>架构简单</li>
<li>部署成本低</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>耦合度高（维护困难、升级困难）</li>
</ul>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>
<img src="image-20231030150020111.png" alt="image-20231030150020111" style="zoom: 50%;" />

<p><strong>优点：</strong></p>
<ul>
<li>降低服务耦合</li>
<li>有利于服务升级和拓展</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务调用关系错综复杂</li>
</ul>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<p>微服务是一种经过良好架构设计的分布式架构方案，在分布式架构的基础上进一步降低了服务之间的耦合性，做到了高内聚、低耦合。</p>
<img src="image-20231030150216934.png" alt="image-20231030150216934" style="zoom:67%;" />

<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>SpringCloud是目前国内使用最广泛的微服务框架，SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配。</p>
<img src="image-20231030150415817.png" alt="image-20231030150415817" style="zoom:50%;" />

<p><font color="red"><strong>注意SpringCloud和Springboot的版本之间有一定的兼容关系：</strong></font></p>
<img src="image-20231030150615075.png" alt="image-20231030150615075" style="zoom:67%;" />

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- version管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2022.0.3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、服务拆分和远程调用"><a href="#2、服务拆分和远程调用" class="headerlink" title="2、服务拆分和远程调用"></a>2、服务拆分和远程调用</h2><h3 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h3><ul>
<li>不同微服务，不要重复开发相同业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ul>
<img src="image-20231030150745297.png" alt="image-20231030150745297" style="zoom:33%;" />

<h3 id="服务拆分案例"><a href="#服务拆分案例" class="headerlink" title="服务拆分案例"></a>服务拆分案例</h3><p>数据库中<code>cloud-user</code>和<code>cloud-order</code>表：</p>
<img src="image-20231030151209448.png" alt="image-20231030151209448" style="zoom:67%;" />

<p>在<code>OrderController</code>层有根据<code>id</code>查询的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据id查询订单并返回</span></span><br><span class="line">    <span class="keyword">return</span> orderService.queryOrderById(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="image-20231030152721464.png" alt="image-20231030152721464"></p>
<p>同样在<code>UserController</code>曾有根据<code>id</code>查询的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="image-20231030153319794.png" alt="image-20231030153319794"></p>
<h3 id="远程调用案例"><a href="#远程调用案例" class="headerlink" title="远程调用案例"></a>远程调用案例</h3><p>每个业务模块对应着自己业务的数据库，不可跨业务访问。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_order?useSSL=false</span>  <span class="comment"># order-service中连接的是本地的cloud_order数据库</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_user?useSSL=false</span>  <span class="comment"># user-service中连接的是本地的cloud-user数据库</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20231030152721464.png" alt="image-20231030152721464"></p>
<p>在<code>order-service</code>模块中查询订单信息时 <code>user == null</code>，而我们希望在<code>order-service</code>的接口中可以根据<code>id</code>查询订单的同时，根据订单中包含的<code>userId</code>查询出用户信息一起返回。</p>
<img src="image-20231030154105602.png" alt="image-20231030154105602" style="zoom: 50%;" />

<p>因此，我们需要在<code>order-service</code>中向<code>user-service</code>发送一个http请求，调用<code>user-service</code>的<code>http://localhost:8081/user/&#123;userId&#125;</code>接口来查询<code>cloud-user</code>数据库的内容。</p>
<p><strong>远程调用步骤：</strong></p>
<ul>
<li><p>注册一个<code>RestTemplate</code>实例到Spring容器中（在启动类中注册<code>Bean</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.lijiacheng.order.dao&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>order-service</code>中的接口方法，通过<code>Order</code>对象的<code>userId</code>来查询<code>User</code></p>
</li>
<li><p>将<code>User</code>对象填充到<code>Order</code>对象一同返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderDao.findById(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.远程查询user</span></span><br><span class="line">        <span class="comment">// 2.1 url地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/user/&quot;</span> + order.getUserId();</span><br><span class="line">        <span class="comment">// 2.2 通过restTemplate发起调用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.存入order</span></span><br><span class="line">        order.setUser(u);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20231030155118802.png" alt="image-20231030155118802"></p>
<h3 id="提供者和消费者"><a href="#提供者和消费者" class="headerlink" title="提供者和消费者"></a>提供者和消费者</h3><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务（提供接口给其它微服务）</p>
<p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）</p>
<blockquote>
<p>服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p>
</blockquote>
<p><img src="image-20231030155844415.png" alt="image-20231030155844415"></p>
<h2 id="3、Eureka注册中心"><a href="#3、Eureka注册中心" class="headerlink" title="3、Eureka注册中心"></a>3、Eureka注册中心</h2><p>假设服务提供者<code>user-service</code>部署了多个实例供服务消费者调用：</p>
<img src="image-20231030160201998.png" alt="image-20231030160201998" style="zoom:33%;" />

<p>那么我们会好奇几个问题：<code>order-service</code>是如何得到<code>user-service</code>实例的ip地址和端口的？有多个消费者时如何选择？服务消费者如何知道提供者实例是否仍然健康？</p>
<h3 id="Eureka的结构和作用"><a href="#Eureka的结构和作用" class="headerlink" title="Eureka的结构和作用"></a>Eureka的结构和作用</h3><p>Eureka是SpringCloud中的一个注册中心，来解决上述问题。</p>
<img src="image-20231030160626368.png" alt="image-20231030160626368" style="zoom: 50%;" />

<p><strong>Eureka原理</strong></p>
<ul>
<li><p>服务注册：<code>user-service</code>服务实例启动后，将自己的信息注册到<code>eureka-server</code>（Eureka服务端）</p>
</li>
<li><p><code>eureka-server</code>保存服务名称到服务实例地址列表的映射关系</p>
</li>
<li><p>服务拉取（服务发现）：<code>order-service</code>根据服务名称，拉取实例地址列表</p>
</li>
<li><p>通过负载均衡算法挑选一个提供者服务，实现远程调用</p>
</li>
<li><p>心跳：<code>user-service</code>会每隔一段时间<strong>（默认30秒）</strong>向<code>eureka-server</code>发起请求，报告自己状态</p>
</li>
</ul>
<blockquote>
<p>一个微服务，既可以是服务提供者，又可以是服务消费者，因此<font color="blue">eureka将服务注册、服务发现等功能统一封装到了<code>eureka-client</code>端</font>。</p>
</blockquote>
<h3 id="搭建eureka-server"><a href="#搭建eureka-server" class="headerlink" title="搭建eureka-server"></a>搭建eureka-server</h3><p>注册中心服务端：<strong>eureka-server</strong>，这必须是一个独立的微服务。</p>
<ul>
<li><p>创建module，引入服务端依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改启动类：<code>@EnableEurekaServer</code>注解用来开启注册中心功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="comment"># eureka的客户端配置</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动服务</p>
<p><img src="image-20231030162051513.png" alt="image-20231030162051513"></p>
</li>
</ul>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>接下来将服务提供者<code>user-service</code>注册到<code>eureka-service</code>中。</p>
<ul>
<li><p>在服务提供者<code>user-service</code>中引入<code>eureka-client</code>依赖（注意这里是client端）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在服务提供者<code>user-service</code>中，修改配置文件，添加服务名称、eureka地址：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动多个服务提供者<code>user-service</code>实例</p>
<p><img src="image-20231030162818082.png" alt="image-20231030162818082"></p>
</li>
</ul>
<img src="image-20231030163102118.png" alt="image-20231030163102118" style="zoom:50%;" />

<p><img src="image-20231030164507443.png" alt="image-20231030164507443"></p>
<h3 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h3><p>将<code>order-service</code>的逻辑修改，向<code>eureka-server</code>拉取<code>user-service</code>的信息，实现服务拉取（服务发现）。</p>
<ul>
<li><p>在服务消费者<code>order-service</code>中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册一致。</p>
</blockquote>
</li>
<li><p>在服务消费者<code>order-service</code>中配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>服务拉取和负载均衡</p>
<p>到<code>eureka-server</code>中拉取服务提供者<code>user-service</code>服务的实例列表，并且实现负载均衡。</p>
<ul>
<li>在<code>RestTemplate</code>（实现远程调用的Bean）中加入表示客户端负载均衡的注释<code>@LoadBalanced</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">// 标注此注解后，RestTemplate就具有了客户端负载均衡能力</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改服务消费者<code>order-service</code>的调用接口中的url路径，用<strong>服务名</strong>代替ip、端口：</p>
<img src="image-20231030170324318.png" alt="image-20231030170324318" style="zoom:80%;" />

<p><img src="image-20231030170046438.png" alt="image-20231030170046438"></p>
</li>
</ul>
<p>向<code>order-service</code>的查询业务重复发送请求（2次）——实现了<strong>负载均衡</strong>。</p>
<p><img src="image-20231030170633134.png" alt="image-20231030170633134"></p>
<p><img src="image-20231030170657000.png" alt="image-20231030170657000"></p>
<blockquote>
<p><font color="red">注意：Springcloud的新版本已经没有ribbon组件（实现负载均衡）了，需要导入以下两个pom依赖：</font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p>上一章节，我们在<code>RestTemplate</code>这个Bean中添加注释<code>@LoadBalanced</code>即可实现负载均衡。</p>
<h3 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h3><p>SpringCloud底层利用一个名为Ribbon的组件来实现负载均衡：</p>
<img src="image-20231031083402421.png" alt="image-20231031083402421" style="zoom: 50%;" />

<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>我们只输入了service名称，就获取到了服务实例的ip和端口——就是<code>LoadBalancerInterceptor</code>，这个类会在对<code>RestTemplate</code>远程调用的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p>
<p><strong>负载均衡原理：</strong>首先通过<code>LoadBalancerInterceptor</code>拦截了用户的http请求，获取用户请求的URL和服务id，交给<code>LoadBalancerClient</code>；<code>LoadBalancerClient</code>利用内置的负载均衡算法（默认是轮询）选择服务列表中的端口号用于服务。</p>
<p><img src="image-20231031084059739.png" alt="image-20231031084059739"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Ribbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改：</p>
<img src="image-20231031084956806.png" alt="image-20231031084956806" style="zoom:67%;" />

<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p>
<img src="image-20231031090129412.png" alt="image-20231031090129412" style="zoom: 50%;" />

<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon<strong>默认</strong>的负载均衡规则</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
<h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><blockquote>
<p><strong>注意</strong>：一般用默认的负载均衡规则，不做修改。</p>
</blockquote>
<ul>
<li><p>方法一：代码方式——在服务消费者<code>order-service</code>中的启动类中，定义一个新的(Bean)<code>IRule</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：配置文件方式——在服务消费者<code>order-service</code>的yml文件中，添加新的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h3><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 饥饿加载</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure>

<h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>SpringCloud Alibaba也推出了一个名为Nacos的注册中心。</p>
<h3 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h3><blockquote>
<p>Windows版</p>
</blockquote>
<p>1、下载安装包</p>
<p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p>
<p>2、目录说明</p>
<img src="image-20231031092058493.png" alt="image-20231031092058493" style="zoom:50%;" />

<p>3、端口配置</p>
<p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。<strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p>
<img src="image-20231031092212309.png" alt="image-20231031092212309" style="zoom: 50%;" />

<img src="image-20231031092254476.png" alt="image-20231031092254476" style="zoom:50%;" />

<p>4、启动</p>
<p>进行bin目录，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<img src="image-20231031092335416.png" alt="image-20231031092335416" style="zoom:50%;" />

<p>5、访问</p>
<p>默认的账号和密码都是nacos。</p>
<h3 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a>服务注册到Nacos</h3><p>Nacos和Eureka对于微服务来说没有什么区别，主要差异在：① 依赖不同；② 服务地址不同。</p>
<ul>
<li><p> 引入依赖</p>
</li>
<li><p>父依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos的管理依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2022.0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在服务的消费者和提供者<code>order-service</code>和<code>user-service</code>中引入discovery依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置nacos地址</p>
<p>在yml文件中配置nacos地址：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动微服务</p>
<p><img src="image-20231031140453859.png" alt="image-20231031140453859"></p>
</li>
</ul>
<h3 id="服务分级存储模型"><a href="#服务分级存储模型" class="headerlink" title="服务分级存储模型"></a>服务分级存储模型</h3><p>举例来说，<code>user-service</code>是服务，一个服务可以包含多个集群（如杭州、上海），每个集群下可以有多个实例，形成分级模型：</p>
<img src="image-20231031140714932.png" alt="image-20231031140714932" style="zoom: 50%;" />

<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群：</p>
<img src="image-20231031140833581.png" alt="image-20231031140833581" style="zoom: 50%;" />

<h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>修改<code>user-service</code>的application.yml文件，添加集群配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>  <span class="comment"># nacos服务地址</span></span><br><span class="line">        <span class="attr">discovery:</span></span><br><span class="line">          <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>

<img src="image-20231031141156542.png" alt="image-20231031141156542" style="zoom:50%;" />

<p>再次复制一个<code>user-service</code>启动配置，添加属性：</p>
<img src="image-20231031141248389.png" alt="image-20231031141248389" style="zoom:67%;" />

<img src="image-20231031141418717.png" alt="image-20231031141418717" style="zoom:33%;" />

<h4 id="同集群优先的负载均衡"><a href="#同集群优先的负载均衡" class="headerlink" title="同集群优先的负载均衡"></a>同集群优先的负载均衡</h4><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡；因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例：</p>
<p>因为作为服务消费者的<code>order-service</code>要远程调用服务提供者<code>user-service</code>，所以要在<code>order-service</code>中配置Nacos负载均衡的设置：</p>
<ul>
<li><p>将<code>order-service</code>的服务也加入到前面的HZ集群</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务地址</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure></li>
<li><p>在服务消费者<code>order-service</code>中加入负载均衡设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡的配置规则</span></span><br><span class="line"><span class="attr">userservice:</span>  <span class="comment"># 要做配置的微服务名称</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><font color="red"><strong>出现了问题：Nacos注册中心，访问不了order-service服务：</strong></font></p>
<p><img src="image-20231101084020891.png" alt="image-20231101084020891"></p>
<p>【解决方案】在新版本的springcloud（我用的是2022.0.0）中已经没有默认的ribbon负载均衡组件了，需要手动导入这个<strong>负载均衡依赖</strong>（不用导入ribbon依赖了）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="负载均衡的权重配置"><a href="#负载均衡的权重配置" class="headerlink" title="负载均衡的权重配置"></a>负载均衡的权重配置</h3><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p>
<img src="image-20231031203443346.png" alt="image-20231031203443346" style="zoom:50%;" />

<h3 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h3><ul>
<li>nacos中可以有多个<code>namespace</code>；</li>
<li><code>namespace</code>下可以有<code>group、service</code>等；</li>
<li>不同<code>namespace</code>之间相互隔离，例如不同<code>namespace</code>的服务互相不可见；</li>
</ul>
<img src="image-20231031203554894.png" alt="image-20231031203554894" style="zoom: 25%;" />

<ul>
<li>创建namespace</li>
</ul>
<img src="image-20231101084151523.png" alt="image-20231101084151523" style="zoom:50%;" />

<ul>
<li><p>给微服务配置namespace</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> </span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> </span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">6adbcdc1-bb2e-460c-a447-e100eae322d2</span> <span class="comment"># 命名空间配置</span></span><br></pre></td></tr></table></figure>

<img src="image-20231101084555881.png" alt="image-20231101084555881" style="zoom:67%;" /></li>
</ul>
<img src="image-20231101084614439.png" alt="image-20231101084614439" style="zoom:67%;" />

<p>这时候访问<code>order-service</code>会导致远程调用<code>user-service</code>时找不到<code>userservice</code>的实例，这是因为它们的namespace不同！</p>
<h3 id="Nacos和Eureka的比较"><a href="#Nacos和Eureka的比较" class="headerlink" title="Nacos和Eureka的比较"></a>Nacos和Eureka的比较</h3><p>Nacos的服务实例分为两种类型：</p>
<ul>
<li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li>
</ul>
<p>将一个服务设置为永久实例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure>

<p>Nacos与eureka的共同点：</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
<p>Nacos与Eureka的区别：</p>
<ul>
<li><p>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</p>
</li>
<li><p>临时实例心跳不正常会被剔除，非临时实例则不会被剔除（等待重新恢复健康）</p>
</li>
<li><p>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p>
</li>
<li><p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</p>
<blockquote>
<p><strong>AP（可用性和分区容忍性）</strong>：</p>
<ul>
<li>AP模型强调在面对网络分区或节点故障时保持系统的可用性。</li>
<li>在AP模型下，系统会允许数据在不同部分之间存在短暂的不一致性，以保证系统的可用性。这意味着在某些情况下，系统可能会返回陈旧或部分不一致的数据，但不会拒绝请求。</li>
<li>AP系统通常用于需要高可用性和容忍分区故障的场景，例如，社交媒体应用或内容分发网络（CDN）。</li>
</ul>
<p><strong>CP（一致性和分区容忍性）</strong>：</p>
<ul>
<li><p>CP模型强调在面对网络分区或节点故障时保持数据的一致性。</p>
</li>
<li><p>在CP模型下，系统会确保数据的一致性，即使这可能导致一些部分的系统不可用。系统会拒绝写入或读取请求，直到数据一致性得到满足。</p>
</li>
<li><p>CP系统通常用于需要数据一致性和容忍分区故障的场景，例如，金融交易系统或医疗记录系统。</p>
<p>​                                                                                                                                                                                                   ——ChatGPT</p>
</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>SpingCloud</category>
      </categories>
  </entry>
  <entry>
    <title>利用Git实现多台电脑同步工作</title>
    <url>/2023/05/26/git/</url>
    <content><![CDATA[<p>去年新买了一台mac台式机放在宿舍，就不用每天回到宿舍还要把笔记本插上各种线再启动了。有时候在外面写的代码想要回到宿舍继续用台式机写，所以我需要在两台电脑之间实现无缝协作，即需求：<strong>两台电脑里同一个文件夹的内容可以相互同步</strong>。</p>
<span id="more"></span>

<p>首先说一下，我下面总结的只是我使用git的一个小应用，git的功能强大作用远远不止这些，更多的功能仍然等待着去挖掘呢。</p>
<blockquote>
<p>安装Git：下载地址 <a href="https://git-scm.com/download">https://git-scm.com/download</a> ，安装一路点next即可。</p>
</blockquote>
<img src="image-20230516105819093.png" alt="image-20230516105819093" style="zoom: 50%;" />

<h2 id="构建本地仓库"><a href="#构建本地仓库" class="headerlink" title="构建本地仓库"></a>构建本地仓库</h2><p>1、在本地建立一个目录，在该目录里防止需要同步的文件。</p>
<img src="image-20230516104922621.png" alt="image-20230516104922621" style="zoom:67%;" />

<p>2、在当前目录下打开git控制台</p>
<p>界面为：</p>
<img src="image-20230516105212427.png" alt="image-20230516105212427" style="zoom: 50%;" />

<p>3、初始化本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>输出<code>Initialized empty Git repository in C:/Users/13668/Desktop/git/.git/</code> 即成功。</p>
<p>4、Add文件到暂存区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>上述命令是添加所有文件到暂存区，但不包含已删除的。或者使用<code>git add xxx(文件名)</code>来添加指定文件。</p>
<p>5、commit文件到本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交注释&quot;</span><br></pre></td></tr></table></figure>

<p>提交注释为本次提交的说明，这里我直接使用提交的日期作为提交注释。</p>
<h2 id="将本地仓库推送到github上"><a href="#将本地仓库推送到github上" class="headerlink" title="将本地仓库推送到github上"></a>将本地仓库推送到github上</h2><p>1、在github上创建新仓库</p>
<p><img src="image-20230516110734048.png" alt="image-20230516110734048"></p>
<p><strong>2、将本地仓库与远程仓库关联</strong></p>
<p>一个新建的空仓库会有一个提示页面，对应不同情况的操作命令。我们现在已经创建好本地仓库，需要做的就是将本地仓库推送到远程，也就是情况2。直接复制提示页面给出的命令即可。</p>
<p><img src="image-20230516110844342.png" alt="image-20230516110844342"></p>
<ul>
<li><p>添加远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:KiCheng/Git.git</span><br></pre></td></tr></table></figure>

<p><img src="D:\spring\image-20230516111217156.png" alt="image-20230516111217156"></p>
<p>可以通过如下命令查看与本地仓库关联的远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出如下：</p>
<p>origin  <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a>:KiCheng/Git.git (fetch)<br>origin  <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>:KiCheng/Git.git (push)</p>
</blockquote>
<p>删除与远程仓库的关联：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li>
<li><p>推送到远程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<img src="image-20230516111627417.png" alt="image-20230516111627417" style="zoom:67%;" />

<p>再次刷新github中的仓库，本地仓库的内容已经推送到远程了。</p>
<p><img src="image-20230516111723812.png" alt="image-20230516111723812"></p>
</li>
</ul>
<h2 id="将远程仓库clone到本地"><a href="#将远程仓库clone到本地" class="headerlink" title="将远程仓库clone到本地"></a>将远程仓库clone到本地</h2><p>在另一台安装好了git的电脑上，在文件夹目录下打开git控制台。输入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:账户名/仓库名.git</span><br></pre></td></tr></table></figure>

<p>将上述替换成自己的github账户名和仓库名：</p>
<p><img src="image-20230526165230679.png" alt="image-20230526165230679"></p>
<p>这就说明clone成功了，在当前文件夹就可以找到远程备份的文件了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>瑞吉外卖项目实战day2</title>
    <url>/2023/07/06/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day2/</url>
    <content><![CDATA[<p>适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。</p>
<span id="more"></span>

<p>后面我逐渐省略了一些功能的记录，主要是因为和前面的业务万变不离其宗，如果要看详细的代码可以到我的github仓库下拉<a href="https://github.com/KiCheng/reggie">reggie代码</a>。</p>
<h2 id="业务实现（后台系统）"><a href="#业务实现（后台系统）" class="headerlink" title="业务实现（后台系统）"></a>业务实现（后台系统）</h2><h3 id="新增套餐"><a href="#新增套餐" class="headerlink" title="新增套餐"></a>新增套餐</h3><p><strong>数据模型</strong></p>
<p><img src="image-20230706103537857.png" alt="image-20230706103537857"></p>
<p><strong>表现层要素</strong></p>
<p><img src="image-20230706103038582.png" alt="image-20230706103038582"></p>
<p>请求类型：POST</p>
<p>请求路径：<code>/setmeal</code></p>
<p><img src="image-20230706103143613.png" alt="image-20230706103143613"></p>
<p>请求参数：json格式的数据，除了setmeal套餐的基本信息外，还有套餐内的菜品信息setmealDishes也封装成json数组的格式。<font color="blue">（还有idType和dishList是什么，当请求参数json数据key大于dto对象的时候，可以正常封装吗？）</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addSetmeal</span>(prams)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;套餐添加成功！&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">ruleForm</span>.<span class="title function_">resetFields</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dishList</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dishTable</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">categoryId</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">code</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">image</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">description</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">dishList</span>: [],</span><br><span class="line">          <span class="attr">status</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">idType</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：<code>Result&lt;String&gt;</code>类型</p>
<p><strong>核心业务思路</strong></p>
<p>仍然是操作setmeal数据表和setmeal_dish数据表，要在Service类上加事务管理注释<code>@Transactional</code>。</p>
<p>步骤1：在Service类自定义新增套餐的业务层方法，并在类上加事务管理注释<code>@Transactional</code>；</p>
<p>步骤2：调用Service层原生的save方法将SetmealDto对象传入并保存；</p>
<p>步骤3：接下来要对setmeal_dish数据表进行添加多条数据，可以从dto对象中get到setmealDishes这个属性列表，但是不能直接将setmealDishes列表<code>saveBatch</code>，要对其赋值setmeal_id值；</p>
<p>步骤4：通过dto对象get到id值（执行了save操作，在setmeal表已经通过雪花算法为dto对象生成了id属性值），将其赋给setmealDishes列表的setmealDish.setmealId套餐id值；</p>
<p>步骤5：调用Service层的<code>saveBatch</code>将setmealDishes列表添加到setmeal_dish数据表中。</p>
<h3 id="套餐信息分页查询"><a href="#套餐信息分页查询" class="headerlink" title="套餐信息分页查询"></a>套餐信息分页查询</h3><p><strong>表现层要素</strong></p>
<p><img src="image-20230706111444821.png" alt="image-20230706111444821"></p>
<p>请求类型：GET</p>
<p>请求路径：<code>/setmeal/page</code></p>
<p>请求参数：普通参数page、pageSize和可选参数name</p>
<p>返回值类型：<code>Result&lt;Page&gt;</code></p>
<p><strong>核心业务思路</strong></p>
<p>跟前面的菜品信息分页查询一模一样。</p>
<h3 id="删除套餐"><a href="#删除套餐" class="headerlink" title="删除套餐"></a>删除套餐</h3><p><strong>表现层要素</strong></p>
<p><img src="image-20230706113845252.png" alt="image-20230706113845252"></p>
<p>请求类型：DELETE</p>
<p>请求路径：<code>/setmeal</code></p>
<p>请求参数：普通参数ids，因为批量删除的id可能有多个，所以这里的方法形参是<code>List&lt;Long&gt; ids</code>，要加<code>@RequestParam</code>注解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">deleteSetmeal</span>(type === <span class="string">&#x27;批量&#x27;</span> ? <span class="variable language_">this</span>.<span class="property">checkList</span>.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) : id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;删除成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：<code>Result&lt;String&gt;</code></p>
<p><strong>核心业务思路</strong></p>
<p>首先操作setmeal表删除套餐信息，再操作setmeal_dish表删除setmeal_id字段 = ids的所有数据。</p>
<h3 id="批量起售停售"><a href="#批量起售停售" class="headerlink" title="批量起售停售"></a>批量起售停售</h3><p><img src="image-20230706163258312.png" alt="image-20230706163258312"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">changeStatus</span><span class="params">(<span class="meta">@PathVariable</span> Integer status, <span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        LambdaUpdateWrapper&lt;Setmeal&gt; lambdaUpdateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaUpdateWrapper.in(Setmeal::getId, ids);</span><br><span class="line">        lambdaUpdateWrapper.set(Setmeal::getStatus, status);</span><br><span class="line">        setmealService.update(lambdaUpdateWrapper);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;状态修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="订单明细分页查询"><a href="#订单明细分页查询" class="headerlink" title="订单明细分页查询"></a>订单明细分页查询</h3><p>跟前面的分页查询相比就是可选参数变多了，还有就是关注一下“时间”作为可选参数如何处理。</p>
<p><img src="image-20230706203744254.png" alt="image-20230706203744254"></p>
<p>可选参数：</p>
<img src="image-20230706203801378.png" alt="image-20230706203801378" style="zoom:67%;" />

<p><img src="image-20230706203823723.png" alt="image-20230706203823723"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Page&gt; <span class="title function_">pageSelect</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> pageSize, String number,String beginTime, String endTime)</span>&#123;</span><br><span class="line">    Page&lt;Orders&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page ,pageSize);</span><br><span class="line">    LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.like(StringUtils.hasText(number), Orders::getNumber, number);</span><br><span class="line">    lambdaQueryWrapper.gt(StringUtils.hasText(beginTime), Orders::getOrderTime, beginTime)</span><br><span class="line">            .lt(StringUtils.hasText(endTime), Orders::getOrderTime, endTime);</span><br><span class="line">    lambdaQueryWrapper.orderByDesc(Orders::getOrderTime);</span><br><span class="line"></span><br><span class="line">    orderService.page(pageInfo, lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="业务实现（移动端系统）"><a href="#业务实现（移动端系统）" class="headerlink" title="业务实现（移动端系统）"></a>业务实现（移动端系统）</h2><h3 id="手机验证码登录"><a href="#手机验证码登录" class="headerlink" title="手机验证码登录"></a>手机验证码登录</h3><p><strong>流程分析</strong></p>
<ol>
<li>点击获取验证码，页面向服务端发送第一次请求，请求服务器随机生成要求的验证码并发送到表单输出的手机号中；</li>
<li>点击登录，页面向服务端发送第二次请求，携带表单输入的验证码和Session中储存的验证码进行比对，确定是否成功登录。</li>
</ol>
<p><strong>核心业务思路</strong></p>
<ul>
<li>发送验证码请求</li>
</ul>
<p>导入手机验证的依赖坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云短信服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-dysmsapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写一个工具类（根据阿里云短信服务的帮助文档改的），用于发送手机验证码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 短信发送工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送短信</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> signName 签名</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> templateCode 模板</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> phoneNumbers 手机号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String signName, String templateCode,String phoneNumbers,String param)</span>&#123;</span><br><span class="line">      <span class="type">DefaultProfile</span> <span class="variable">profile</span> <span class="operator">=</span> DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);  <span class="comment">// accessKeyId, secret</span></span><br><span class="line">      <span class="type">IAcsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAcsClient</span>(profile);</span><br><span class="line"></span><br><span class="line">      <span class="type">SendSmsRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendSmsRequest</span>();</span><br><span class="line">      request.setSysRegionId(<span class="string">&quot;cn-hangzhou&quot;</span>);</span><br><span class="line">      request.setPhoneNumbers(phoneNumbers);</span><br><span class="line">      request.setSignName(signName);</span><br><span class="line">      request.setTemplateCode(templateCode);</span><br><span class="line">      request.setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+param+<span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">SendSmsResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getAcsResponse(request);</span><br><span class="line">         System.out.println(<span class="string">&quot;短信发送成功&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随机生成随机验证码的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机生成验证码工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长度为4位或者6位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">generateValidateCode</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">4</span>)&#123;</span><br><span class="line">            code = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">9999</span>);<span class="comment">//生成随机数，最大为9999</span></span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">                code = code + <span class="number">1000</span>;<span class="comment">//保证随机数为4位数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(length == <span class="number">6</span>)&#123;</span><br><span class="line">            code = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">999999</span>);<span class="comment">//生成随机数，最大为999999</span></span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="number">100000</span>)&#123;</span><br><span class="line">                code = code + <span class="number">100000</span>;<span class="comment">//保证随机数为6位数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;只能生成4位或6位数字验证码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成指定长度字符串验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateValidateCode4String</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rdm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hash1</span> <span class="operator">=</span> Integer.toHexString(rdm.nextInt());</span><br><span class="line">        <span class="type">String</span> <span class="variable">capstr</span> <span class="operator">=</span> hash1.substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> capstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改拦截器，对客户端登录相关的请求进行放行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义不需要处理的请求路径</span></span><br><span class="line">String[] urls = &#123;</span><br><span class="line">        <span class="string">&quot;/employee/login&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/employee/logout&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/backend/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/front/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/common/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/user/sendMsg&quot;</span>,  <span class="comment">// 移动端发送短信</span></span><br><span class="line">        <span class="string">&quot;/user/login&quot;</span>  <span class="comment">// 移动端登录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表现层方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpSession session)</span>&#123;</span><br><span class="line">      <span class="comment">// 获取手机号</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> user.getPhone();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(phone))&#123;</span><br><span class="line">          <span class="comment">// 生成随机的4位验证码</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> ValidateCodeUtils.generateValidateCode(<span class="number">4</span>).toString();</span><br><span class="line">          log.info(<span class="string">&quot;code -&gt; &#123;&#125;&quot;</span>, code);</span><br><span class="line">          <span class="comment">// 调用阿里云提供的短信服务API完成短信发送</span></span><br><span class="line">          SMSUtils.sendMessage(<span class="string">&quot;瑞吉外卖&quot;</span>, <span class="string">&quot;您的验证码为：$&#123;code&#125;，请勿泄露于他人！&quot;</span>, phone, code);</span><br><span class="line">          <span class="comment">// 需要将生成的验证码保存到Session中</span></span><br><span class="line">          session.setAttribute(phone, code);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> Result.success(<span class="string">&quot;手机短信验证码发送成功&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Result.error(<span class="string">&quot;手机短信验证码发送失败&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录请求</li>
</ul>
<p><img src="image-20230706171041816.png" alt="image-20230706171041816"></p>
<p>请求参数是json格式的code和phone，phone是User实体类的属性，但是验证码code不是。有两种解决方案：① 定义增强类UserDto； ② 用Map的key-value接收参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;User&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Map userMap, HttpSession session)</span>&#123;</span><br><span class="line">    log.info(userMap.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> userMap.get(<span class="string">&quot;phone&quot;</span>).toString();</span><br><span class="line">    <span class="comment">// 获取验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> userMap.get(<span class="string">&quot;code&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从session中获取保存的验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">codeInSession</span> <span class="operator">=</span> session.getAttribute(phone).toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行验证码的比对（页面提交的验证码和Session中保存的验证码做比对）</span></span><br><span class="line">    <span class="keyword">if</span>(codeInSession != <span class="literal">null</span> &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">        <span class="comment">// 如果能够比对成功，说明登录成功</span></span><br><span class="line">        <span class="comment">// 判断当前手机号对应的用户是否为新用户</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(User::getPhone, phone);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getOne(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果是新用户则自动注册</span></span><br><span class="line">            user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setPhone(phone);</span><br><span class="line">            userService.save(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, user.getId());</span><br><span class="line">        <span class="keyword">return</span> Result.success(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="地址簿管理"><a href="#地址簿管理" class="headerlink" title="地址簿管理"></a>地址簿管理</h3><p><strong>address_book数据模型</strong></p>
<p><img src="image-20230706171952511.png" alt="image-20230706171952511"></p>
<p><strong>表现层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址簿管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/addressBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressBookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AddressBook&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        addressBookService.save(addressBook);</span><br><span class="line">        <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AddressBook&gt; <span class="title function_">setDefault</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        wrapper.set(AddressBook::getIsDefault, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 0 where user_id = ?</span></span><br><span class="line">        addressBookService.update(wrapper);</span><br><span class="line"></span><br><span class="line">        addressBook.setIsDefault(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 1 where id = ?</span></span><br><span class="line">        addressBookService.updateById(addressBook);</span><br><span class="line">        <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (addressBook != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AddressBook&gt; <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.eq(AddressBook::getIsDefault, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? and is_default = 1</span></span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == addressBook) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定用户的全部地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">		<span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;AddressBook&gt;&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddressBook</span>();</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件构造器</span></span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="literal">null</span> != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());</span><br><span class="line">        queryWrapper.orderByDesc(AddressBook::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? order by update_time desc</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(addressBookService.list(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心业务思路</strong></p>
<ul>
<li><p>设置默认地址</p>
<p>一个用户的默认收货地址只能有一个，如何保证在设置默认地址时，每个用户的默认地址只有一个呢？那就是每次操作address_book数据表时，先将该用户的所有<code>is_default</code>字段都设置为0，再将选中的设置为1。</p>
</li>
<li><p>查询指定用户的全部地址</p>
<p><img src="image-20230706173632478.png" alt="image-20230706173632478"></p>
</li>
</ul>
<p>​    这里不需要请求参数，只需要用户userId，这个可以从Session中获取。</p>
<h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p><strong>需求分析</strong></p>
<ul>
<li>移动端用户可以将菜品/套餐添加到购物车</li>
<li>对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车（前端实现）</li>
<li>对于套餐来说，可以直接点击当前套餐加入购物车</li>
<li>在购物车中可以修改菜品/套餐的数量，也可以清空购物车</li>
</ul>
<p><strong>表现层代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shoppingCart&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向购物车中新增菜品或套餐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shoppingCart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;ShoppingCart&gt; <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前用户的id，指定是哪个用户的购物车数据</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> shoppingCart.getDishId();</span><br><span class="line">        <span class="comment">// 菜品和套餐的区别是发送的请求参数一个是dishId一个是setmealId</span></span><br><span class="line">        <span class="comment">// SQL: select * from shopping_cart where user_id = ? and [dish_id = ? 或者 setmeal_id = ?]</span></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">        <span class="keyword">if</span>(dishId == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 加入购物车的是套餐setmealId</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 加入购物车的是单菜品</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getDishId, shoppingCart.getDishId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  shopping_cart中的一行数据</span></span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">shoppingCartOne</span> <span class="operator">=</span> shoppingCartService.getOne(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还要检查加入购物车菜品或者套餐的数量 -- 如果是第一次添加则setNumber=1，并执行save操作；如果不是第一次添加则updateNumber++</span></span><br><span class="line">        <span class="keyword">if</span>(shoppingCartOne == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 第一次添加</span></span><br><span class="line">            shoppingCart.setNumber(<span class="number">1</span>);</span><br><span class="line">            shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">            shoppingCartService.save(shoppingCart);</span><br><span class="line">            shoppingCartOne = shoppingCart;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不是第一次添加</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> shoppingCartOne.getNumber();</span><br><span class="line">            shoppingCartOne.setNumber(++number);</span><br><span class="line">            shoppingCartService.updateById(shoppingCartOne);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(shoppingCartOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向购物车中减少菜品或套餐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shoppingCart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sub&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;ShoppingCart&gt; <span class="title function_">sub</span><span class="params">(<span class="meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际请求参数只有dishId或者setmealId</span></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, userId);</span><br><span class="line">        <span class="keyword">if</span>(shoppingCart.getDishId() != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 菜品</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getDishId, shoppingCart.getDishId());</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 套餐</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">one</span> <span class="operator">=</span> shoppingCartService.getOne(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(one.getNumber() == <span class="number">1</span>)&#123;</span><br><span class="line">            shoppingCartService.remove(lambdaQueryWrapper);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(one.getNumber() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            one.setNumber(one.getNumber() - <span class="number">1</span>);</span><br><span class="line">            shoppingCartService.updateById(one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据登录用户的id查询购物车的列表清单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;ShoppingCart&gt;&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">        lambdaQueryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;ShoppingCart&gt; list = shoppingCartService.list(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/clean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">cleanShoppingCart</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">        shoppingCartService.remove(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;清空购物车成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h3><p><strong>流程分析</strong></p>
<ol>
<li>在订单确认页面中，发送ajax请求，请求服务端，获取当前登录用户的默认地址</li>
<li>在订单确认页面，发送ajax请求，请求服务端，获取当前登录用户的购物车数据</li>
<li>在订单确认页面点击去支付按钮，发送ajax请求，请求服务端，完成下单操作</li>
</ol>
<p><strong>数据模型</strong></p>
<p>orders数据表：</p>
<img src="image-20230706184553636.png" alt="image-20230706184553636" style="zoom:87%;" />

<p>order_detail数据表：</p>
<img src="image-20230706184642018.png" alt="image-20230706184642018" style="zoom:87%;" />

<p><strong>“下单”核心业务思路</strong></p>
<p>步骤1：查询当前用户的购物车，判断购物车是否为空，如果为空抛出业务异常无法下单；</p>
<p>步骤2：向订单表orders插入(1条)数据；</p>
<p>步骤3：向订单明细表order_detail插入(多条)数据；</p>
<p>步骤4：清空购物车数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户下单提交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Orders orders)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得当前用户的id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询当前用户id的购物车数据</span></span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; cartLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    cartLambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">    List&lt;ShoppingCart&gt; cartList = shoppingCartService.list(cartLambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cartList == <span class="literal">null</span> || cartList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;购物车为空，无法下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(currentId);</span><br><span class="line">    <span class="comment">// 查询地址数据</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">addressBookId</span> <span class="operator">=</span> orders.getAddressBookId();</span><br><span class="line">    <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(addressBookId);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> IdWorker.getId();<span class="comment">//订单号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历购物车数据得到订单明细列表数据</span></span><br><span class="line">    List&lt;OrderDetail&gt; orderDetails = cartList.stream().map((item) -&gt; &#123;</span><br><span class="line">        <span class="type">OrderDetail</span> <span class="variable">orderDetail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDetail</span>();</span><br><span class="line">        orderDetail.setOrderId(orderId);</span><br><span class="line">        orderDetail.setNumber(item.getNumber());</span><br><span class="line">        orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">        orderDetail.setDishId(item.getDishId());</span><br><span class="line">        orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">        orderDetail.setName(item.getName());</span><br><span class="line">        orderDetail.setImage(item.getImage());</span><br><span class="line">        orderDetail.setAmount(item.getAmount());</span><br><span class="line">        amount.addAndGet(item.getAmount().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getNumber())).intValue());</span><br><span class="line">        <span class="keyword">return</span> orderDetail;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单表数据设置</span></span><br><span class="line">    orders.setId(orderId);</span><br><span class="line">    orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">    orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">    orders.setStatus(<span class="number">2</span>);</span><br><span class="line">    orders.setAmount(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(amount.get()));<span class="comment">//总金额</span></span><br><span class="line">    orders.setUserId(currentId);</span><br><span class="line">    orders.setNumber(String.valueOf(orderId));</span><br><span class="line">    orders.setUserName(user.getName());</span><br><span class="line">    orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">    orders.setPhone(addressBook.getPhone());</span><br><span class="line">    orders.setAddress((addressBook.getProvinceName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getProvinceName())</span><br><span class="line">            + (addressBook.getCityName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getCityName())</span><br><span class="line">            + (addressBook.getDistrictName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDistrictName())</span><br><span class="line">            + (addressBook.getDetail() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDetail()));</span><br><span class="line">    <span class="comment">// 向订单表orders插入(1条)数据</span></span><br><span class="line">    <span class="built_in">this</span>.save(orders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向订单明细表order_detail插入(多条)数据</span></span><br><span class="line">    orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空购物车数据</span></span><br><span class="line">    shoppingCartService.remove(cartLambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title>网页调试工具PostMan</title>
    <url>/2023/06/04/%E7%BD%91%E9%A1%B5%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7PostMan/</url>
    <content><![CDATA[<p>PostMan是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，常用于进行接口测试。</p>
<span id="more"></span>

<h2 id="PostMan简介"><a href="#PostMan简介" class="headerlink" title="PostMan简介"></a>PostMan简介</h2><p>代码编写完后，我们要想测试，只需要打开浏览器直接输入地址发送请求即可。发送的是GET请求可以直接使用浏览器，但是如果要发送的是POST请求呢？如果要求发送的是post请求，我们就得准备页面在页面上准备form表单，测试起来比较麻烦。所以我们就需要借助一些第三方工具，如PostMan。</p>
<h2 id="PostMan安装"><a href="#PostMan安装" class="headerlink" title="PostMan安装"></a>PostMan安装</h2><p><a href="https://www.postman.com/downloads/">官网链接下载</a></p>
<p>注册一个账号直接来到这个界面：</p>
<img src="image-20230606092337492.png" alt="image-20230606092337492" style="zoom:67%;" />

<h2 id="PostMan使用"><a href="#PostMan使用" class="headerlink" title="PostMan使用"></a>PostMan使用</h2><h3 id="创建WorkSpace工作空间"><a href="#创建WorkSpace工作空间" class="headerlink" title="创建WorkSpace工作空间"></a>创建WorkSpace工作空间</h3><img src="image-20230606092805094.png" alt="image-20230606092805094" style="zoom:67%;" />

<img src="image-20230606092858754.png" alt="image-20230606092858754" style="zoom:67%;" />

<img src="image-20230606092948897.png" alt="image-20230606092948897" style="zoom:67%;" />

<img src="image-20230606093406445.png" alt="image-20230606093406445" style="zoom:67%;" />

<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><img src="image-20230606093645158.png" alt="image-20230606093645158" style="zoom:67%;" />

<p>也可以请求访问我们在Tomcat返回的页面：</p>
<p><img src="image-20230606094044962.png" alt="image-20230606094044962"></p>
<img src="image-20230606094234798.png" alt="image-20230606094234798" style="zoom:77%;" />

<h3 id="保存当前请求"><a href="#保存当前请求" class="headerlink" title="保存当前请求"></a>保存当前请求</h3><img src="image-20230606094500001.png" alt="image-20230606094500001" style="zoom:67%;" />
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>瑞吉外卖项目实战day1</title>
    <url>/2023/07/04/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day1/</url>
    <content><![CDATA[<p>适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。</p>
<span id="more"></span>

<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="配置静态资源映射"><a href="#配置静态资源映射" class="headerlink" title="配置静态资源映射"></a>配置静态资源映射</h3><p>为了访问静态资源，要进行静态资源映射的配置。</p>
<p>Springboot将静态资源都放在<code>resource/static</code>目录下，会进行自动配置静态资源映射。</p>
<p><img src="image-20230704123442685.png" alt="image-20230704123442685"></p>
<p>如果静态资源没放在<code>resource/static</code>目录，要书写配置类实现<code>WebMvcConfigurer</code>接口，重写<code>addResourceHandlers</code>方法，进行手动配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始进行静态资源映射...&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/backend/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/front/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不推荐继承WebMvcConfigurationSupport类，而是使用实现WebMvcConfigurer接口，因为继承类会覆盖Springboot提供的自动静态资源映射配置，而实现接口是在原有的配置上附加映射配置。</p>
</blockquote>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Application.yml配置文件，核心是服务器端口号+数据库四要素。</p>
<p>此外还有mybatis-plus的一些配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">reggie_take_out</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span></span><br></pre></td></tr></table></figure>

<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>导入lombok依赖，通过<code>@Data</code>注释在实体类中只需要定义属性名，会自动生成默认的无参构造方法和setter/getter方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>@AllArgsConstructor</code>：提供全部参数的构造方法，会覆盖<code>@Data</code>提供的无参构造方法。</p>
<p><code>@NoArgsConstructor</code>：提供默认的无参构造方法。</p>
<h3 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h3><p>使用Result类将服务器的响应进行统一格式的结果封装。</p>
<p>属性：状态位code（0/1）、错误信息msg（String）、数据data（泛型T）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;();</span><br><span class="line">        result.data = object;</span><br><span class="line">        result.code = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.msg = msg;</span><br><span class="line">        result.code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Result&lt;T&gt; <span class="title function_">add</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h2><p>编写Controller表现层业务方法时，首先需要通过前端代码以及浏览器开发者工具明确几个要素：</p>
<ul>
<li><p>请求类型</p>
</li>
<li><p>请求路径</p>
</li>
<li><p>请求参数：尽量封装成实体类对象，通过getter得到请求参数。</p>
<ul>
<li><code>@PathVariable</code>：RESTful风格的参数</li>
<li><code>@RequestBody</code>：json格式数据</li>
<li><code>@RequestParam</code></li>
</ul>
</li>
<li><p>返回值类型：看前端代码需要服务器响应什么类型的数据。</p>
</li>
</ul>
<h3 id="后台登录功能"><a href="#后台登录功能" class="headerlink" title="后台登录功能"></a>后台登录功能</h3><p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loginApi</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;/employee/login&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：POST</p>
<p>请求路径：<code>/employee/login</code></p>
<p>请求参数：包含username和password的json格式数据，可以封装成Employee实体类对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;userInfo&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res.<span class="property">data</span>))</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>= <span class="string">&#x27;../../index.html&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值类型：由于前端需要服务端的响应包含<code>data</code>属性，所以返回值应该是<code>Result&lt;Employee&gt;</code>类型</p>
<p><strong>核心业务思路</strong></p>
<p>步骤1：先判断请求参数username/password是否为空，任一为空就不用再查表了；</p>
<p>步骤2：根据请求参数的username查表 – <code>LambdaQueryWrapper</code>封装查询条件；</p>
<p>步骤3：没查到数据（username）则返回失败；</p>
<p>步骤4：查询到了数据则进行密码比对，密码不一致返回失败 – 登录功能的密码考虑到安全性可以进行md5加密后再存入数据库：<code>DigestUtils</code>工具类的<code>md5DigestAsHex(String.getBytes())</code>方法；</p>
<p>步骤5：登陆成功，将员工id存入Session备用。</p>
<blockquote>
<p>复习Session：一种服务端的会话跟踪技术，在一次会话的多次请求中共享数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Session</span></span><br><span class="line">HttpServletRequset.getSession().setAttribute(String key, Object o);</span><br><span class="line"><span class="comment">// 获取Session内容</span></span><br><span class="line">HttpServletRequset.getSession().getAttribute(String key);</span><br><span class="line"><span class="comment">// 删除Session内容</span></span><br><span class="line">HttpServletRequset.getSession().removeAttribute(String key);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>登录业务完善</strong></p>
<p>只有登录成功了才得以访问其他页面，未登录则跳转到登录页面——在过滤器或拦截器中判断用户是否登录。</p>
<ul>
<li><p>实现Filter过滤器</p>
<ul>
<li><p>在LoginCheckFilter类中实现<code>Filter</code>接口，加类注释<code>@WebFilter</code>，重写<code>doFilter</code>方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Servlet的过滤器对登录功能进行数据增强：访问界面如果未登录则自动跳转到登录界面</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">			filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Springboot启动类上加<code>@ServletComponentScan</code>注释；</p>
</li>
</ul>
</li>
<li><p>过滤器登录检查逻辑</p>
<ul>
<li><p>获取本次请求的URI</p>
</li>
<li><p>定义不需要拦截的请求（静态资源+登录登出有关的资源路径），并判断本次请求是否需要被处理</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 包含通配符的路径匹配 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">PATH_MATCHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"><span class="comment">// -----------具体实现-----------</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkFilter</span><span class="params">(String[] urls, String requestURI)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PATH_MATCHER.match(url, requestURI)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>如果不需要处理则直接放行</p>
</li>
<li><p>判断登录状态（通过Session），如果已登录则放行，如果未登录则通过输出流方式返回结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.getWriter().write(JSON.toJSONString(Result.error(<span class="string">&quot;NOTLOGIN&quot;</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用JSON.toJSONString要导入fastjson坐标。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="添加员工功能"><a href="#添加员工功能" class="headerlink" title="添加员工功能"></a>添加员工功能</h3><p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member.js  新增---添加员工</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addEmployee</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：POST</p>
<p>请求路径：<code>/employee</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addEmployee</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;员工添加成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;phone&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="comment">// &#x27;password&#x27;: &#x27;&#x27;,</span></span><br><span class="line">        <span class="comment">// &#x27;rePassword&#x27;: &#x27;&#x27;,/</span></span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;idNumber&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求参数：包含username、name、phone、sex、idNumber的json格式数据，可以封装成Employee实体类对象</p>
<p>返回值类型：由于前端需要服务端的响应只有<code>code</code>和<code>msg</code>属性，所以返回值写成<code>Result&lt;String&gt;</code>类型。</p>
<p><strong>核心业务思路</strong></p>
<p>Controller表现层直接调用Service层的<code>save</code>添加实体轮类Employee对象，在Mapper层对象解析成Employee数据表中的字段进行数据添加。</p>
<p><strong>添加员工业务完善</strong></p>
<p>操作数据库时insert操作要注意：① 数据表中not null的字段必须有值； ② 数据表中主键、not unique字段都不能重复，要进行判断。</p>
<ul>
<li>Employee数据表结构：</li>
</ul>
<img src="image-20230704144542860.png" alt="image-20230704144542860" style="zoom:87%;" />

<p>前端的表单中提交过来的参数填充的字段有：username、name、phone、sex、id_number，主键id雪花算法自动生成、status具有默认值1，所以后面4个not null字段的值需要我们手动来添加：</p>
<p>而创建人、创建时间、修改人、修改时间字段属于公共字段，不仅员工表有这些字段，在菜品表、分类表等其他表中，也拥有这些字段。那我们有没有办法让这些字段在一个地方统一管理呢？</p>
<p>解决方案：使用MybatisPlus给我们提供的公共字段自动填充功能。</p>
<ul>
<li>在Employee数据表中，username字段not unique不能重复：</li>
</ul>
<img src="image-20230704144402844.png" alt="image-20230704144402844" style="zoom:87%;" />

<p>步骤1：获取请求参数中的username，调用Service方法检查用户名是否重复；</p>
<p>步骤2：用户名重复则无法添加，<strong>抛出异常</strong>（进行统一异常处理）并响应给前端提示信息；用户名未重复则操作数据库进行添加操作。</p>
<p><strong>公共字段自动填充</strong></p>
<p>步骤1：按照框架要求编写元数据对象处理器MyMetaObjectHandler类，在此类中统一对公共字段赋值，此类需要实现<code>MetaObjectHandler</code>接口，实现接口之后，重写两个方法，一个是插入时填充，一个是修改时填充（字段填充方式，使用metaObject的<code>setValue</code>方法来实现）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作自动填充</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">      <span class="comment">// 在元数据对象处理器中通过LocalThread获取用户id</span></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作自动填充</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        log.info(<span class="string">&quot;线程id: &#123;&#125;&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">       <span class="comment">// 在元数据对象处理器中通过LocalThread获取用户id</span></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：在实体类的属性上方加入<code>@TableFiled</code>注解，指定自动填充的策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span>  <span class="comment">// 插入时填充字段</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>  <span class="comment">// 插入和更新时填充字段</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span>  <span class="comment">// 插入时填充字段</span></span><br><span class="line"><span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>  <span class="comment">// 插入和更新时填充字段</span></span><br><span class="line"><span class="keyword">private</span> Long updateUser;</span><br></pre></td></tr></table></figure>

<p><strong>通过LocalThread获取用户id</strong></p>
<p>关于id的获取，我们之前是存到session里的，但在<code>MyMetaObjectHandler</code>类中不能获得HttpSession对象，所以我们需要用其他方式来获取登录用户id。</p>
<p>我们可以使用<code>ThreadLocal</code>来解决这个问题：在学习ThreadLocal之前，我们需要先确认一个事情，<font color="blue">就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程：</p>
<ol>
<li><code>LoginCheckFilter</code>中的<code>doFilter</code>方法</li>
<li><code>EmployeeController</code>中的响应方法</li>
<li><code>MyMetaObjectHandler</code>中的<code>insertFill</code>或者<code>updateFill</code>方法</li>
</ol>
<blockquote>
<p>ThreadLocal并不是一个Thread，而是Thread的局部变量；当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本；所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本；ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p>
</blockquote>
<p>具体实现——</p>
<p>我们可以在LoginCheckFilter过滤器的的<code>doFilter</code>方法中获取当前登录用户id，并调用<code>ThreadLocal</code>的<code>set</code>方法来设置当前线程的线程局部变量的值（用户id)，然后在MyMetaObjectHandler的<code>insertFill</code>或<code>updateFill</code>方法中调用<code>ThreadLocal</code>的<code>get</code>方法来获得当前线程所对应的线程局部变量的值（用户id)。</p>
<ul>
<li>步骤1：common包下新建BaseContext类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户的id</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：在LoginCheckFilter类（每次请求都会首先经过过滤器类）中获取当前Session的值(用户id)，使用BaseContext封装的<code>setCurrentId</code>方法封装id值</li>
<li>步骤3：在MyMetaObjectHandler类中获取当前请求所在线程的id值。</li>
</ul>
<p><strong>统一异常处理</strong></p>
<ul>
<li>统一异常处理框架<ul>
<li>在common包下添加一个ProjectExceptionAdvice统一异常处理类，加类注释<code>@RestControllerAdvice</code>；</li>
<li>方法参数是异常类型的对象ex，方法上加类注释<code>@ExceptionHandler(异常类型.class)</code>，返回值一般是<code>Result&lt;String&gt;</code>；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">doSqlException</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        log.info(ex.getMessage());  <span class="comment">// Duplicate entry &#x27;lisi&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class="line">		</span><br><span class="line">     		 <span class="comment">/* --- 异常逻辑判断（可选） ---  */</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常逻辑判断（有些时候需要，有时不用）– <code>ex.getMessage()</code>方法很重要</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ex.getMessage().contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;	<span class="comment">// Duplicate entry &#x27;lisi&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class="line">    String[] split = ex.getMessage().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> split[<span class="number">2</span>] + <span class="string">&quot;已存在&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="员工信息分页查询"><a href="#员工信息分页查询" class="headerlink" title="员工信息分页查询"></a>员工信息分页查询</h3><p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member.js </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMemberList</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee/page&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：GET</p>
<p>请求路径：<code>/employee/page</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> init () &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">      <span class="attr">page</span>: <span class="variable language_">this</span>.<span class="property">page</span>,</span><br><span class="line">      <span class="attr">pageSize</span>: <span class="variable language_">this</span>.<span class="property">pageSize</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">input</span> ? <span class="variable language_">this</span>.<span class="property">input</span> : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getMemberList</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">records</span> || []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counts</span> = res.<span class="property">data</span>.<span class="property">total</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求出错了：&#x27;</span> + err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><img src="image-20230704170513895.png" alt="image-20230704170513895"></p>
<p>请求参数：包含page、pageSzie和可选参数name，因为是get请求，所以请求参数是在请求头中的普通参数</p>
<p>返回值类型：由于前端需要服务端的响应除了<code>code</code>属性还有<code>res.data.records</code>和<code>res.data.total</code>属性，很明显方法返回值是<code>Result&lt;Page&gt;</code>类型。</p>
<p><strong>Mybatis-Plus中分页插件配置</strong></p>
<p>要在Springboot项目中使用分页查询，必须要配置Mybatis-Plus的分页插件：</p>
<p>在config包下新建MybatisPlusConfig配置类，在方法中首先创建一个MybatisPlus拦截器，在拦截器中再添加分页查询的拦截器，不要忘了将方法注释为<code>@Bean</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置MybatisPlus的分页插件</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心业务思路</strong></p>
<p>分页查询的请求参数是page、pageSize，响应参数也是page，它的业务逻辑比较固定，直接展示实现基本分页功能的表现层代码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Page&gt; <span class="title function_">pageSelect</span><span class="params">(Integer page, Integer pageSize, String name)</span>&#123;</span><br><span class="line">        <span class="comment">// 构造分页构造器</span></span><br><span class="line">        Page&lt;Employee&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page, pageSize);</span><br><span class="line">        <span class="comment">// 构造条件构造器</span></span><br><span class="line">        LambdaQueryWrapper&lt;Employee&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加过滤条件</span></span><br><span class="line">        lambdaQueryWrapper.like(StringUtils.hasText(name), Employee::getName, name);  <span class="comment">// 或者 name != null</span></span><br><span class="line">        <span class="comment">// 添加排序条件</span></span><br><span class="line">        lambdaQueryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        employeeService.page(pageInfo, lambdaQueryWrapper);  <span class="comment">// IService的page函数会将查询数据自动封装到pageInfo当中</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(pageInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="禁用-启用员工账号"><a href="#禁用-启用员工账号" class="headerlink" title="禁用/启用员工账号"></a>禁用/启用员工账号</h3><p>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作：账号禁用的员工不能登录系统，启用后的员工可以正常登录。【前端业务】需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。</p>
<p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member.js --启用禁用接口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enableOrDisableEmployee</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：PUT</p>
<p>请求路径：<code>/employee</code></p>
<p><img src="image-20230704173524643.png" alt="image-20230704173524643"></p>
<p>请求参数：包含id和status的json格式数据，可以封装成Employee实体类对象（这里注意一下，status为0则表示客户端的禁用请求，status为1则表示客户端的启用请求）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">enableOrDisableEmployee</span>(&#123; <span class="string">&#x27;id&#x27;</span>: <span class="variable language_">this</span>.<span class="property">id</span>, <span class="string">&#x27;status&#x27;</span>: !<span class="variable language_">this</span>.<span class="property">status</span> ? <span class="number">1</span> : <span class="number">0</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enableOrDisableEmployee&#x27;</span>,res)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;账号状态更改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值类型：由于前端需要服务端的响应只有<code>code</code>属性，所以返回值写成<code>Result&lt;String&gt;</code>类型。</p>
<p><strong>核心业务思路</strong></p>
<p>将请求参数传入Service的updateById方法，就可以更改相应employee数据的status字段值。</p>
<p><font color="blue">但是通过日志我们发现，数据并没有修改成功，原因是服务端接收到的Long类型的请求参数<code>employee.id</code> 通过前端js已经丢失了精度，导致id不准确，无法从数据库中找到相应id的数据！</font></p>
<p>解决方案是：我们可以在服务端给页面响应json数据时进行处理，将Long型数据统一转为String字符串。</p>
<p><strong>拓展mvc的消息转换器</strong></p>
<p>可以自定义服务器Result对象序列化成json数据的细节，比如数据类型Long→String，比如自定义时间格式等。</p>
<p>步骤1：common包下配置对象映射器<font color="red">（工具类可以直接复制代码）</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line"></span><br><span class="line">                .addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：扩展Mvc框架的消息转换器</p>
<p>config包下的WebMvcConfig配置类，实现<code>WebMvcConfigurer</code>接口，重写<code>extendMessageConverters</code>方法（方法在项目启动时就被调用）。springboot自己的消息转换器可以把返回的Result对象序列化成json数据响应给前端，而我们可以根据自己的需要扩展消息转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展mvc框架的消息转换器: springboot自己的消息转换器可以把返回的Result对象序列化成json数据响应给前端，而我们可以根据自己的需要扩展消息转换器</span></span><br><span class="line"><span class="comment">     * (方法在项目启动时调用)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消息转换器对象</span></span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        <span class="comment">// 设置对象转换器，底层使用jackson将Java对象转换成json数据</span></span><br><span class="line">        messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">        <span class="comment">// 将上面的消息转换器对象追加到mvc框架的转换器集合中</span></span><br><span class="line">        converters.add(<span class="number">0</span>, messageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑员工信息"><a href="#编辑员工信息" class="headerlink" title="编辑员工信息"></a>编辑员工信息</h3><p><strong>流程分析</strong></p>
<p>后续我们会开发一些比较复杂的业务功能，一个业务功能处理多个请求发送多个响应数据，所以流程分析是很重要的。</p>
<ol>
<li>在list.html页面中，点击编辑按钮，页面跳转到add.html中，并在url中携带employee的id；</li>
<li>发送ajax请求（回显数据的请求），将id提交给服务器；</li>
<li>服务器接收请求，根据id查询employee信息，并将员工信息响应给页面；</li>
<li>页面接收服务端的json数据，并通过Vue的双向绑定进行员工信息回显；</li>
<li>点击保存按钮，发送ajax请求（修改数据的请求），将id和表单数据一起提交至服务端；</li>
<li>服务端接收员工信息，根据id修改员工的信息，完成后给页面响应。</li>
</ol>
<p><strong>表现层要素</strong></p>
<ul>
<li>回显数据的请求</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member.js -- 修改页面反查详情接口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryEmployeeById</span> (id) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">`/employee/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230704201830485.png" alt="image-20230704201830485"></p>
<p>请求类型：GET</p>
<p>请求路径：<code>/employee/&#123;id&#125;</code></p>
<p>请求参数：只有员工id，且是RESTful风格，需要加<code>@PathVariable</code>注解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">queryEmployeeById</span>(<span class="variable language_">this</span>.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span> = res.<span class="property">data</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">sex</span> = res.<span class="property">data</span>.<span class="property">sex</span> === <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;女&#x27;</span> : <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="comment">// this.ruleForm.password = &#x27;&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：前端需要服务端的响应<code>data</code>属性，所以方法返回值是Result<Employee>类型。</p>
<ul>
<li>修改数据的请求</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改---添加员工</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">editEmployee</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：PUT</p>
<p>请求路径：<code>/employee</code></p>
<p><img src="image-20230704210234755.png" alt="image-20230704210234755"></p>
<p>请求参数：json格式的员工信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">editEmployee</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;员工信息修改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：前端只要服务端的响应<code>code</code>和<code>msg</code>属性，所以方法返回值是<code>Result&lt;String&gt;</code>类型即可。</p>
<p><strong>核心业务思路</strong></p>
<p>通过员工id查询Employee数据表进行数据回显；前端点击修改按钮后，服务端接收修改后的Employee对象请求参数，调用Service层的updateById传回employee对象即可修改数据表内容。</p>
<h3 id="新增菜品分类"><a href="#新增菜品分类" class="headerlink" title="新增菜品分类"></a>新增菜品分类</h3><p><strong>数据模型</strong></p>
<p><img src="image-20230705093303752.png" alt="image-20230705093303752"></p>
<p>菜品分类id字段是主键，name分类名称是unique唯一的，type为1表示菜品分类，type为2表示套餐分类。</p>
<p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// category.js -- 新增接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">addCategory</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：POST</p>
<p>请求路径：<code>/employee</code></p>
<p><img src="image-20230705094033530.png" alt="image-20230705094033530"></p>
<p><img src="image-20230705094411620.png" alt="image-20230705094411620"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addCategory</span>(&#123;<span class="string">&#x27;name&#x27;</span>: classData.<span class="property">name</span>,<span class="string">&#x27;type&#x27;</span>:<span class="variable language_">this</span>.<span class="property">type</span>, <span class="attr">sort</span>: classData.<span class="property">sort</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;分类添加成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">dialogVisible</span> = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">sort</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求参数：json格式的请求参数，包含name、type、sort字段，可以封装成Category对象</p>
<p>返回值类型：前端需要服务端的响应只有<code>code</code>和<code>msg</code>属性，所以方法返回值是<code>Result&lt;String&gt;</code>类型</p>
<p><strong>核心业务思路</strong></p>
<p>前面已经做过新增员工的业务逻辑，新增菜品分类的其实都是一样的，<strong>（新增业务的重点）保证每一个not null的字段都有赋值且unique的字段没有重复</strong>，再通过Service层的save方法调用进而mapper操作数据库进行添加数据。</p>
<h3 id="分类信息分页查询"><a href="#分类信息分页查询" class="headerlink" title="分类信息分页查询"></a>分类信息分页查询</h3><p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// category.js -- 查询列表接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">getCategoryPage</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category/page&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">     params</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：GET</p>
<p>请求路径：<code>/category/page</code></p>
<p><img src="image-20230705094851492.png" alt="image-20230705094851492"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">getCategoryPage</span>(&#123;<span class="string">&#x27;page&#x27;</span>: <span class="variable language_">this</span>.<span class="property">page</span>, <span class="string">&#x27;pageSize&#x27;</span>: <span class="variable language_">this</span>.<span class="property">pageSize</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">records</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">counts</span> = <span class="title class_">Number</span>(res.<span class="property">data</span>.<span class="property">total</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求参数：分页查询，请求参数是普通请求头里的page、pageSize。</p>
<p>返回值类型：<code>Result&lt;Page&gt;</code>类型</p>
<p><strong>核心业务思路</strong></p>
<p>对于分页查询来说，我们一定要记得配置MybatisPlus的分页查询插件。除此之外，表现层的业务代码非常简单：分页构造器+条件构造器（排序条件），调用Service层的page函数即可，最终把分页构造器响应给前端用来页面的展示。</p>
<blockquote>
<p>分页插件的配置，再复习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="删除菜品分类"><a href="#删除菜品分类" class="headerlink" title="删除菜品分类"></a>删除菜品分类</h3><p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// category.js -- 删除当前列的接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">deleCategory</span> = (<span class="params">ids</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">     <span class="attr">params</span>: &#123; ids &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230705100107054.png" alt="image-20230705100107054"></p>
<p>请求类型：DELETE</p>
<p>请求路径：<code>/category/&#123;ids&#125;</code></p>
<p>请求参数：RESTful风格的菜品id参数，如果方法参数名和前端请求参数名不一致，需要在注释后面加<code>@PathVariable(&quot;参数名&quot;)</code>参数名进行映射。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">deleCategory</span>(id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;删除成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：<code>Result&lt;String&gt;</code>类型</p>
<p><strong>核心业务思路</strong></p>
<p>因为请求参数是Category数据表的主键值id，所以直接调用Service层的<code>removeById</code>删除数据即可。和新增业务必须考虑的not null和unique字段一样，删除业务也有必须考虑的点：<strong>也就是当前要删除的数据，是否跟其他表中的数据相关联。</strong>对于当前来说，当菜品分类或套餐分类关联了其他菜品或套餐时，该分类将不允许被删除，所以我们需要进一步完善我们的删除业务逻辑。<font color="red">（是否可以直接把关联通过外键约束等体现在数据库中，这需要进一步优化数据库表？复习完mysql再回来研究）</font></p>
<p>MybatisPlus中的Service层提供的删除方法不能满足我们的业务需求，所以我们在Service层手动添加remove方法：我们需要在删除数据之前，根据<code>id</code>值，去<code>Dish</code>表和<code>Setmeal</code>表中（<code>category_id</code>字段）查询是否关联了数据：如果存在关联数据，则不能删除，并抛一个自定义的业务异常。</p>
<blockquote>
<p>复习一下统一异常处理：自定义业务异常</p>
<p>步骤1：在exception包下创建响应的Exception类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的业务异常</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：在统一异常处理类中自定义异常处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理方法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(ServiceException.class)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">doServiceException</span><span class="params">(ServiceException ex)</span>&#123;</span><br><span class="line">    log.info(ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> Result.error(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="修改菜品分类"><a href="#修改菜品分类" class="headerlink" title="修改菜品分类"></a>修改菜品分类</h3><p><strong>表现层要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// category.js -- 修改接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">editCategory</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230705105056053.png" alt="image-20230705105056053"></p>
<p>请求类型：PUT</p>
<p>请求路径：<code>/category</code></p>
<p><img src="image-20230705105128881.png" alt="image-20230705105128881"></p>
<p>请求参数：json格式的菜品id、name、sort参数，封装成Category对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">editCategory</span>(&#123;<span class="string">&#x27;id&#x27;</span>:<span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">id</span>,<span class="string">&#x27;name&#x27;</span>: <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">name</span>, <span class="attr">sort</span>: <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">sort</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;分类修改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">dialogVisible</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：<code>Result&lt;String&gt;</code>类型</p>
<blockquote>
<p>这里的数据回显完全交由前端来处理，我们简单了解下前端是如何完成数据回显的即可。页面首先通过<code>scope.row</code> 传递当前行的数据对象，通过v-model双向绑定完成数据的回显。</p>
</blockquote>
<p><strong>核心业务思路</strong></p>
<p>没什么好讲的，直接调用Service原生的<code>updateById</code>方法把实体类对象传进去。</p>
<h3 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h3><p><strong>文件上传</strong></p>
<p>文件上传，也叫upload，是指将本地图片、视频、音频等文件上传到服务器中，可以供其他用户浏览或下载的过程。</p>
<p>文件上传的前端业务我们不需要掌握，只需要了解文件上传是通过采用post方式提交数据即可。Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个<code>MultipartFile</code>类型的参数即可接收上传的文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line"> 		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">// 请求参数名是Form-Data的name值</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(fileName);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的MultipartFile类型的参数名不是随意定的，要和前端请求参数中Form-Data的<code>name</code>值一致才可以！</p>
<p><img src="image-20230705112408492.png" alt="image-20230705112408492"></p>
</blockquote>
<p><strong>文件下载</strong></p>
<p>文件下载，也称为了download，是指将文件从服务器传输到本地计算机的过程，<strong>本质上就是服务端将文件以流的形式写回浏览器的过程</strong>。通过浏览器进行文件下载，通常有两种表现形式：① 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录；② 直接在浏览器中打开。</p>
<p><strong>文件上传核心业务实现</strong></p>
<p><img src="image-20230705161814263.png" alt="image-20230705161814263"></p>
<p>请求类型：POST</p>
<p>请求路径：<code>/common/upload</code></p>
<p>请求参数：<code>MultipartFile</code>类型的对象<code> file</code></p>
<p>方法返回值：<code>Result&lt;String&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 注入配置文件的属性</span></span><br><span class="line"> <span class="meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;		  <span class="comment">// 请求参数名是Form-Data的name值</span></span><br><span class="line">     log.info(file.toString());</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 本地的是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();   <span class="comment">// xxxxxxx.jpg</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用UUID重新生成文件名，防止文件名重复造成的文件覆盖</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 判断文件目录basePath确实存在，若不存在则先进行创建 */</span></span><br><span class="line">     <span class="comment">// 创建一个目录对象</span></span><br><span class="line">     <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">     <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">         dir.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));  <span class="comment">// 转存文件</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Result.success(fileName);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>因为上传至服务器的是一个临时文件（完成本次请求后会被删除），所以我们需要设定文件转存到指定位置，在yml配置文件中设置保存在服务器中的路径并通过<code>@Value(&quot;$&#123;xxx&#125;&quot;)</code>获得路径：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义下载上传图片的路径配置</span></span><br><span class="line"><span class="attr">reggie:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/Users/NUC/git/SSM/reggie_take_out/src/main/resources/picture/</span></span><br></pre></td></tr></table></figure>

<p><strong>文件下载核心业务实现</strong></p>
<p>前端页面的ElementUI在上传完图片后发送请求，服务端以流的方式（输出流）将文件写回给浏览器，在浏览器中展示图片：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleAvatarSuccess (response, file, fileList) &#123;</span><br><span class="line">  <span class="comment">// 拼接down接口预览</span></span><br><span class="line">  <span class="keyword">if</span>(response.<span class="property">code</span> === <span class="number">0</span> &amp;&amp; response.<span class="property">msg</span> === <span class="string">&#x27;未登录&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">top</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;../login/login.html&#x27;</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">`/common/download?name=<span class="subst">$&#123;response.data&#125;</span>`</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">image</span> = response.<span class="property">data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><img src="image-20230705162548370.png" alt="image-20230705162548370"></p>
<p>请求类型：GET</p>
<p>请求路径：<code>/common/download</code></p>
<p>请求参数：String类型的文件名name</p>
<p>方法返回值：无</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件下载</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(HttpServletResponse response, <span class="meta">@RequestParam(&quot;name&quot;)</span> String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 输入流，通过输入流读取文件内容</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));</span><br><span class="line">    <span class="comment">// 输出流，通过输出流将文件写回浏览器，在浏览器展示图片</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应数据的类型</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        outputStream.write(bytes,<span class="number">0</span> ,len);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件下载中有一个容易被忽视的点：浏览器需要知道文件的类型，所以必须设置相应数据的类型<code>response.setContentType</code>，否则会导致下载失败。</p>
</blockquote>
<h3 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h3><p><strong>流程分析</strong></p>
<ol>
<li>add.html页面发送ajax请求，请求服务器获取菜品分类并展示到下拉框中</li>
<li>选择图片进行上传，请求服务器将图片保存在服务器当中</li>
<li>上传成功后前端会自动发送下载请求，回显上传的图片</li>
<li>点击保存按钮，发送ajax请求，将菜品相关json数据提供到服务器端进行处理</li>
</ol>
<p><strong>表现层要素</strong></p>
<p>上传下载请求上一节讲的很明白了这里就不说了，主要讲一下第一个请求（是容易被忽略掉的）和第四个请求。</p>
<ul>
<li>获取菜品分类并展示到下拉框</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取菜品分类列表</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCategoryList</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/category/list&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求类型：GET</p>
<p>请求路径：<code>/category/list</code></p>
<p><img src="image-20230705171036768.png" alt="image-20230705171036768"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取菜品分类</span></span><br><span class="line">getDishList () &#123;</span><br><span class="line">  <span class="title function_">getCategoryList</span>(&#123; <span class="string">&#x27;type&#x27;</span>: <span class="number">1</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dishList</span> = res.<span class="property">data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>请求参数：菜品分类Category对象中的分类类型type，可以封装成Category对象</p>
<p>方法返回值：前端得到服务器响应的结果有<code>data</code>属性，返回值应该是<code>Result&lt;List&gt;</code>类型，将查询到的列表响应给前端</p>
<ul>
<li>将新增菜品json数据提交</li>
</ul>
<p><img src="image-20230705163823971.png" alt="image-20230705163823971"></p>
<p>请求类型：POST</p>
<p>请求路径：<code>/dish</code></p>
<p><img src="image-20230705163902869.png" alt="image-20230705163902869"></p>
<p>请求参数：json格式的dish菜品信息，外加flavors是一个json数组。而flavors不是Dish类中的属性，Dish对象不足以接收本次请求的参数，所以需要导入Dish的增强类DishDto，用于封装页面提交的数据。</p>
<blockquote>
<p>DTO，全称为<code>Data Transfer Object</code>，即数据传输对象，一般用于展示层与服务层之间的数据传输。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishDto</span> <span class="keyword">extends</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;DishFlavor&gt; flavors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer copies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">actionType</span> == <span class="string">&#x27;add&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">delete</span> params.<span class="property">id</span></span><br><span class="line">  <span class="title function_">addDish</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;菜品添加成功！&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dishFlavors</span> = []</span><br><span class="line">        <span class="comment">// this.dishFlavorsData = []</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123;</span><br><span class="line">          <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;price&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;image&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;description&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;dishFlavors&#x27;</span>: [],</span><br><span class="line">          <span class="string">&#x27;status&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">categoryId</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>返回值类型：<code>Result&lt;String&gt;</code>类型</p>
<p><strong>核心业务思路</strong></p>
<ul>
<li>获取菜品分类并展示到下拉框</li>
</ul>
<p>​        将请求参数type作为查询条件，调用Service层的<code>list</code>将菜品分类列表响应给前端即可。</p>
<ul>
<li>将新增菜品json数据提交</li>
</ul>
<p>​        由于请求参数是json格式的嵌套，且flavors口味数据并不在Dish数据表中，所以要完成新增菜品的业务我们需要：① 在dish数据表中添加菜品基本信息； ② 在dish_flavor数据表中添加口味信息。    </p>
<p>​        步骤1：因为要在两张数据表中添加数据，所以不能用MyabtisPlus提供好的Service层方法，我们在Service中自定义新增方法；</p>
<p>​        <font color="red">因为这里要在多张表中添加或修改数据，所以要加入事务管理：① 在Service层方法或类上加注释<code>@Transactional</code>； ② 在启动类上加注释<code>@EnableTransactionManagement</code>.</font></p>
<p>​        步骤2：添加菜品的基本信息到dish菜品表<code>this.save(dishDto);</code>；<font color="blue">（这里可以直接传dishDto对象）</font></p>
<p>​        步骤3：添加菜品口味数据flavors到菜品口味表dish_flavor，要注意dish_id（是一个not null字段）无法通过flavors列表赋值要通过Dto对象手动set。</p>
<p>​                               <img src="image-20230705182604710.png" alt="image-20230705182604710" style="zoom:77%;" /></p>
<h3 id="菜品信息分页查询"><a href="#菜品信息分页查询" class="headerlink" title="菜品信息分页查询"></a>菜品信息分页查询</h3><p><strong>流程分析</strong></p>
<p>这里的分页查询其实也是发送了两次请求：</p>
<ol>
<li>请求参数page、pageSize和可选参数name，发送分页请求并回显在页面上；</li>
<li>向服务端发送下载请求，将图片回显到页面上。（这个请求前面的CommonController表现层已经实现功能响应）</li>
</ol>
<p><strong>核心业务思路</strong></p>
<p>分页查询前面已经做过好多了，这里的分页查询图片列和菜品分类列比较特殊：</p>
<ul>
<li>图片列：会用到文件的下载功能</li>
<li>菜品分类列：由于我们的dish菜品表只保存了category_id，所以我们需要在category分类表中查询category_id对应的菜品分类名称，从而回显数据</li>
</ul>
<p><img src="image-20230705184128037.png" alt="image-20230705184128037"></p>
<p>因为代码中用到了几个比较关键的知识点，所以这里我直接展示业务代码，也方便到时候复习来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Page&gt; <span class="title function_">pageSelect</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> pageSize, String name)</span> &#123;</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page, pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.like(name != <span class="literal">null</span>, Dish::getName, name);</span><br><span class="line">        lambdaQueryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line">      </span><br><span class="line">        dishService.page(pageInfo, lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象拷贝pageInfo除了&quot;records&quot;属性</span></span><br><span class="line">        BeanUtils.copyProperties(pageInfo, dishDtoPage, <span class="string">&quot;records&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; dishDtoList = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();</span><br><span class="line">            <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">            <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">            dishDto.setCategoryName(categoryName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(dishDtoList);</span><br><span class="line">        <span class="keyword">return</span> Result.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h3><p><strong>流程分析</strong></p>
<ol>
<li>页面发送ajax请求，请求服务器获取分类数据，用于菜品分类下拉框的数据回显（之前已经实现过了）</li>
<li>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</li>
<li>页面发送请求，请求服务端进行图片下载，用于页面图片回显（之前已经实现过了）</li>
<li>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</li>
</ol>
<p><strong>表现层要素</strong></p>
<ul>
<li>回显数据</li>
</ul>
<p><img src="image-20230705214455637.png" alt="image-20230705214455637"></p>
<p>请求类型：GET</p>
<p>请求路径：<code>/dish/&#123;id&#125;</code></p>
<p>请求参数：RESTful风格的菜品id</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">queryDishById</span>(<span class="variable language_">this</span>.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123; ...res.<span class="property">data</span> &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">price</span> = <span class="title class_">String</span>(res.<span class="property">data</span>.<span class="property">price</span>/<span class="number">100</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">status</span> = res.<span class="property">data</span>.<span class="property">status</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dishFlavors</span> = res.<span class="property">data</span>.<span class="property">flavors</span> &amp;&amp; res.<span class="property">data</span>.<span class="property">flavors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">obj</span> =&gt;</span> (&#123; ...obj, <span class="attr">value</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(obj.<span class="property">value</span>),<span class="attr">showOption</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.dishFlavors&#x27;</span>,<span class="variable language_">this</span>.<span class="property">dishFlavors</span>)</span><br><span class="line">    <span class="comment">// this.ruleForm.id = res.data.data.categoryId</span></span><br><span class="line">    <span class="comment">// this.imageUrl = res.data.data.image</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">`/common/download?name=<span class="subst">$&#123;res.data.image&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方法返回值：前端用到了响应的<code>data.flavors</code>属性，所以响应的数据一定是Result<DishDto>类型</p>
<ul>
<li>提交修改数据</li>
</ul>
<p><img src="image-20230705215233049.png" alt="image-20230705215233049"></p>
<p>请求类型：PUT</p>
<p>请求路径：<code>/dish</code></p>
<img src="image-20230705215325955.png" alt="image-20230705215325955" style="zoom:77%;" />

<p>请求参数：json格式的DishDto对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">editDish</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;菜品修改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方法返回值：<code>Result&lt;String&gt;</code></p>
<p><strong>核心业务思路</strong></p>
<ul>
<li>回显数据</li>
</ul>
<p>​        这里的数据回显还是值得一提的。通常来说数据回显就是以id作为请求参数向服务端发送查询请求，在以id作为主键的数据表中查询到该条数据并将该对象作为相应参数返回并回显在页面上。但是这里回显的数据内容除了以id作为主键的dish菜品表外，还有flavors口味信息，需要在dish_flavor表中查询多条数据。</p>
<p>​        步骤1：在Service层自定义一个根据菜品id查询的业务层方法；</p>
<p>​        步骤2：根据id查询dish菜品表中的基本信息，只需要调用MybatisPlus原生的<code>getOne</code>方法得到查询到的Dish对象；</p>
<p>​        步骤3：因为要在dish_flavor表再做查询，而Dish对象没有flavors属性，所以定义一个DishDto增强对象，并进行Dish的对象拷贝；</p>
<p>​        步骤4：根据DishDto的id属性查询dish_id = id的DishDto对象列表，set给DishDto的flavors属性，将DishDto响应给前端。</p>
<ul>
<li><p>提交修改数据</p>
<p>很显然这里也要涉及两张表dish表和dish_flavor表的修改操作，所以先在Service实现类上加上注释<code>@Transactional</code>。</p>
<p>步骤1：先在Service实现类上加上注释<code>@Transactional</code>；</p>
</li>
</ul>
<p>​       步骤2：将请求参数DishDto传入MybatisPlus原生的<code>updateById</code>方法修改dish表中的菜品基本信息；</p>
<p>​       步骤3：在dish_flavor表中涉及多条数据的修改，所以这里的修改我们将其拆分为删除+添加两个过程来完成：首先是将dish_id = DishDto.id的数据删除；</p>
<p>​       步骤4：再将DishDto.flavors这个列表通过<code>saveBatch</code>方法添加到口味表中，其中dish_id字段在DishDto.flavors中没有相应的属性对应，要进行手动的set。</p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
</search>
