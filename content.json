[{"title":"springcloud02","date":"2023-12-19T12:07:44.000Z","path":"2023/12/19/springcloud02/","text":"springcloud入门笔记。 1、Nacos配置管理Nacos除了可以做注册中心，还可以进行配置管理。 统一配置管理当微服务部署的实例越来越多时，逐个修改微服务实例的配置太过繁琐，所以我们需要一种统一配置管理的方案，可以集中管理所有实例的配置。 Nacos一方面可以做配置的集中管理，另一方面可以在配置变更时及时通知微服务进行配置的热更新。 在nacos中添加配置文件 image-20231127103043283 在弹出的表单中填写配置信息： image-20231127103445612 项目的核心配置，需要热更新的配置才有放到nacos配置中心管理的必要；基本不会变更的基础配置还是要保存在微服务本地。 从微服务中拉取配置微服务需要拉取nacos中管理的配置，并且与本地application配置文件中的配置合并，才能完成项目的启动。 从微服务拉取配置我们需要先访问nacos再读取本地配置，但是nacos的地址是配置在本地application.yml配置文件中的： 1234spring: cloud: nacos: server-addr: localhost:8848 # nacos服务地址 尚未读取application.yml配置，无法知道nacos的地址，因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取： image-20231127104303113 引入nacos-config依赖 首先在user-service服务中，引入nacos-config的客户端依赖： 12345&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 添加bootstrap.yaml文件 这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;. $&#123;spring.cloud.nacos.config.file-extension&#125;作为文件id来读取配置。 12345678910spring: application: name: userservice # 服务名称 profiles: active: dev # 开发环境，这里是dev cloud: nacos: server-addr: localhost:8848 # Nacos地址 config: file-extension: yaml # 文件后缀名 读取nacos配置 在user-service中的Controller层中添加业务逻辑，读取nacos配置中心的配置： 12345678910111213141516171819202122232425@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat; /** * 路径： /user/110 * @param id 用户id * @return 用户 */ @GetMapping(&quot;/&#123;id&#125;&quot;) public User queryById(@PathVariable(&quot;id&quot;) Long id) &#123; return userService.queryById(id); &#125; @GetMapping(&quot;/time&quot;) public String now()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125;&#125; 在页面访问可以看到效果： 配置热更新配置热更新是指修改nacos的配置后，微服务中无需重启即可让配置生效。 要实现配置的热更新，有两种方式： 方式一（不推荐）在@Value注入的变量所在类上添加注释@RefreshScope： 12345678@Slf4j@RestController@RequestMapping(&quot;/user&quot;)@RefreshScope // 在新版springcloud应该已经不支持了，而且本身就不推荐使用 -- 改用config配置类public class UserController &#123; @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat;&#125; 方式二 步骤一 使用@ConfigurationProperties注释代替@Value注释：在user-service服务中，添加一个类来读取pattern.dateformat属性： 123456@Component@Data@ConfigurationProperties(prefix = &quot;pattern&quot;) // pattern.dateformat的pattern前缀public class PatternProperties &#123; private String dateformat;&#125; 步骤二 在Controller层使用PatternProperties类代替@Value： 1234567891011// @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)// private String dateformat; @Autowired private PatternProperties patternProperties; @GetMapping(&quot;/time&quot;) public String now()&#123; // 从@Value的变量值改为：patternProperties.getDateformat() return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat())); &#125; ​ image-20231127170830419 配置共享微服务在启动时，会从nacos中读取多个配置文件如： [spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml； [spring.application.name].yaml，例如：userservice.yaml，像这个配置文件不包含环境，因此可以被多个环境所共享。 通过案例来实现配置共享： 添加一个环境共享配置 在微服务中读取共享配置 在user-service服务中，在PatternProperties配置类中添加读取新的属性： 12345678@Component@Data@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123; private String dateformat; private String envSharedValue; // 新添加的属性&#125; 在Controller层中添加新的mapping方法： 1234567/** * 读取共享配置**/@GetMapping(&quot;/prop&quot;)public PatternProperties properties()&#123; return patternProperties;&#125; UserServiceApplication(8081)使用的profiles是dev（在bootstrap.yaml文件中定义了dev环境），UserServiceApplication(8082)使用的profiles是test： 所以从8082端口进行访问是无法得到userservice-dev.yaml配置文件中的配置信息的： 尽管如此，在userservice.yaml中的配置是共享的，无论在dev还是在test环境中都可以读取到： 配置共享的优先级 当nacos、服务本地出现相同属性时，优先级： 2、Feign远程调用先前我们在服务消费者（order-service）中利用RestTemplate发起远程调用： 1234// 2.1 url地址String url = &quot;http://userservice/user/&quot; + order.getUserId();// 2.2 通过restTemplate发起调用User u = restTemplate.getForObject(url, User.class); 缺点：① 代码可读性差； ② 参数复杂URL难以维护. 比如我在搜索引擎搜索“java”，就有很复杂的URL参数。 image-20231128085844270 Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign，作用是帮助我们远程调用时实现HTTP请求。 Feign代替RestTemplate 步骤1：引入依赖 在服务消费者（order-service）中引入Feign依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 步骤2：启动类添加注解开启功能 在服务消费者（order-service）的启动类添加注解开启Feign功能： 12345678@MapperScan(&quot;com.lijiacheng.order.dao&quot;)@SpringBootApplication@EnableFeignClients // 开启Feignpublic class OrderServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderServiceApplication.class, args); &#125;&#125; 步骤3：编写Feign客户端 在服务消费者（order-service）中新建一个接口（客户端），基于SpringMVC注解来声明远程调用的信息： 服务名称：userservice 请求方式：GET 请求路径：/user/&#123;id&#125; 请求参数：Long id 返回值类型：User 12345@FeignClient(&quot;userservice&quot;)public interface UserClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User findById(@PathVariable(&quot;id&quot;) Long id);&#125; 步骤4：利用 Feign远程调用 12345678910111213@Autowiredprivate UserClient userClient; // Feign的客户端public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderDao.findById(orderId); // 2.Feign远程调用 User u = userClient.findById(order.getUserId()); // 3.存入order order.setUser(u); // 4.返回 return order;&#125; 自定义配置 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign. Contract 支持的注解格式 默认是SpringMVC的注解 feign. Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。有两种方式进行Feign配置的自定义： 配置文件方式基于配置文件的方式修改Feign配置可以针对单个服务或针对所有服务： 单个服务 1234567spring: cloud: openfeign: client: config: userservice: # 针对某个微服务的配置 logger-level: full # 日志级别 所有服务 1234567spring: cloud: openfeign: client: config: default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置 logger-level: full # 日志级别 而日志的级别分为四种： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 java代码方式声明一个配置类，再在配置类里声明一个Logger.Level的对象： 1234567import feign.Logger;public class DefaultFeignConfiguration &#123; @Bean public Logger.Level feignLogLevel()&#123; return Logger.Level.BASIC; // 日志级别为BASIC &#125;&#125; 如果是局部生效，则把它放到对应的@FeignClient这个注解中： 如果是全局生效，则把它放到启动类的@EnableFeignClients注解中： Feign使用优化Feign底层发起http请求依赖于其他的框架，其底层客户端实现包括： URLConnection：默认实现，不支持连接池 Apache HttpClient：支持连接池 OKHttp：支持连接池 因此提高Feign性能的主要手段就是使用连接池代替默认的URLConnection，这里使用Apache的HttpClient来展示： 1）引入HttpClient依赖 12345&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置连接池 在服务消费者order-service的application.yml配置文件中添加配置： 1234567891011spring: cloud: openfeign: client: config: userservice: # 针对某个微服务的配置 logger-level: full # 日志级别 httpclient: enabled: true # 开启feign对于HttpClient的支持 max-connections: 200 # 最大的连接数 max-connections-per-route: 50 # 每个路径的最大连接数 Feign的优化总结： 1、日志级别尽量用basic 2、使用HttpClient或OKHttp代替URLConnection框架 ① 引入feign-httpClient依赖 ② 配置文件开启httpClient功能，设置连接池参数 Feign的最佳实践Feign的客户端与服务提供者的controller代码非常相似： 12345@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration.class)public interface UserClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User findById(@PathVariable(&quot;id&quot;) Long id);&#125; 123456789101112@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/&#123;id&#125;&quot;) public User queryById(@PathVariable(&quot;id&quot;) Long id) &#123; return userService.queryById(id); &#125;&#125; 继承方式（不常用）1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。 2）Feign客户端和Controller都集成改接口 优缺点 优点：简单、实现了代码共享 缺点：服务提供方、服务消费方紧密耦合；参数列表中的注解映射（上图是id）不会继承，因此在Controller层必须再次声明方法、参数列表和注解。 抽取方式将Feign的Cilent抽取为独立的模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。 实现基于抽取的最佳实践 抽取 在feign-api中然后引入feign的starter依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在order-service中编写的UserClient、User、DefaultFeignConfiguration都移到feign-api项目中： 在order-service中使用feign-api 在order-service中引入feign-api的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.lijiacheng&lt;/groupId&gt; &lt;artifactId&gt;feign-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包。 启动测试 服务出现报错：意思是bean没有注册到Spring容器当中。 image-20231128154751428 这是因为UserClient现在在com.lijiacheng.feign.clients包下，而order-service的@EnableFeignClients注解是在com.lijiacheng.order包下，不在同一个包无法扫描到UserClient。 image-20231128155324183 image-20231128155433928 解决包扫描的问题： 方式一：指定Feign应该扫描的包 1@EnableFeignClients(basePackages = &quot;com.lijiacheng.feign.client&quot;) 方式二：指定需要加载的cilents端口（精准） 1@EnableFeignClients(clients = &#123;UserClient.class&#125;) 3、Gateway服务网关网关是什么Gateway网关是所有微服务的统一入口。 网关的核心功能特性： 权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。 路由和负载均衡：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由（路由的目标服务有多个时，还需要做负载均衡）。 限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。 SpringCloud中网关的实现有gateway和Zuul两种，Zuul是基于Servlet的实现，gateway是基于Spring5提供的WebFlux，具备更好的性能。 gateway快速入门测试一下gateway最主要的路由功能。 创建gateway服务，引入依赖 如果不导入loadbalancer负载均衡依赖网关会无法使用lb://服务名称. 123456789101112131415&lt;!--网关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--高版本的SpringCloud需要导入负载均衡依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt; 编写启动类 1234567@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 编写基础配置和路由规则 创建application.yml配置文件，内容如下： 12345678910111213141516server: port: 10010 # 网关端口spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: # ===============网关路由配置=============== routes: - id: user-service # 路由id，自定义，只要唯一即可 uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求 ​ 将符合断言Path的一切请求，都代理到uri参数指定的地址。本例就是将/user/**开头的请求，代理到userservice服务并根据服务名拉取服务实现负载均衡。 重启测试 访问http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1： 断言工厂Predicate Factory读取并处理，转变为路由判断的条件，例如Path=/user/**是按照路径匹配，这个规则是由PathRoutePredicateFactory类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个，我们只需要掌握Path这种路由断言就可以： 名称 说明 示例 After 是某个时间点后的请求 - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 是某个时间点之前的请求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 是某两个时间点之前的请求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 请求必须包含某些cookie - Cookie=chocolate, ch.p Header 请求必须包含某些header - Header=X-Request-Id, \\d+ Host 请求必须是访问某个host（域名） - Host=.somehost.org,.anotherhost.org Method 请求方式必须是指定方式 - Method=GET,POST Path 请求路径必须符合指定规则 - Path=/red/{segment},/blue/** Query 请求参数必须包含指定参数 - Query=name, Jack或者- Query=name RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr=192.168.1.1/24 Weight 权重处理 过滤器工厂GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理： 路由过滤器的种类Spring提供了31种不同的路由过滤器工厂，例如： 名称 说明 AddRequestHeader 给当前请求添加一个请求头 RemoveRequestHeader 移除请求中的一个请求头 AddResponseHeader 给响应结果中添加一个响应头 RemoveResponseHeader 从响应结果中移除有一个响应头 RequestRateLimiter 限制请求的流量 请求头过滤器以AddRequestHeader 为例，需求是：给所有进入userservice的请求添加一个请求头：Truth, ljc is a good coder!（“键, 值”形式） 只需要在gateway服务的application配置文件中配置路由过滤即可： 123456- id: user-service # 路由id uri: lb://userservice predicates: - Path=/user/** filters: # 过滤器 - AddRequestHeader=Truth, ljc is a good coder! # 添加请求头 当前过滤器写在userservice路由下，所以仅对访问userservice的请求有效。 在user-service的contoller层加入添加请求头的验证功能： 123456// 添加过滤器添加请求头验证功能@GetMapping(&quot;/&#123;id&#125;&quot;)public User queryById(@PathVariable(&quot;id&quot;) Long id, @RequestHeader(value = &quot;Truth&quot;, required = false) String header) &#123; System.out.println(&quot;Truth:&quot; + header); return userService.queryById(id);&#125; @RequestHeader表示获取请求头信息，value是获取相应键的请求头信息，required是false允许无此请求头信息，在控制台打印出来。 image-20231130095800873 默认过滤器如果要对所有的路由都生效，则可以将过滤器工厂写到default下： 12345678gateway: routes: # 网关路由配置 - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 默认过滤项 - AddRequestHeader=Truth, ljc is a good coder! 全局过滤器网关提供了31种过滤器，但每一种过滤器的作用都是固定的。如果我们希望拦截请求做特定的业务逻辑则没办法实现。全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。 在filter中通过实现GloabalFilter接口编写自定义逻辑，可以实现下列功能： 登录状态判断 权限校验 请求限流等 1234567891011121314151617181920212223242526@Order(-1) // 定义过滤器的优先级@Component public class AuthorizeFilter implements GlobalFilter &#123; // 定义方式是实现GlobalFilter接口 /** * @param exchange 请求上下文，里面可以获取Request、Response等信息 * @param chain 用来把请求委托给下一个过滤器 * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束 */ @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1、获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap&lt;String, String&gt; requestQueryParams = request.getQueryParams(); // 2、获取authorization请求参数 String author = requestQueryParams.getFirst(&quot;authorization&quot;); // 3、校验 if(author.equals(&quot;admin&quot;))&#123; // 放行 return chain.filter(exchange); &#125; // 4、拦截 // 禁止访问，设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 401 return exchange.getResponse().setComplete(); &#125;&#125; image-20231130101748204 在加入正确的请求参数后，过滤器放行，user-service微服务访问生效： 过滤器执行顺序请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter。请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： 排序的规则： 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定。 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。 当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行（想让GlobalFilter先执行将order值调到负数即可）。 跨域问题跨域：域名不一致就是跨域，主要包括： 域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com 域名相同，端口不同：localhost:8080和localhost:8081 跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题；解决方案：CORS。","tags":[]},{"title":"springcloud02","date":"2023-12-06T12:07:44.000Z","path":"2023/12/06/springcloud01/","text":"springcloud入门笔记。 1、微服务单体架构 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 分布式架构根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 优点： 降低服务耦合 有利于服务升级和拓展 缺点： 服务调用关系错综复杂 微服务微服务的架构特征： 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责 自治：团队独立、技术独立、数据独立，独立部署和交付 面向服务：服务提供统一标准的接口，与语言和技术无关 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 微服务是一种经过良好架构设计的分布式架构方案，在分布式架构的基础上进一步降低了服务之间的耦合性，做到了高内聚、低耦合。 SpringCloudSpringCloud是目前国内使用最广泛的微服务框架，SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配。 注意SpringCloud和Springboot的版本之间有一定的兼容关系： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- version管理 --&gt;&lt;spring-cloud.version&gt;2022.0.3&lt;/spring-cloud.version&gt; 2、服务拆分和远程调用服务拆分原则 不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其它微服务的数据库 微服务可以将自己的业务暴露为接口，供其它微服务调用 服务拆分案例数据库中cloud-user和cloud-order表： 在OrderController层有根据id查询的接口： 12345@GetMapping(&quot;/&#123;orderId&#125;&quot;)public Order queryOrderByUserId(@PathVariable(&quot;orderId&quot;) Long orderId) &#123; // 根据id查询订单并返回 return orderService.queryOrderById(orderId);&#125; 查询结果： image-20231030152721464 同样在UserController曾有根据id查询的接口： 1234@GetMapping(&quot;/&#123;id&#125;&quot;)public User queryById(@PathVariable(&quot;id&quot;) Long id) &#123; return userService.queryById(id);&#125; 查询结果： image-20231030153319794 远程调用案例每个业务模块对应着自己业务的数据库，不可跨业务访问。 12345678spring: datasource: url: jdbc:mysql://localhost:3306/cloud_order?useSSL=false # order-service中连接的是本地的cloud_order数据库 username: root password: 12345678 driver-class-name: com.mysql.cj.jdbc.Driver application: name: orderservice 123456spring: datasource: url: jdbc:mysql://localhost:3306/cloud_user?useSSL=false # user-service中连接的是本地的cloud-user数据库 username: root password: 12345678 driver-class-name: com.mysql.cj.jdbc.Driver image-20231030152721464 在order-service模块中查询订单信息时 user == null，而我们希望在order-service的接口中可以根据id查询订单的同时，根据订单中包含的userId查询出用户信息一起返回。 因此，我们需要在order-service中向user-service发送一个http请求，调用user-service的http://localhost:8081/user/&#123;userId&#125;接口来查询cloud-user数据库的内容。 远程调用步骤： 注册一个RestTemplate实例到Spring容器中（在启动类中注册Bean） 123456789101112@MapperScan(&quot;com.lijiacheng.order.dao&quot;)@SpringBootApplicationpublic class OrderServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderServiceApplication.class, args); &#125; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改order-service中的接口方法，通过Order对象的userId来查询User 将User对象填充到Order对象一同返回 1234567891011121314151617181920212223@Servicepublic class OrderService &#123; @Autowired private OrderDao orderDao; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderDao.findById(orderId); // 2.远程查询user // 2.1 url地址 String url = &quot;http://localhost:8081/user/&quot; + order.getUserId(); // 2.2 通过restTemplate发起调用 User u = restTemplate.getForObject(url, User.class); // 3.存入order order.setUser(u); // 4.返回 return order; &#125;&#125; image-20231030155118802 提供者和消费者服务提供者：一次业务中，被其它微服务调用的服务（提供接口给其它微服务） 服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口） 服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。 image-20231030155844415 3、Eureka注册中心假设服务提供者user-service部署了多个实例供服务消费者调用： 那么我们会好奇几个问题：order-service是如何得到user-service实例的ip地址和端口的？有多个消费者时如何选择？服务消费者如何知道提供者实例是否仍然健康？ Eureka的结构和作用Eureka是SpringCloud中的一个注册中心，来解决上述问题。 Eureka原理 服务注册：user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端） eureka-server保存服务名称到服务实例地址列表的映射关系 服务拉取（服务发现）：order-service根据服务名称，拉取实例地址列表 通过负载均衡算法挑选一个提供者服务，实现远程调用 心跳：user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态 一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端。 搭建eureka-server注册中心服务端：eureka-server，这必须是一个独立的微服务。 创建module，引入服务端依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 修改启动类：@EnableEurekaServer注解用来开启注册中心功能 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 编写配置文件 12345678910server: port: 10086spring: application: name: eureka-servereureka: # eureka的客户端配置 client: service-url: defaultZone: http://127.0.0.1:10086/eureka 启动服务 服务注册接下来将服务提供者user-service注册到eureka-service中。 在服务提供者user-service中引入eureka-client依赖（注意这里是client端）： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在服务提供者user-service中，修改配置文件，添加服务名称、eureka地址： 1234567spring: application: name: userserviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 启动多个服务提供者user-service实例 image-20231030164507443 服务拉取将order-service的逻辑修改，向eureka-server拉取user-service的信息，实现服务拉取（服务发现）。 在服务消费者order-service中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册一致。 在服务消费者order-service中配置文件 1234567spring: application: name: orderserviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 服务拉取和负载均衡 到eureka-server中拉取服务提供者user-service服务的实例列表，并且实现负载均衡。 在RestTemplate（实现远程调用的Bean）中加入表示客户端负载均衡的注释@LoadBalanced 12345@LoadBalanced // 标注此注解后，RestTemplate就具有了客户端负载均衡能力@Beanpublic RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 修改服务消费者order-service的调用接口中的url路径，用服务名代替ip、端口： 向order-service的查询业务重复发送请求（2次）——实现了负载均衡。 image-20231030170633134 image-20231030170657000 注意：Springcloud的新版本已经没有ribbon组件（实现负载均衡）了，需要导入以下两个pom依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt; &lt;artifactId&gt;ribbon&lt;/artifactId&gt; &lt;version&gt;2.7.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; Ribbon负载均衡上一章节，我们在RestTemplate这个Bean中添加注释@LoadBalanced即可实现负载均衡。 负载均衡原理SpringCloud底层利用一个名为Ribbon的组件来实现负载均衡： 源码实现我们只输入了service名称，就获取到了服务实例的ip和端口——就是LoadBalancerInterceptor，这个类会在对RestTemplate远程调用的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。 负载均衡原理：首先通过LoadBalancerInterceptor拦截了用户的http请求，获取用户请求的URL和服务id，交给LoadBalancerClient；LoadBalancerClient利用内置的负载均衡算法（默认是轮询）选择服务列表中的端口号用于服务。 image-20231031084059739 总结Ribbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改： 负载均衡策略负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类： 内置负载均衡规则类 规则描述 RoundRobinRule 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则 AvailabilityFilteringRule 对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略 WeightedResponseTimeRule 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择 ZoneAvoidanceRule 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询 BestAvailableRule 忽略那些短路的服务器，并选择并发数较低的服务器 RandomRule 随机选择一个可用的服务器 RetryRule 重试机制的选择逻辑 自定义负载均衡策略 注意：一般用默认的负载均衡规则，不做修改。 方法一：代码方式——在服务消费者order-service中的启动类中，定义一个新的(Bean)IRule： 1234@Beanpublic IRule randomRule()&#123; return new RandomRule();&#125; 方法二：配置文件方式——在服务消费者order-service的yml文件中，添加新的配置： 123userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 饥饿加载Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载： 12345# 饥饿加载ribbon: eager-load: enabled: true clients: userservice Nacos注册中心SpringCloud Alibaba也推出了一个名为Nacos的注册中心。 安装Nacos Windows版 1、下载安装包 GitHub主页：https://github.com/alibaba/nacos 2、目录说明 3、端口配置 Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口： 4、启动 进行bin目录，执行： 1startup.cmd -m standalone 5、访问 默认的账号和密码都是nacos。 服务注册到NacosNacos和Eureka对于微服务来说没有什么区别，主要差异在：① 依赖不同；② 服务地址不同。 引入依赖 父依赖 12345678&lt;!-- nacos的管理依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2022.0.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 在服务的消费者和提供者order-service和user-service中引入discovery依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 配置nacos地址 在yml文件中配置nacos地址： 1234spring: cloud: nacos: server-addr: localhost:8848 # nacos服务地址 启动微服务 服务分级存储模型举例来说，user-service是服务，一个服务可以包含多个集群（如杭州、上海），每个集群下可以有多个实例，形成分级模型： 微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群： 集群配置修改user-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 # nacos服务地址 discovery: cluster-name: HZ # 集群名称 再次复制一个user-service启动配置，添加属性： 同集群优先的负载均衡默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡；因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例： 因为作为服务消费者的order-service要远程调用服务提供者user-service，所以要在order-service中配置Nacos负载均衡的设置： 将order-service的服务也加入到前面的HZ集群 123456spring: cloud: nacos: server-addr: localhost:8848 # nacos服务地址 discovery: cluster-name: HZ # 集群名称 在服务消费者order-service中加入负载均衡设置 1234# 负载均衡的配置规则userservice: # 要做配置的微服务名称 ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 出现了问题：Nacos注册中心，访问不了order-service服务： image-20231101084020891 【解决方案】在新版本的springcloud（我用的是2022.0.0）中已经没有默认的ribbon负载均衡组件了，需要手动导入这个负载均衡依赖（不用导入ribbon依赖了）： 1234&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&gt;&lt;/dependency&gt; 负载均衡的权重配置服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。 环境隔离 nacos中可以有多个namespace； namespace下可以有group、service等； 不同namespace之间相互隔离，例如不同namespace的服务互相不可见； 创建namespace 给微服务配置namespace 1234567spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ namespace: 6adbcdc1-bb2e-460c-a447-e100eae322d2 # 命名空间配置 这时候访问order-service会导致远程调用user-service时找不到userservice的实例，这是因为它们的namespace不同！ Nacos和Eureka的比较Nacos的服务实例分为两种类型： 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。 将一个服务设置为永久实例： 12345spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例 Nacos与eureka的共同点： 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别： Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除（等待重新恢复健康） Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 AP（可用性和分区容忍性）： AP模型强调在面对网络分区或节点故障时保持系统的可用性。 在AP模型下，系统会允许数据在不同部分之间存在短暂的不一致性，以保证系统的可用性。这意味着在某些情况下，系统可能会返回陈旧或部分不一致的数据，但不会拒绝请求。 AP系统通常用于需要高可用性和容忍分区故障的场景，例如，社交媒体应用或内容分发网络（CDN）。 CP（一致性和分区容忍性）： CP模型强调在面对网络分区或节点故障时保持数据的一致性。 在CP模型下，系统会确保数据的一致性，即使这可能导致一些部分的系统不可用。系统会拒绝写入或读取请求，直到数据一致性得到满足。 CP系统通常用于需要数据一致性和容忍分区故障的场景，例如，金融交易系统或医疗记录系统。 ​ ——ChatGPT","tags":[]},{"title":"algorithm08-dp之子序列","date":"2023-08-11T02:32:09.000Z","path":"2023/08/11/algorithm08-dp之子序列/","text":"不连续子序列300. 最长递增子序列 image-20230811103401752 定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。 我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：$$dp[i]=max⁡(dp[j])+1,其中 0≤j&lt;i 且 num[j]&lt;num[i]$$ 12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; // init dp[0] = 1; int maxans = 1; // dp for(int i=1;i&lt;nums.length;i++)&#123; dp[i] = 1; for(int j=0;j&lt;i;j++)&#123; if(nums[j] &lt; nums[i])&#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; maxans = Math.max(dp[i], maxans); &#125; return maxans; &#125;&#125; 1143. 最长公共子序列 image-20230811110006614 最长公共子序列问题是典型的二维动态规划问题。 假设字符串 text1 和 text2的长度分别为 m 和 n，创建 m 行 n 列的二维数组dp，其中 dp[i][j]表示 text1[0:i]和 text2[0:j]的最长公共子序列的长度。 当 i&gt;0 且 j&gt;0 时，考虑 dp[i][j] 的计算： 当 text1[i] = text2[j]时，将这两个相同的字符称为公共字符，考虑 text1[0:i−1] 和 text2[0:j−1]的最长公共子序列，再增加一个字符（即公共字符）即可得到 text1[0:i]和 text2[0:j]的最长公共子序列，因此 dp[i][j] = dp[i−1][j−1]+1。 当 text1[i] ≠ text2[j] 时，考虑以下两项： text1[0:i−1] 和 text2[0:j] 的最长公共子序列； text1[0:i] 和 text2[0:j−1] 的最长公共子序列； 由此可以得到如下状态转移方程： image-20230811112053495 123456789101112131415161718192021222324252627282930class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(); int n = text2.length(); int[][] dp = new int[m][n]; // init boolean stage = false; for(int i=0;i&lt;m;i++)&#123; if(text1.charAt(i) == text2.charAt(0))&#123; stage = true; &#125; dp[i][0] = stage == true ? 1:0; &#125; stage = false; for(int j=0;j&lt;n;j++)&#123; if(text1.charAt(0) == text2.charAt(j))&#123; stage = true; &#125; dp[0][j] = stage == true ? 1:0; &#125; // dp for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; int max = Math.max(dp[i-1][j], dp[i][j-1]); dp[i][j] = text1.charAt(i) == text2.charAt(j) ? dp[i-1][j-1] + 1 : max; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 1035. 不相交的线高情商版本的最长子序列问题，与1143题一模一样。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[][] dp = new int[m][n]; // init boolean stage = false; for(int i=0;i&lt;m;i++)&#123; if(nums1[i] == nums2[0])&#123; stage = true; &#125; dp[i][0] = stage == true ? 1:0; &#125; stage = false; for(int j=0;j&lt;n;j++)&#123; if(nums1[0] == nums2[j])&#123; stage = true; &#125; dp[0][j] = stage == true ? 1:0; &#125; // dp for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; if(nums1[i] == nums2[j])&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 连续子序列674. 最长连续递增序列 image-20230811114008992 dp[i]代表以nums[i]为结尾的递增序列长度。 123456789101112131415class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; // init dp[0] = 1; // dp int maxans = 1; for(int i=1;i&lt;n;i++)&#123; dp[i] = nums[i-1] &lt; nums[i] ? dp[i-1]+1 : 1; maxans = Math.max(dp[i], maxans); &#125; return maxans; &#125;&#125; 718. 最长重复子数组 image-20230811161804773 dp[i][j]表示以nums1[i]和nums2[j]为结尾的子数组的公共子数组长度。当nums1[i] == nums2[j]时，dp[i][j]由dp[i-1][j-1]状态转移过来。 12345678910111213141516171819202122232425class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[][] dp = new int[m][n]; // init int maxans = 0; for(int i=0;i&lt;m;i++)&#123; dp[i][0] = nums1[i] == nums2[0] ? 1:0; maxans = Math.max(dp[i][0], maxans); &#125; for(int j=0;j&lt;n;j++)&#123; dp[0][j] = nums1[0] == nums2[j] ? 1:0; maxans = Math.max(dp[0][j], maxans); &#125; // dp for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j] = nums1[i] == nums2[j] ? dp[i-1][j-1]+1 : 0; maxans = Math.max(dp[i][j], maxans); &#125; &#125; return maxans; &#125;&#125; 53. 最大子数组和 image-20230811164122670 dp[i]表示以nums[i]为结尾的子数组的最大和，通过比较dp[i-1]+nums[i]和nums[i]的状态转移到dp[i]上来。 123456789101112class Solution &#123; public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length]; dp[0] = nums[0]; int maxans = dp[0]; for(int i=1;i&lt;nums.length;i++)&#123; dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); maxans = Math.max(maxans, dp[i]); &#125; return maxans; &#125;&#125; 392. 判断子序列 image-20230811164503300 12345678910111213141516171819202122class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int m = s.length(); int n = t.length(); boolean stage = false; int count = 0; for(int i=0;i&lt;m;i++)&#123; stage = false; for(int j=count;j&lt;n;j++)&#123; if(s.charAt(i) == t.charAt(j))&#123; stage = true; count = j+1; break; &#125; &#125; if(stage == false)&#123; return false; &#125; &#125; return true; &#125;&#125;","tags":[]},{"title":"algorithm07-dp之股票系列","date":"2023-08-05T03:34:25.000Z","path":"2023/08/05/algorithm07-dp之股票系列/","text":"121. 买卖股票的最佳时机 image-20230805115618486 只能买卖一次，所以维护一个历史最低价minprice变量，意为在第i天时，[0, …, i-1]天中的最底价。这是一种动态规划的思想。 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int minprice = prices[0]; int maxprofit = 0; for(int i=1;i&lt;prices.length;i++)&#123; minprice = minprice &lt;= prices[i] ? minprice : prices[i]; maxprofit = maxprofit &gt;= (prices[i] - minprice) ? maxprofit : (prices[i] - minprice); &#125; return maxprofit; &#125;&#125; 122. 买卖股票的最佳时机 II image-20230805120302626 可以买卖任意次数，这里通过二维数组dp[prices.length][2]表示每个状态，dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。dp[][0]表示持有现金，dp[][1]表示持有股票。 每一天状态可以转移，也可以不动。状态转移用下图表示： image-20230805121048597 状态转移方程： 12dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); 完整代码如下： 12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int[][] dp = new int[prices.length][2]; // 状态位：dp[][0]表示持有现金 dp[][1]表示持有股票 dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i=1;i&lt;prices.length;i++)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); &#125; return dp[prices.length-1][0]; &#125;&#125; 由于在状态转移方程中我们仅需参考上一位状态，所以可以采用滚动数组的思想进行空间优化： 12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int cash = 0; int stock = -prices[0]; for(int i=1;i&lt;prices.length;i++)&#123; int precash = cash; int prestock = stock; cash = Math.max(precash, prestock + prices[i]); stock = Math.max(prestock, precash - prices[i]); &#125; return cash; &#125;&#125; 123. 买卖股票的最佳时机 III image-20230805160417623 限定只能买卖两次。因此在任意一天结束之后，我们会处于以下五个状态中的一种： ① 未进行过任何操作；② 只进行过一次买操作；③ 进行了一次买操作和一次卖操作，即完成了一笔交易；④ 在完成了一笔交易的前提下，进行了第二次买操作；⑤ 完成了全部两笔交易。 由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为buy1, sell1, buy2 以及sell2： 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; // init int buy1 = -prices[0]; int sell1 = 0; int buy2 = -prices[0]; int sell2 = 0; // dp for(int i=1;i&lt;prices.length;i++)&#123; buy1 = Math.max(buy1, -prices[i]); // 第一次买入的状态 sell1 = Math.max(sell1, buy1 + prices[i]); // 第一次卖出的状态 buy2 = Math.max(buy2, sell1 - prices[i]); // 第二次买入的状态 sell2 = Math.max(sell2, buy2 + prices[i]); // 第二次卖出的状态 &#125; return sell2; &#125;&#125; 下面这种解法仅作为一种思路参考，只能限定于2次买卖的情况，不具有股票问题的普适性，而且个人感觉该思路比较别扭。 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; int[] dp1 = new int[prices.length]; // 表示第i天以及之前区间所获得的最大利润 int[] dp2 = new int[prices.length]; // 表示第i天开始到最后一天所获得的最大利润 int minVal = prices[0], maxVal = prices[prices.length-1]; dp1[0] = 0; for(int i=1;i&lt;dp1.length;i++)&#123; dp1[i] = Math.max(dp1[i-1], prices[i]-minVal); minVal = prices[i] &lt; minVal ? prices[i] : minVal; &#125; dp2[dp2.length-1] = 0; for(int i=dp2.length-2;i&gt;=0;i--)&#123; dp2[i] = Math.max(dp2[i+1], maxVal-prices[i]); maxVal = prices[i] &gt; maxVal ? prices[i] : maxVal; &#125; int max = 0; for(int i=0;i&lt;prices.length;i++)&#123; max = Math.max(dp1[i] + dp2[i], max); &#125; return max; &#125;&#125; 188. 买卖股票的最佳时机 IV image-20230805163734130 思路与 买卖股票的最佳时机 III 完全一致！ 12345678910111213141516171819class Solution &#123; public int maxProfit(int k, int[] prices) &#123; int[] buy = new int[k]; int[] sell = new int[k]; // init Arrays.fill(buy, -prices[0]); Arrays.fill(sell, 0); // dp for(int i=0;i&lt;prices.length;i++)&#123; buy[0] = Math.max(buy[0], -prices[i]); sell[0] = Math.max(sell[0], buy[0] + prices[i]); for(int j=1;j&lt;k;j++)&#123; buy[j] = Math.max(buy[j], sell[j-1] - prices[i]); sell[j] = Math.max(sell[j], buy[j] + prices[i]); &#125; &#125; return sell[k-1]; &#125;&#125;","tags":[]},{"title":"algorithm06-回溯算法","date":"2023-07-21T04:03:09.000Z","path":"2023/07/21/algorithm06-回溯算法/","text":"组合77. 组合 image-20230815163034834 image-20230721155109453 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); dfs(n, k, 1, path); return res; &#125; public void dfs(int n, int k, int begin, Deque&lt;Integer&gt; path)&#123; if(path.size() == k)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=begin;i&lt;=n;i++)&#123; path.addLast(i); dfs(n, k, i+1, path); path.removeLast(); &#125; &#125;&#125; 剪枝： 12345678910111213141516171819202122232425class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); dfs(n, k, 1, path); return res; &#125; public void dfs(int n, int k, int begin, Deque&lt;Integer&gt; path)&#123; if(path.size() == k)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=begin;i&lt;=n;i++)&#123; // 如果当前可选的数 小于 path剩余的size，则剪枝 if(k - path.size() - 1 &gt; n - i)&#123; break; &#125; path.addLast(i); dfs(n, k, i+1, path); path.removeLast(); &#125; &#125;&#125; 17. 电话号码的字母组合 image-20230815163058336 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); public void buildMap()&#123; map.put(2, &quot;abc&quot;); map.put(3, &quot;def&quot;); map.put(4, &quot;ghi&quot;); map.put(5, &quot;jkl&quot;); map.put(6, &quot;mno&quot;); map.put(7, &quot;pqrs&quot;); map.put(8, &quot;tuv&quot;); map.put(9, &quot;wxyz&quot;); &#125; public List&lt;String&gt; letterCombinations(String digits) &#123; if(digits.length() == 0)&#123; return res; &#125; buildMap(); String path = &quot;&quot;; dfs(digits, 0, path); return res; &#125; public void dfs(String digits, int depth, String path)&#123; if(depth == digits.length())&#123; res.add(path); return; &#125; char ch = digits.charAt(depth); String str_ch = map.get(ch - &#x27;0&#x27;); for(int i=0;i&lt;str_ch.length();i++)&#123; path += str_ch.charAt(i); dfs(digits, depth+1, path); path = path.substring(0, path.length()-1); &#125; &#125;&#125; 39. 组合总和 image-20230815163405787 组合类回溯问题使用 begin 状态位限制重复出现的答案： 1dfs(candidates, target - candidates[i], i, path); 12345678910111213141516171819202122232425class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); dfs(candidates, target, 0, path); return res; &#125; public void dfs(int[] candidates, int target, int begin, Deque&lt;Integer&gt; path)&#123; if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=begin;i&lt;candidates.length;i++)&#123; if(target &lt; candidates[i])&#123; break; &#125; path.addLast(candidates[i]); dfs(candidates, target - candidates[i], i, path); path.removeLast(); &#125; &#125;&#125; 40. 组合总和 II image-20230817104851768 和39题的区别有二：① candidates[i]在每个组合中只能使用一次； ② candidates数组在本题中包含了重复元素。 ① 解决方案：纵向限制 1dfs(candidates, target - candidates[i], i+1, path); ② 解决方案：横向限制 123if(i-1 &gt;= begin &amp;&amp; candidates[i] == candidates[i-1])&#123; continue;&#125; 123456789101112131415161718192021222324252627class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); dfs(candidates, target, 0, path); return res; &#125; public void dfs(int[] candidates, int target, int begin, Deque&lt;Integer&gt; path)&#123; if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=begin;i&lt;candidates.length;i++)&#123; if(target &lt; candidates[i])&#123; break; &#125; if(i-1 &gt;= begin &amp;&amp; candidates[i] == candidates[i-1])&#123; continue; &#125; path.addLast(candidates[i]); dfs(candidates, target - candidates[i], i+1, path); path.removeLast(); &#125; &#125;&#125; 216. 组合总和 III image-20230817111908237 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); dfs(n, k, 1, path); return res; &#125; public void dfs(int target, int k, int begin, Deque&lt;Integer&gt; path)&#123; if(path.size() == k)&#123; if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(path)); &#125; return; &#125; for(int i=begin;i&lt;=9;i++)&#123; // ----可剪枝---- path.addLast(i); dfs(target - i, k, i + 1, path); path.removeLast(); &#125; &#125;&#125; 剪枝条件： 123if(k - path.size() &gt; 9 - i + 1)&#123; break;&#125; 分割131. 分割回文串 image-20230829151735071 93","tags":[]},{"title":"algorithm05-二叉树","date":"2023-07-18T09:07:58.000Z","path":"2023/07/18/algorithm05-二叉树/","text":"二叉树的遍历方式递归遍历递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。 前序遍历 按照访问根节点→左子树→右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。 123456789101112131415class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); traversal(root, res); return res; &#125; public static void traversal(TreeNode node, List&lt;Integer&gt; res)&#123; if(node == null)&#123; return; &#125; res.add(node.val); traversal(node.left, res); traversal(node.right, res); &#125;&#125; 中序遍历 按照访问左子树→根节点→右子树的方式遍历这棵树。 123456789101112131415class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); traversal(root, res); return res; &#125; public static void traversal(TreeNode node, List&lt;Integer&gt; res)&#123; if(node == null)&#123; return; &#125; traversal(node.left, res); res.add(node.val); traversal(node.right, res); &#125;&#125; 后序遍历 按照访问左子树→右子树→根节点的方式遍历这棵树。 123456789101112131415class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); traversal(root, res); return res; &#125; public static void traversal(TreeNode node, List&lt;Integer&gt; res)&#123; if(node == null)&#123; return; &#125; traversal(node.left, res); traversal(node.right, res); res.add(node.val); &#125;&#125; 迭代遍历递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来。相较于递归方法，迭代遍历的代码更难理解一些，但是本质都是相同的。 前序遍历 首先我们应该创建一个 Stack 用来存放节点，首先我们想要打印根节点的数据，此时 Stack 里面的内容为空，所以我们优先将头结点加入 Stack，然后打印。之后我们应该先打印左子树，然后右子树。所以先加入 Stack 的就是右子树，然后左子树。 12345678910111213141516171819202122class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); if(root == null)&#123; return res; &#125; stack.push(root); while(!stack.isEmpty())&#123; root = stack.pop(); res.add(root.val); // 一定要先压入右子树，再压入左子树，注意Stack的先进后出特性 if(root.right != null)&#123; stack.push(root.right); &#125; if(root.left != null)&#123; stack.push(root.left); &#125; &#125; return res; &#125;&#125; 中序遍历 按 左子树→根节点→右子树 的顺序输出节点。尽可能的将这个节点的左子树压入 Stack，此时栈顶的元素是最左侧的元素（也就是最左侧的一个节点），并且在寻找的过程中记录了来源，才能返回上层，同时在返回上层的时候已经处理完毕左子树了。如果有右节点，其也要进行中序遍历。 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); while(root != null || !stack.isEmpty())&#123; while(root != null)&#123; // 将这个节点的左子树压入Stack stack.push(root); root = root.left; &#125; // 出内循环是root一定为null，如果node没有右子树就会回退一层 TreeNode node = stack.pop(); res.add(node.val); if(node.right != null)&#123; // 如果有右节点，其也要进行中序遍历 root = node.right; &#125; &#125; return res; &#125;&#125; 后序遍历 后序遍历和中序一样，都要先找到二叉树最左侧的节点，但是由于后序遍历的顺序是 左子树→右子树→根节点，所以和中序还略有不同——找到最左侧节点后不能马上输出，要先判断该节点是否有右子树：如果有右子树，要将右子树的根节点重复执行前面的步骤；如果没有右子树，则输出该节点并回退一层继续寻找右子树。需要注意的是，由于在压出右子树后进行回退时根节点（左右子树的根，严格意义上的中间节点）仍在栈中，所以要记录右子树节点为prev才能将根节点压出（压出节点的条件是该节点没有右子树或者右子树已经输出完），否则会造成死循环。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode prev = null; if(root == null)&#123; return res; &#125; while(root != null || !stack.isEmpty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; // 执行内循环后root取为最左侧节点，但不能马上将其输出，要先考虑该节点是否有优先级更高的右子树 root = stack.peek(); // 压出节点的条件是该节点 没有右子树 或者 右子树已经输出完 if(root.right == null || root.right == prev)&#123; res.add(root.val); stack.pop(); prev = root; // 记录刚输出的节点 root = null; // 回退上层的标志 &#125; else &#123; root = root.right; &#125; &#125; return res; &#125;&#125; 二叉树的层序遍历层序遍历就是把二叉树分层，然后每一层从左到右遍历： 这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。BFS ，广度优先搜索，遍历使用队列数据结构。而这里的层序遍历，就是 BFS 的应用场景之一。在层序遍历中，要记录每一层节点的个数，然后通过内置for循环一口气将这一层的节点处理完。 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root != null)&#123; queue.addLast(root); &#125; while(!queue.isEmpty())&#123; ArrayList&lt;Integer&gt; r = new ArrayList&lt;&gt;(); int num = queue.size(); // 记录每一层节点的个数 for(int i=0;i&lt;num;i++)&#123; TreeNode node = queue.removeFirst(); r.add(node.val); if(node.left != null)&#123; queue.addLast(node.left); &#125; if(node.right != null)&#123; queue.addLast(node.right); &#125; &#125; res.add(r); &#125; return res; &#125;&#125; BFS 广度优先搜索，需要解决以下三类问题： BFS遍历 层序遍历 最短路径 最后来讲一下BFS 的最短路径问题。BFS 属于图算法，这里就先简单讲一下。在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。 二叉树的属性翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。 1234567891011121314151617181920212223class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root == null)&#123; return null; &#125; invert(root); return root; &#125; public static void invert(TreeNode root)&#123; if(root.left == null &amp;&amp; root.right == null)&#123; return; &#125; if(root.left != null)&#123; invert(root.left); &#125; if(root.right != null)&#123; invert(root.right); &#125; TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125;&#125; 看过题解后，发现可以将递归程序写的更优雅： 123456789101112class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; &#125;&#125; 对称二叉树给定一个二叉树，检查它是否是镜像对称的。 递归方法（重点掌握递归法即可） 对称二叉树的递归思路是，要保证当前两节点的值相等，并且递归调用左右节点另其镜像相等，只要有一处镜像不对称，那就输出false。 12345678910111213141516171819class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; // 树中节点数目在范围 [1, 1000] 内 if(root.left == null &amp;&amp; root.right == null)&#123; return true; &#125; return check(root.left, root.right); &#125; public static boolean check(TreeNode p, TreeNode q)&#123; if(p == null &amp;&amp; q == null)&#123; return true; &#125; if(p == null || q == null)&#123; return false; &#125; return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left); &#125;&#125; 迭代方法 手动维护一个队列结构，根据层序遍历的思想对每一层进行检验：每次拿出的两个元素， 就是镜像位置的元素，进行比较即可。Deque接口的offer方法不会报空指针异常（此方法通常优于add仅通过抛出异常来插入元素失败的方法），可酌情选择使用。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root.left == null &amp;&amp; root.right ==null)&#123; return true; &#125; else if(root.left == null || root.right == null)&#123; return false; &#125; return check(root.left, root.right); &#125; public static boolean check(TreeNode p, TreeNode q)&#123; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.addLast(p); queue.addLast(q); while(!queue.isEmpty())&#123; int num = queue.size(); if(num % 2 != 0)&#123; return false; &#125; for(int i=0;i&lt;num/2;i++)&#123; p = queue.removeFirst(); q = queue.removeFirst(); if(p == null &amp;&amp; q == null)&#123; continue; &#125; else if(p == null || q == null || p.val != q.val)&#123; return false; &#125; queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; &#125; return true; &#125;&#125; 二叉树的最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 广度优先搜索BFS 12345678910111213141516171819202122232425class Solution &#123; public int maxDepth(TreeNode root) &#123; // 层序遍历求深度 Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null)&#123; return 0; &#125; queue.addLast(root); int count = 0; while(!queue.isEmpty())&#123; int num = queue.size(); for(int i=0;i&lt;num;i++)&#123; TreeNode node = queue.removeFirst(); if(node.left != null)&#123; queue.addLast(node.left); &#125; if(node.right != null)&#123; queue.addLast(node.right); &#125; &#125; count++; &#125; return count; &#125;&#125; 深度优先搜索DFS 如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为max(l,r)+1。而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用 深度优先搜索 的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 算出当前二叉树的最大深度。递归在访问到空节点时退出。 12345678910class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; &#125;&#125; 二叉树的最小深度给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 广度优先搜索BFS 当我们找到一个叶子节点时，直接返回这个叶子节点的深度，广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。 123456789101112131415161718192021222324252627class Solution &#123; public int minDepth(TreeNode root) &#123; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null)&#123; return 0; &#125; queue.addLast(root); int count = 0; while(!queue.isEmpty())&#123; int num = queue.size(); for(int i=0;i&lt;num;i++)&#123; TreeNode node = queue.removeFirst(); if(node.left == null &amp;&amp; node.right == null)&#123; return ++count; &#125; if(node.left != null)&#123; queue.addLast(node.left); &#125; if(node.right != null)&#123; queue.addLast(node.right); &#125; &#125; count++; &#125; return count; &#125;&#125; 深度优先搜索DFS 对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。 12345678910111213141516171819class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; // 终止条件是叶子节点 if(root.left == null &amp;&amp; root.right == null)&#123; return 1; &#125; int min = Integer.MAX_VALUE; if(root.left != null)&#123; min = Math.min(minDepth(root.left), min); &#125; if(root.right != null)&#123; min = Math.min(minDepth(root.right), min); &#125; return min + 1; &#125;&#125;","tags":[]},{"title":"Java集合","date":"2023-07-17T13:55:33.000Z","path":"2023/07/17/Java集合/","text":"复习一下Java的集合：分为单列集合和双列集合，单列集合有List和Set两类，双列集合是Map集合。List接口的实现类有ArrayList, LinkedList；Set和Map可以配合着学，主要有HashSet–HashMap, LinkedHashSet–LinkedHashMap, TreeSet–TreeMap三组。 Collection集合 总结一下Collection单列集合的常用功能有哪些，ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet集合都可以调用下面的方法： Collection集合的遍历方式： 迭代器遍历集合 当调用iterator()方法获取迭代器时，当前指向第一个元素； hasNext()方法则判断这个位置是否有元素，如果有则返回true，进入循环； 调用next()方法获取元素，并将当月元素指向下一个位置； 等下次循环时，则获取下一个元素，依此类推。 12345Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String context = it.next(); System.out.println(context);&#125; 增强for遍历集合 123for(String context: list)&#123; System.out.println(context);&#125; forEach遍历集合 12345678list.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125;&#125;);/* ======Lambda表达式简化======= */list.forEach(s -&gt; System.out.println(s)); 当往集合中存对象时，实际上存储的是对象的地址值： image-20230718122238215 List集合 List集合的常用方法： 因为List集合有索引，所以可以通过普通for循环的方式遍历List集合。 Arraylist集合ArrayList集合底层是基于数组结构实现的，也就是说当你往集合容器中存储元素时，底层本质上是往数组中存储元素。 特点如下： 我们知道数组的长度是固定的，但是集合的长度是可变的，这是怎么做到的呢？ 数组扩容，并不是在原数组上扩容（原数组是不可以扩容的），底层是创建一个新数组，然后把原数组中的元素全部复制到新数组中去。 LinkedListLinkedList底层是双向链表结构。 image-20230718123113316 所以相对于ArrayList新增了一些可以针对头尾进行操作的方法，如下图示所示： 由于双向链表的结构，可以用它来设计栈、队列： Set集合 HashSet集合 HashSet去重原理 前面我们学习了HashSet存储元素的原理，依赖于两个方法：一个是hashCode方法用来确定在底层数组中存储的位置，另一个是用equals方法判断新添加的元素是否和集合中已有的元素相同。 要想保证在HashSet集合中没有重复元素，我们需要重写对象类的hashCode和equals方法。比如以下面的User类为例，假设把User类的对象作为HashSet集合的元素： 123456HashSet&lt;User&gt; hs = new HashSet&lt;&gt;();User u1 = new User(&quot;ljc&quot;, &quot;123&quot;);User u2 = new User(&quot;ljc&quot;,&quot;123&quot;);hs.add(u1);hs.add(u2);System.out.println(hs); // [User&#123;username = ljc, password = 123&#125;, User&#123;username = ljc, password = 123&#125;] 我们发现结果和我们想象的不一样，HashSet不是可以去重吗？实际上，通常两个不同对象的HashCode值是不同的，导致元素挂在了不同的数组位置上。要解决这个问题要重写对象类的hashCode和equals方法——直接generate自动生成： 123456789101112@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return Objects.equals(username, user.username) &amp;&amp; Objects.equals(password, user.password);&#125;@Overridepublic int hashCode() &#123; return Objects.hash(username, password);&#125; LinkedHashSet集合LinkedHashSet类是HashSet的子类。LinkedHashSet它底层采用的是也是哈希表结构，只不过额外新增了一个双向链表来维护元素的存取顺序。 特点：相比HashSet，它记录了元素存入的顺序。 TreeSet集合TreeSet集合的特点是可以对元素进行排序（底层是红黑树实现的），但是必须指定元素的排序规则。如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。如果往TreeSet集合中存储自定义类型的元素，比如说User类型，则需要我们自己指定排序规则，否则会出现异常，原因是TreeSet不知道按照什么条件对自定义对象来排序： image-20230717225542069 我们想要告诉TreeSet集合按照指定的规则排序，有两种办法： 第一种：在创建TreeSet集合时，通过构造方法传递Compartor比较器对象； 第二种：让元素的类实现Comparable接口，重写compareTo方法； 第一种：创建集合时传递比较器对象 o1-o2是升序排序，o2-o1是降序排序。 Double类型用Double.compare(d1, d2)比较，String类型用s1.compareTo(s2)方法比较。 123456TreeSet&lt;User&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;User&gt;() &#123; @Override public int compare(User o1, User o2) &#123; return o1.getUsername().compareTo(o2.getUsername()); &#125;&#125;); 第二种：实体类实现Comparable接口，重写compareTo方法 this：表示将要添加进去的Student对象；o: 表示集合中已有的Student对象。 123456789public class User implements Comparable&lt;User&gt;&#123; private String username; private String password; /* ...... */ @Override public int compareTo(User o) &#123; return this.username.compareTo(o.username); // 升序 &#125;&#125; 自然排序Comparable是类在创建的时候就规定了类的比较的特性，而比较器Comparator是在具体的应用过程中我们根据需求创建一个工具类来完成比较，相比之下比较器的使用更加灵活（有的时候需要对同一对象进行多种不同方式的排序；或者按照特定的需求比较字符串但无法重写String类中的compareTo方法），不会改变这个类本身，降低了耦合度。 Collection集合总结 并发修改异常在使用迭代器遍历集合时，可能存在并发修改异常： 123456789101112131415161718List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;王麻子&quot;); list.add(&quot;小李子&quot;); list.add(&quot;李爱花&quot;); list.add(&quot;张全蛋&quot;); list.add(&quot;晓李&quot;); list.add(&quot;李玉刚&quot;); System.out.println(list); // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] //需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除 Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; String name = iterator.next(); if(name.contains(&quot;李&quot;))&#123; list.remove(name); &#125; &#125; System.out.println(list); image-20230718101929828 这是因为迭代器遍历机制，规定迭代器遍历集合的同时，不允许集合自己去增删元素。 增强for循环遍历方式，是在内部调用迭代器进行遍历，所以也会出现并发修改异常： 123456for(String name: list)&#123; if(name.contains(&quot;李&quot;))&#123; list.remove(name); &#125;&#125;System.out.println(list); 简单for循环遍历方式，不会出发迭代器的并发修改异常，但会造成结果出错： 1234567for(int i=0;i&lt;list.size();i++)&#123; String name = list.get(i); if(name.contains(&quot;李&quot;))&#123; list.remove(name); &#125;&#125;System.out.println(list); // [王麻子, 李爱花, 张全蛋, 李玉刚] [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]，以上述list集合为例，当i=1时remove了“小李子”元素，这时候i=1的元素变成了“李爱花”，而循环执行了i++，该元素就被跳过去了。解决方案是： 123456789for(int i=0;i&lt;list.size();i++)&#123; String name = list.get(i); if(name.contains(&quot;李&quot;))&#123; list.remove(name); i--; // 因为普通for循环没有异常出现，所以在逻辑上将每次remove元素后的索引i--即可 &#125; &#125; System.out.println(list);&#125; 而迭代器遍历解决并发修改异常的方法是，使用迭代器的修改元素方法： 12345678Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String name = it.next(); if(name.contains(&quot;李&quot;))&#123; it.remove(); // 当前迭代器指向谁，就删除谁 &#125;&#125;System.out.println(list); Collections工具类可变参数 可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。 可变参数在方法内部，本质上是一个数组。 12345678910public static void main(String[] args) &#123; test(); test(1); test(1,2,3); int[] arr = new int[]&#123;1,2,3,4&#125;; test(arr);&#125;public static void test(int...nums)&#123; System.out.println(Arrays.toString(nums));&#125; 一个形参列表中，只能有一个可变参数；否则会报错。 形参列表中如果多个参数，可变参数需要写在最后；否则会报错。 Collections工具类 image-20230718105406211 往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储实体类对象，这个时候想要对List集合进行排序自定义比较规则的。 123456Collections.sort(list, new Comparator&lt;User&gt;() &#123; @Override public int compare(User o1, User o2) &#123; return o1.getPassword().compareTo(o2.getPassword()); &#125;&#125;); Map集合双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以key=value的形式存在的，一个key=value就称之为一个键值对，而且在 Java 中有一个类叫Entry类，Entry的对象用来表示键值对对象。 Map集合有如下的特点：键不能重复，值可以重复，每一个键只能找到自己对应的值。 Map集合常用方法 Map集合遍历方法 方式一 123456789101112Map&lt;String, Double&gt; map = new HashMap&lt;&gt;();map.put(&quot;蜘蛛精&quot;, 162.5);map.put(&quot;蜘蛛精&quot;, 169.8);map.put(&quot;紫霞&quot;, 165.8);map.put(&quot;至尊宝&quot;, 169.5);map.put(&quot;牛魔王&quot;, 183.6); Set&lt;String&gt; keys = map.keySet();for(String key: keys)&#123; Double value = map.get(key); System.out.println(key + &quot;---&gt;&quot; + value);&#125; 方式二 Map集合是用来存储键值对的，而每一个键值对实际上是一个Entry对象。可以直接获取每一个Entry对象，把Entry存储扫Set集合中去，再通过Entry对象获取键和值。 Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合： 123456Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();for (Map.Entry&lt;String, Double&gt; entry: entries)&#123; String key = entry.getKey(); Double value = entry.getValue(); System.out.println(key + &quot;---&gt;&quot; + value);&#125; 方式三 123456map.forEach(new BiConsumer&lt;String, Double&gt;() &#123; @Override public void accept(String k, Double v) &#123; System.out.println(k + &quot;---&gt;&quot; + v); &#125;&#125;); HashMapHashMap集合的特点是由键决定的： 它的键是无序、不能重复，而且没有索引的。在各种Map集合中也是用得最多的一种集合。 HashMap底层原理和HashSet是一样的。因为我们往HashSet集合中添加元素时，实际上是把元素作为key添加到了HashMap集合中。 image-20230718114026273 HashMap和HashSet是一样的，底层是哈希表结构，哈希表是一种增删改查性能相对都较好的数据结构。 往HashMap集合中键值对数据时，底层步骤如下： 第1步：当你第一次往HashMap集合中存储键值对时，底层会创建一个长度为16的数组； 第2步：把键然后将键和值封装成一个对象，叫做Entry对象； 第3步：再根据Entry对象的键计算hashCode值（和值无关）； 第4步：利用hashCode值和数组的长度做一个类似求余数的算法，会得到一个索引位置； 第5步：判断这个索引的位置是否为null：如果为null，就直接将这个Entry对象存储到这个索引位置；如果不为null，则还需要进行第6步的判断； 第6步：继续调用equals方法判断两个对象键是否相同：如果equals返回false，则以链表的形式往下挂；如果equals方法true，则认为键重复，此时新的键值对会替换就的键值对。 HashMap底层需要注意这几点： 底层数组默认长度为16，如果数组中有超过12个位置已经存储了元素，则会对数组进行扩容2倍。数组扩容的加载因子是 0.75 ，意思是：16*0.75=12； 数组的同一个索引位置有多个元素、并且在8个元素以内（包括8），则以链表的形式存储（JDK8以后版本链表采用尾插法）。 数组的同一个索引位置有多个元素、并且超过了8个，则以红黑树形式存储。 决定键是否重复与两个方法有关，一个是hashCode方法、一个是equals方法。有两个键计算得到的hashCode值相同，并且两个键使用equals比较为true，就认为键重复。所以，往Map集合中存储自定义对象作为键，为了保证键的唯一性，我们应该重写这两个方法。 LinkedHashMapLinkedHashMap集合的特点也是由键决定的：有序的、不重复、无索引。这里的“有序”是只存入的顺序。LinkedHashMap的底层原理，和LinkedHashSet底层原理是一样的，底层多个一个双向链表来维护键的存储顺序。 TreeMapTreeMap集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。TreeMap集合的底层原理和TreeSet也是一样的，底层都是红黑树实现的，所以可以对键进行排序。","tags":[]},{"title":"Java的深浅拷贝","date":"2023-07-14T14:33:27.000Z","path":"2023/07/14/Java的深浅拷贝/","text":"今天在刷算法题的时候忘记了引用数据类型深浅拷贝的问题，正好借此机会来复习一下。 拷贝的分类 引用拷贝 没有创建新的内存空间，只是复制了一个引用变量指向了堆空间中相同的地址。 对象拷贝 创建对象的一个副本，创建了新的对象指向不同的地址空间。而深浅拷贝的区别在于对象里面的属性拷贝方式。 浅拷贝 属性就是引用拷贝，指向同一地址。 深拷贝 属性也是对象拷贝，不是同一地址。 引用拷贝1234Teacher teacher = new Teacher(&quot;riemann&quot;, 28);Teacher otherTeacher = teacher; // 没有创建新的对象System.out.println(teacher);System.out.println(otherTeacher); 它们的地址值是相同的，teacher和otherTeacher只是引用而已，他们都指向了一个相同的对象Teacher(“riemann”,28)。 对象拷贝1234Teacher teacher = new Teacher(&quot;riemann&quot;, 28); Teacher otherTeacher = (Teacher) teacher.clone(); System.out.println(teacher); System.out.println(otherTeacher); 它们的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量，这就叫做对象拷贝。 由于age是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。但是name是String类型的， 它只是一个引用， 指向一个真正的String对象，那么对它的拷贝有两种方式将对象拷贝分为了浅拷贝和深拷贝。 直接将源对象中的name的引用值拷贝给新对象的name字段； 根据原Person对象中的name指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的Person对象的name字段。 Student类和Teacher类的pojo结构是这样的： ​ 浅拷贝被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。 image-20230714220049094 无论是String对象还是pojo对象，它们都是引用数据类型： 1Student student2 = (Student) student1.clone(); 由于Object类本身没有实现Cloneable接口，所以要使用clone方法必须在pojo类上实现该接口。 两个引用student1和student2指向不同的两个对象，但是两个引用student1和student2中的teacher引用指向的是同一个对象，所以说明是浅拷贝。 Cloneable接口中的clone()方法是浅拷贝的： 1234public Object clone() throws CloneNotSupportedException &#123; Object object = super.clone(); return object;&#125; 深拷贝深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。 image-20230714221034487 无论是String对象还是pojo对象，它们都是引用数据类型： 1Student student2 = (Student) student1.clone(); 两个引用student1和student2指向不同的两个对象，两个引用student1和student2中的两个teacher引用指向的是两个对象。对student1中的teacher属性的修改只能影响student1对象，所以说是深拷贝。 123456public Object clone() throws CloneNotSupportedException &#123; // 深拷贝时： Student student = (Student) super.clone(); student.setTeacher((Teacher)student.getTeacher().clone()); return student;&#125; String讲到对象的拷贝，突然想到字符串，字符串也是一种引用数据类型，这在初学中是容易被忽视掉的。 String字符串的基本特性 String声明为final的，不可被继承、不可变特性； String实现了Serializable接口：表示字符串是支持序列化的；实现了Comparable接口：表示String可以比较大小； String在jdk8及以前内部定义了final char [] value用于存储字符串数据，jdk9时改为byte[]； 字符串连接池 为了减少在jvm中创建的字符串的数量，虚拟机维护了一个字符串常量池。当创建String对象时，jvm会先检查字符串常量池，如果这个字符串的常量值已经存在在池中了，就直接返回池中对象的引用，如果不在池中，就会实例化一个字符串并放入池中。 String不可变性Java 中的 String 真的是不可变的吗？ 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 12345String str = &quot;Python&quot;;System.out.println(str); // Pythonstr = &quot;Java&quot;;System.out.println(str); // Java 123456String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;System.out.println(str1 == str2); // truestr2 = &quot;ABC&quot;; // 相当于new String(&quot;ABC&quot;)，交给str2的引用System.out.println(str1 + &quot;----------&quot; + str2); // str1=&quot;abc&quot;, str2=&quot;ABC&quot; 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 12345String s1 = &quot;a&quot;;String s2 = &quot;b&quot;;String s3 = &quot;ab&quot;;String s4 = s1 + s2; // 在底层是StringBuilder.toString而来的，相当于new String(s1+s2);System.out.println(s3 == s4); //false 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 ​","tags":[]},{"title":"Linux入门","date":"2023-07-08T08:55:37.000Z","path":"2023/07/08/Linux入门/","text":"Linux的常见命令和Linux中安装jdk、mysql等。 Linux基础命令文件目录操作命令 ls -a -l cd ~：表示用户的home目录 .：表示当前所在目录 ..：表示目前目录位置的上级目录 cat -n：显示行号 more：分页的形式显示文件内容 回车键：向下滚动一行 空格键：向下滚动一屏 b：返回上一屏 q或者Ctrl+C：退出more tail：查看文件末尾的内容 -f：动态读取文件末尾内容并显示，常用于日志文件的内容输出 mkdir：创建目录 -p：可以实现多级目录的同时创建（mkdir 1/2/3） rmdir：删除空目录 拷贝移动命令 cp：用来复制文件或目录（cp [-r] source dest） -r：复制该目录下的所有子目录和文件 mv：为文件或目录改名，或移动到其他位置（mv source dest） 打包压缩命令 tar：对文件进行打包、解包、压缩、解压 包文件后缀名.tar，表示只是完成了打包，并没有压缩；包文件后缀名.tar.gz表示打包的同时还进行了压缩。 -z：代表是gzip，gzip可以对文件压缩或解压； -c：代表是create，创建新的包文件； -x：代表是extract，实现从包文件中还原文件； -v：代表是verbose，显示命令的执行操作； -f：代表是file，用于指定包文件的名称。 1234tar -cvf fileName # 打包tar文件tar -xvf fileName # 解包tar文件tar -zcvf fileName # 打包并压缩tar.gz文件tar -zxvf fileName # 打包并解压tar.gz文件 文本编辑命令 vi/vim vim安装：yum install yum 命令模式 G gg 插入模式 底行模式： wq q! set nu：显示行号 查找命令 find：在指定目录下查找文件 1find dirName -name fileName grep：从指定文件查找指定文本内容 1grep word fileName 远程服务器上传下载 本地向服务器上传 12scp /localpath/filename（本地目录文件） username@IP_Address:/remotepath（远程目录）scp -r /localpath（本地目录） username@IP_Address:/remotepath（远程目录） 本地从服务器下载 12scp username@IP_Address:/remotepath/filename（远程目录文件） /localpath（本地目录）scp -r username@IP_Address:/remotepath（远程目录） /localpath（本地目录） 远程服务器设置固定的ip地址：https://www.cnblogs.com/itbsl/p/10998696.html 安装Linux中安装jdk建议安装jdk8，jdk17亲测在CentOS中和tomcat不兼容，tomcat安装时无法识别jdk17（我看网上的博主在23年还在linux中使用jdk8的版本，可能CentOS7真的和jdk17有一些兼容上的问题）。 下载jdk8地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 其中别忘记环境变量的配置： 使用vim修改/etc/profile文件，在文件末尾加入配置： 12JAVA_HOME=/usr/local/jdk1.8.0_371PATH=$JAVA_HOME/bin:$PATH 重新加载profile文件，使得配置立即生效 1source /etc/profile 检查jdk是否安装成功： 1java -version Linux中安装Tomcat我使用的是Tomcat9版本。 在Tomcat的/bin目录下启动tomcat服务： 1sh startup.sh 或者 ./startup.sh 查看进程检查是否启动成功： 1ps -ef | grep tomcat 通过客户机浏览器可以试着访问服务器的8080端口： 如果无法访问大概率是防火墙关闭了服务器的8080端口，尝试开放8080端口后尝试： 1234firewall-cmd --zone=public --add-port=8080/tcp --permanent # 开放指定端口firewall-cmd --zone=public --remove-port=8080/tcp --permanent # 开放指定端口firewall-cmd --reload # 立即生效配置filewall-cmd --zone=public --list-ports # 查看开放的端口 停止Tomcat服务： 1234# 方法一./shutdown.sh# 方法二kill -9 进程id Linux中安装MySQLCentOS7中自带的 Mariadb 和 MySQL 有冲突，先将其卸载： 123rpm -qa|grep mariadbsudo rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 # mariadb-libs-5.5.68-1.el7.x86_64是上面命令显示的sudo rm /etc/my.cnf 检查MySQL是否存在，如果存在也卸载重新安装： 1rpm -qa | grep mysql 下载MySQL地址：https://downloads.mysql.com/archives/community/?spm=a2c6h.12873639.article-detail.5.51fa3861DJz2jH image-20230708173316683 将mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar上传至服务器： 1scp /localpath/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar username@IP_Address:/remotepath/mysql 将tar解压到指定目录： 1sudo tar -xvf /home/ljc/mysql/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar -C /usr/local/mysql image-20230708174332889 不考虑依赖关系的强制安装命令： 1rpm -ivh *.rpm --nodeps --force image-20230708175727311 安装成功后，启动MySQL服务： 1systemctl start mysqld 进入MySQL： 1mysql -u root -p MySQL的默认临时密码在安装时的日志文件中，复制过来登录： 1sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log image-20230708175930124 降低密码的校验等级和校验规则： 12set global validate_password.policy=0;set global validate_password.length=8; 重新设置MySQL密码： 1alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;password&#x27;; localhost只能用户本机127.0.0.1访问，创建一个新root用户用于远程登录访问： 1create user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;12345678&#x27;; 给新root用户分配权限： 1grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;; 在NaviCat上远程连接服务器上的MySQL： 这里如果连接失败是CentOS防火墙没有开启3306端口，建议关闭防火墙。 1systemctl status firewalld.service image-20230708181402460 关闭防火墙： 12systemctl stop firewalld.servicesystemctl status firewalld.service image-20230708181459858 永久关闭防火墙： 1systemctl disable firewalld.service","tags":[]},{"title":"01-MySQL基础","date":"2023-07-07T09:48:37.000Z","path":"2023/07/07/01-MySQL基础/","text":"Mysql是一种关系型数据库，这篇博客作为数据库的基础篇主要讲解操作关系型数据的SQL编程语言。 数据库相关概念数据库 image-20230708120214301 数据模型数据模型是数据库中数据的存储方式，是数据库系统的基础。 SQL语言DDL 数据定义语言 数据库操作 12345show databases;create database 数据库名;use 数据库名;select database();drop database 数据库名; 表操作 123456show tables;create table 表名 (字段 字段类型, 字段 字段类型...);desc 表名;show create table 表名;alter table 表名 add / modify / change / drop / rename to ...;drop table 表名; 创建数据表时要指定字段的数据类型，SQL的数据类型是很重要的知识点： 数值类型 字符串类型 varchar类型会先计算数据所占用的存储空间，所以性能相对char会差一些。varchar用来存储变长字符串，char用来存储定长字符串。 日期时间类型 DML 数据操作语言 添加数据 1insert into 表名 (字段1, 字段2, ...) values (值1, 值2, ...)[, (值1, 值2, ...),...]; 修改数据 1update 表名 set 字段1 = 值1, 字段2 = 值2... [where 条件]; 删除数据 1delete from 表名 [where 条件]; DQL 数据查询语言1select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后条件列表 order by 排序字段列表 limit 分页参数 基本查询 123select * from 表名;select 字段1 [as 别名], 字段2 [as 别名]... from 表名;select distinct 字段列表 from 表名; 条件查询 1select * from 表名 where 条件; image-20230707182551496 聚合函数 将一列数据作为一个整体，进行纵向计算。 null值不参与所有聚合函数运算。 1select 聚合函数(字段列表) from 表名; 分组查询 1select 字段名 from 表名 [where 条件] group by 分组字段名 [having 分组过滤后的条件]; where 与 having 的区别： ① 执行时机不同：where 是分组之前进行过滤，不满足 where 条件是不参与 group by 分组的；而 having 是分组之后的条件对结果进行过滤； ② 判断条件不同：where 是不能对聚合函数进行判断，而 having 可以。 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询 1select 字段名 from 表名 order by 字段1 排序方式1, order by 字段1 排序方式1 ...; ASC：升序（默认值） DESC：降序 分页查询 1select 字段名 from 表名 limit 起始索引, 查询记录数; 起始索引从0开始，起始索引 = (查询页码 - 1) * 每页显示记录数； 分页查询是数据库的“方言”； 如果查询的是第一页的数据，起始索引可以省略，直接简写为limit 10。 DQL语句执行顺序 可以通过起别名的方式验证sql的执行顺序。 DCL 数据控制语言用来管理数据库用户，控制数据库的访问权限等。这类 SQL 开发人员操作较少，主要是 DBA 数据库管理员使用。 管理用户 查询用户 12use mysql;select * from user; 创建用户 1create user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified by &#x27;密码&#x27;; 修改用户密码 1alter user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;; 删除用户 1drop user &#x27;用户名&#x27;@&#x27;主机名&#x27;; 权限控制 查询权限 1show grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;; 授予权限 1grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;; 撤销权限 1revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;; 函数字符串函数 数值函数 image-20230707213014115 练习：通过数据库内置函数，生成6位验证码： 1select lpad(round(rand()*1000000, 0), 6, &#x27;0&#x27;); 日期函数 流程函数在sql语句中实现条件筛选，提高语句的效率。 约束约束是作用于表中字段的规则，用于限制存储在表中的数据，可以在创建表或修改表的时候添加约束。目的是保证数据库中数据的正确、有效性和完整性。 约束分类 自增：auto_increment . 当插入一条数据失败时，这时候这条未插入的数据已经向数据库申请了自增的字段值。 外键约束外键是用来让两张表的数据相互建立连接，从而保证数据的一致性和完整性的。 下面的两张表，仅存在逻辑上的关系，在数据库层面并未建立外键关联，所以是无法保证数据的一致性和完整性的。 image-20230707220102885 添加外键： 1alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名); 删除外键： 1alter table 表名 drop foreign key 外键名称; 删除/更新行为： 1alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名) on update 行为 on delete 行为; 多表查询多表关系 一对多 一个部门对应多个员工，一个员工对应一个部门。在多的一方建立外键，指向一的一方的主键。 多对多 一个学生可以选修多门课程，一门课程可以被多个学生选择。建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。 一对一 用户与用户详情的关系。多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率。在任意一方加入外键，关联另一方的主键，并且设置外键是唯一的(UNIQUE) – 保证一对一。 多表查询内连接查询的是两张表交集的部分。 隐式内连接 1select 字段列表 from 表1, 表2 where 条件...; 显式内连接 1select 字段列表 from 表1 [inner] join 表2 on 连接条件...; 外连接 左外连接：相当于查询表1（左表）的所有数据（包含表1和表2交集部分） 1select 字段列表 from 表1 left [outer] join 表2 on 条件...; 右外连接：相当于查询表2（右表）的所有数据（包含表1和表2交集部分） 1select 字段列表 from 表1 right [outer] join 表2 on 条件...; 自连接可以是内连接查询，也可以是外连接查询。 1select 字段列表 from 表A 别名A join 表A 别名B on 条件...; 联合查询把多次查询的结果合并起来，形成一个新的查询结果集 1select 字段列表 from 表A union [all] select 字段列表 from 表B; 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致；union是将结果合并后去重，union all是只将结果合并。 子查询（嵌套查询）1select * from t1 where column1 = (select column1 from t2); 根据子查询的结果不同分为：标量子查询、列子查询、行子查询、表子查询。 标量子查询：&gt;, &lt;, =… 列子查询：in, all, any… 行子查询：in, not in, =, &lt;&gt; 表子查询：in 事务事务是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功、要么同时失败。保证数据的正确性和完整性。 默认MySQL的事务是自动提交的，也就是说当执行一条DML语句后，MySQL会立即隐式的提交事务。（开启事务 → 提交/回滚事务） 事务操作 方式一 查看/设置事务提交方式： 12select @@autocommit;set @@autocommit = 0; 提交事务 1commit; 回滚事务 1rollback; 方式二 开启事务后，必须手动commit提交事务（否则数据是不会在表中变化的），或者rollback回滚事务，才能结束这个事务。一旦事务提交，则其所做的修改就会永久保存到数据库中。 开启事务 1start transaction 或 begin; 提交事务 回滚事务 事务四大特性（面试题） image-20230708112047747 并发事务问题 脏读 一个事务读到另一个事务还没有提交的数据。 Question：在事务没提交前更改的数据信息，保存在数据库的什么位置？ 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了。 事务的隔离级别事务的隔离级别是为了解决并发事务问题。设计数据库时需要衡量数据库的安全级别和并发性能。","tags":[]},{"title":"MybatisPlus","date":"2023-07-07T02:19:57.000Z","path":"2023/07/07/MybatisPlus/","text":"MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。使用原生的Mybatis编写持久层逻辑时，所需要的代码是比较繁琐的，需要定义Mapper接口和Mapper.xml文件，每一个方法都需要编写对应的sql语句，会存在很多大量的重复工作，使用MP之后，对通用的方法做了高度的抽取，避免了很多重复工作，可以非常快速的实现了单表的各种增、删、改、查操作。 博客主要讲解Springboot项目下的MybatisPlus框架的核心功能，详细的可参考MP的中文开发文档。 入门配置 创建Springboot工程（在IDEA中集成功能） 引入 Spring Boot Starter 父工程： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/parent&gt; 引入 spring-boot-starter、spring-boot-starter-test依赖： 12345678910111213141516 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- web工程也要导入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 引入mybatis-plus-boot-starter依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt;&lt;/dependency&gt; 引入数据库依赖（在IDEA中集成功能） 123456789101112&lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; &lt;!-- 可选 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt;&lt;/dependency&gt; 快速入门常用注解 @TableName：表名注解，标识实体类对应的表 1234567@TableName(&quot;sys_user&quot;)public class User &#123; private Long id; private String name; private Integer age; private String email;&#125; @TableId：主键注释，标识实体类主键字段 12345678@TableName(&quot;sys_user&quot;)public class User &#123; @TableId private Long id; private String name; private Integer age; private String email;&#125; 属性 类型 必须指定 默认值 描述 value String 否 “” 主键字段名 type Enum 否 IdType.NONE 指定主键类型 IdType的属性 值 描述 AUTO 数据库 ID 自增 NONE 无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT） INPUT insert 前自行 set 主键值 ASSIGN_ID 分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) ASSIGN_UUID 分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法) @TableField：字段注解（非主键） 123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId private Long id; @TableField(&quot;nickname&quot;) private String name; private Integer age; private String email;&#125; value：数据库字段名 fill：字段自动填充策略 值 描述 DEFAULT 默认不处理 INSERT 插入时填充字段 UPDATE 更新时填充字段 INSERT_UPDATE 插入和更新时填充字段 核心功能CRUD 接口Service CRUD 接口通用 Service CRUD 封装 IService 接口，进一步封装 CRUD 采用 get 查询单行 ，remove 删除， list 查询集合 ，page 分页 前缀命名方式区分 Mapper 层避免混淆。 Save 123456// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize); // batchSize:插入批次数量 SaveOrUpdate 12345678// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize); Remove 12345678// 根据 queryWrapper 设置的条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id); // 主键ID// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList); // idList:主键ID列表 Update 12345678910// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize); Get 12345678// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper); List 12345678910111213141516// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper); Page 12345678// 无条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);// 无条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper); Count 1234// 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper); Mapper CRUD 接口通用 CRUD 封装 BaseMapper 接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器。 Insert 12// 插入一条记录int insert(T entity); Delete 12345678// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); Update 1234// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改int updateById(@Param(Constants.ENTITY) T entity); Select 12345678910111213141516171819202122// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 条件构造器AbstractWrapper是QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类，用于生成 sql 的 where 条件。 以下方法在入参中出现的R为泛型，在普通wrapper中是String，在LambdaWrapper中是函数(例:Entity::getId，Entity为实体类，getId为字段id的getter Method)。 allEq：全部eq（或个别isNull） 123allEq(Map&lt;R, V&gt; params)allEq(Map&lt;R, V&gt; params, boolean null2IsNull)allEq(boolean condition, Map&lt;R, V&gt; params, boolean null2IsNull) params : key为数据库字段名，value为字段值null2IsNull : 为true则在map的value为null时调用isNull方法，为false时则忽略value为null的值 例1: allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;)—&gt;id = 1 and name = &#39;老王&#39; and age is null 例2: allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;, false)—&gt;id = 1 and name = &#39;老王&#39; eq：等于 = 12eq(R column, Object val)eq(boolean condition, R column, Object val) ne：不等于 &lt;&gt; (或 !=) gt：大于 &gt; ge：大于等于 &gt;= lt：小于 &lt; le：小于等于 &lt;= between：BETWEEN 值1 AND 值2 123between(R column, Object val1, Object val2)between(boolean condition, R column, Object val1, Object val2)// between(&quot;age&quot;, 18, 30)---&gt;age between 18 and 30 notBetween：NOT BETWEEN 值1 AND 值2 like notLike likeLeft likeRight isNull 12isNull(R column)isNull(boolean condition, R column) isNotNull in 12in(R column, Collection&lt;?&gt; value)in(boolean condition, R column, Collection&lt;?&gt; value) groupBy 123groupBy(R... columns)groupBy(boolean condition, R... columns)// groupBy(&quot;id&quot;, &quot;name&quot;)---&gt;group by id,name orderByAsc：升序排序 12orderByAsc(R... columns)orderByAsc(boolean condition, R... columns) orderByDesc：升序排序 or：主动调用or表示紧接着下一个方法不是用and连接!(不调用or则默认为使用and连接) 123or(Consumer&lt;Param&gt; consumer)or(boolean condition, Consumer&lt;Param&gt; consumer)// eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)---&gt;id = 1 or name = &#x27;老王&#x27; 不是全部，条件构造器API：https://baomidou.com/pages/10c804/#querywrapper。 QueryWrapper或者LambdaQueryWrapper，继承自 AbstractWrapper 。 select：设置查询字段 1234select(String... sqlSelect)select(Predicate&lt;TableFieldInfo&gt; predicate)select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)// select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;) UpdateWrapper或者LambdaUpdateWrapper，也继承自 AbstractWrapper。 set 123set(String column, Object val)set(boolean condition, String column, Object val)// set(&quot;name&quot;, &quot;老李头&quot;) setSql：设置 SET 部分 SQL 12setSql(String sql) // setSql(&quot;name = &#x27;老李头&#x27;&quot;) lambda：获取 LambdaWrapper，在QueryWrapper中是获取LambdaQueryWrapper在UpdateWrapper中是获取LambdaUpdateWrapper。 代码生成器安装 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt;&lt;/dependency&gt; 使用 https://baomidou.com/pages/779a6e/#%E4%BD%BF%E7%94%A8","tags":[]},{"title":"瑞吉外卖项目实战day2","date":"2023-07-06T02:23:12.000Z","path":"2023/07/06/瑞吉外卖项目实战day2/","text":"适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。 后面我逐渐省略了一些功能的记录，主要是因为和前面的业务万变不离其宗，如果要看详细的代码可以到我的github仓库下拉reggie代码。 业务实现（后台系统）新增套餐数据模型 image-20230706103537857 表现层要素 image-20230706103038582 请求类型：POST 请求路径：/setmeal image-20230706103143613 请求参数：json格式的数据，除了setmeal套餐的基本信息外，还有套餐内的菜品信息setmealDishes也封装成json数组的格式。（还有idType和dishList是什么，当请求参数json数据key大于dto对象的时候，可以正常封装吗？） 12345678910111213141516171819202122232425262728addSetmeal(prams) .then((res) =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;套餐添加成功！&#x27;) if (!st) &#123; this.goBack() &#125; else &#123; this.$refs.ruleForm.resetFields() this.dishList = [] this.dishTable = [] this.ruleForm = &#123; name: &#x27;&#x27;, categoryId: &#x27;&#x27;, price: &#x27;&#x27;, code: &#x27;&#x27;, image: &#x27;&#x27;, description: &#x27;&#x27;, dishList: [], status: true, id: &#x27;&#x27;, idType: &#x27;&#x27;, &#125; this.imageUrl = &#x27;&#x27; &#125; &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;) 返回值类型：Result&lt;String&gt;类型 核心业务思路 仍然是操作setmeal数据表和setmeal_dish数据表，要在Service类上加事务管理注释@Transactional。 步骤1：在Service类自定义新增套餐的业务层方法，并在类上加事务管理注释@Transactional； 步骤2：调用Service层原生的save方法将SetmealDto对象传入并保存； 步骤3：接下来要对setmeal_dish数据表进行添加多条数据，可以从dto对象中get到setmealDishes这个属性列表，但是不能直接将setmealDishes列表saveBatch，要对其赋值setmeal_id值； 步骤4：通过dto对象get到id值（执行了save操作，在setmeal表已经通过雪花算法为dto对象生成了id属性值），将其赋给setmealDishes列表的setmealDish.setmealId套餐id值； 步骤5：调用Service层的saveBatch将setmealDishes列表添加到setmeal_dish数据表中。 套餐信息分页查询表现层要素 image-20230706111444821 请求类型：GET 请求路径：/setmeal/page 请求参数：普通参数page、pageSize和可选参数name 返回值类型：Result&lt;Page&gt; 核心业务思路 跟前面的菜品信息分页查询一模一样。 删除套餐表现层要素 image-20230706113845252 请求类型：DELETE 请求路径：/setmeal 请求参数：普通参数ids，因为批量删除的id可能有多个，所以这里的方法形参是List&lt;Long&gt; ids，要加@RequestParam注解 12345678deleteSetmeal(type === &#x27;批量&#x27; ? this.checkList.join(&#x27;,&#x27;) : id).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;删除成功！&#x27;) this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 返回值类型：Result&lt;String&gt; 核心业务思路 首先操作setmeal表删除套餐信息，再操作setmeal_dish表删除setmeal_id字段 = ids的所有数据。 批量起售停售 image-20230706163258312 12345678@PostMapping(&quot;/status/&#123;status&#125;&quot;) public Result&lt;String&gt; changeStatus(@PathVariable Integer status, @RequestParam List&lt;Long&gt; ids)&#123; LambdaUpdateWrapper&lt;Setmeal&gt; lambdaUpdateWrapper = new LambdaUpdateWrapper&lt;&gt;(); lambdaUpdateWrapper.in(Setmeal::getId, ids); lambdaUpdateWrapper.set(Setmeal::getStatus, status); setmealService.update(lambdaUpdateWrapper); return Result.success(&quot;状态修改成功&quot;); &#125; 订单明细分页查询跟前面的分页查询相比就是可选参数变多了，还有就是关注一下“时间”作为可选参数如何处理。 image-20230706203744254 可选参数： image-20230706203823723 12345678910111213@GetMapping(&quot;/page&quot;)public Result&lt;Page&gt; pageSelect(int page, int pageSize, String number,String beginTime, String endTime)&#123; Page&lt;Orders&gt; pageInfo = new Page&lt;&gt;(page ,pageSize); LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.like(StringUtils.hasText(number), Orders::getNumber, number); lambdaQueryWrapper.gt(StringUtils.hasText(beginTime), Orders::getOrderTime, beginTime) .lt(StringUtils.hasText(endTime), Orders::getOrderTime, endTime); lambdaQueryWrapper.orderByDesc(Orders::getOrderTime); orderService.page(pageInfo, lambdaQueryWrapper); return Result.success(pageInfo);&#125; 业务实现（移动端系统）手机验证码登录流程分析 点击获取验证码，页面向服务端发送第一次请求，请求服务器随机生成要求的验证码并发送到表单输出的手机号中； 点击登录，页面向服务端发送第二次请求，携带表单输入的验证码和Session中储存的验证码进行比对，确定是否成功登录。 核心业务思路 发送验证码请求 导入手机验证的依赖坐标： 1234567891011&lt;!-- 阿里云短信服务 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.6.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 编写一个工具类（根据阿里云短信服务的帮助文档改的），用于发送手机验证码： 123456789101112131415161718192021222324252627282930/** * 短信发送工具类 */public class SMSUtils &#123; /** * 发送短信 * @param signName 签名 * @param templateCode 模板 * @param phoneNumbers 手机号 * @param param 参数 */ public static void sendMessage(String signName, String templateCode,String phoneNumbers,String param)&#123; DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, &quot;&quot;, &quot;&quot;); // accessKeyId, secret IAcsClient client = new DefaultAcsClient(profile); SendSmsRequest request = new SendSmsRequest(); request.setSysRegionId(&quot;cn-hangzhou&quot;); request.setPhoneNumbers(phoneNumbers); request.setSignName(signName); request.setTemplateCode(templateCode); request.setTemplateParam(&quot;&#123;\\&quot;code\\&quot;:\\&quot;&quot;+param+&quot;\\&quot;&#125;&quot;); try &#123; SendSmsResponse response = client.getAcsResponse(request); System.out.println(&quot;短信发送成功&quot;); &#125;catch (ClientException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 随机生成随机验证码的工具类： 123456789101112131415161718192021222324252627282930313233343536373839/** * 随机生成验证码工具类 */public class ValidateCodeUtils &#123; /** * 随机生成验证码 * @param length 长度为4位或者6位 * @return */ public static Integer generateValidateCode(int length)&#123; Integer code =null; if(length == 4)&#123; code = new Random().nextInt(9999);//生成随机数，最大为9999 if(code &lt; 1000)&#123; code = code + 1000;//保证随机数为4位数字 &#125; &#125;else if(length == 6)&#123; code = new Random().nextInt(999999);//生成随机数，最大为999999 if(code &lt; 100000)&#123; code = code + 100000;//保证随机数为6位数字 &#125; &#125;else&#123; throw new RuntimeException(&quot;只能生成4位或6位数字验证码&quot;); &#125; return code; &#125; /** * 随机生成指定长度字符串验证码 * @param length 长度 * @return */ public static String generateValidateCode4String(int length)&#123; Random rdm = new Random(); String hash1 = Integer.toHexString(rdm.nextInt()); String capstr = hash1.substring(0, length); return capstr; &#125;&#125; 修改拦截器，对客户端登录相关的请求进行放行： 1234567891011// 定义不需要处理的请求路径String[] urls = &#123; &quot;/employee/login&quot;, &quot;/employee/logout&quot;, &quot;/backend/**&quot;, &quot;/front/**&quot;, &quot;/&quot;, &quot;/common/**&quot;, &quot;/user/sendMsg&quot;, // 移动端发送短信 &quot;/user/login&quot; // 移动端登录&#125;; 表现层方法： 12345678910111213141516171819@PostMapping(&quot;/sendMsg&quot;) public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session)&#123; // 获取手机号 String phone = user.getPhone(); if(StringUtils.hasText(phone))&#123; // 生成随机的4位验证码 String code = ValidateCodeUtils.generateValidateCode(4).toString(); log.info(&quot;code -&gt; &#123;&#125;&quot;, code); // 调用阿里云提供的短信服务API完成短信发送 SMSUtils.sendMessage(&quot;瑞吉外卖&quot;, &quot;您的验证码为：$&#123;code&#125;，请勿泄露于他人！&quot;, phone, code); // 需要将生成的验证码保存到Session中 session.setAttribute(phone, code); return Result.success(&quot;手机短信验证码发送成功&quot;); &#125; return Result.error(&quot;手机短信验证码发送失败&quot;); &#125; 登录请求 image-20230706171041816 请求参数是json格式的code和phone，phone是User实体类的属性，但是验证码code不是。有两种解决方案：① 定义增强类UserDto； ② 用Map的key-value接收参数。 1234567891011121314151617181920212223242526272829303132@PostMapping(&quot;/login&quot;)public Result&lt;User&gt; login(@RequestBody Map userMap, HttpSession session)&#123; log.info(userMap.toString()); // 获取手机号 String phone = userMap.get(&quot;phone&quot;).toString(); // 获取验证码 String code = userMap.get(&quot;code&quot;).toString(); // 从session中获取保存的验证码 String codeInSession = session.getAttribute(phone).toString(); // 进行验证码的比对（页面提交的验证码和Session中保存的验证码做比对） if(codeInSession != null &amp;&amp; codeInSession.equals(code))&#123; // 如果能够比对成功，说明登录成功 // 判断当前手机号对应的用户是否为新用户 LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(User::getPhone, phone); User user = userService.getOne(lambdaQueryWrapper); if(user == null)&#123; // 如果是新用户则自动注册 user = new User(); user.setPhone(phone); userService.save(user); &#125; session.setAttribute(&quot;user&quot;, user.getId()); return Result.success(user); &#125; return Result.error(&quot;登录失败&quot;);&#125; 地址簿管理address_book数据模型 image-20230706171952511 表现层代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 地址簿管理 */@Slf4j@RestController@RequestMapping(&quot;/addressBook&quot;)public class AddressBookController &#123; @Autowired private AddressBookService addressBookService; /** * 新增 */ @PostMapping public Result&lt;AddressBook&gt; save(@RequestBody AddressBook addressBook) &#123; addressBook.setUserId(BaseContext.getCurrentId()); log.info(&quot;addressBook:&#123;&#125;&quot;, addressBook); addressBookService.save(addressBook); return Result.success(addressBook); &#125; /** * 设置默认地址 */ @PutMapping(&quot;/default&quot;) public Result&lt;AddressBook&gt; setDefault(@RequestBody AddressBook addressBook) &#123; log.info(&quot;addressBook:&#123;&#125;&quot;, addressBook); LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = new LambdaUpdateWrapper&lt;&gt;(); wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId()); wrapper.set(AddressBook::getIsDefault, 0); //SQL:update address_book set is_default = 0 where user_id = ? addressBookService.update(wrapper); addressBook.setIsDefault(1); //SQL:update address_book set is_default = 1 where id = ? addressBookService.updateById(addressBook); return Result.success(addressBook); &#125; /** * 根据id查询地址 */ @GetMapping(&quot;/&#123;id&#125;&quot;) public Result get(@PathVariable Long id) &#123; AddressBook addressBook = addressBookService.getById(id); if (addressBook != null) &#123; return Result.success(addressBook); &#125; else &#123; return Result.error(&quot;没有找到该对象&quot;); &#125; &#125; /** * 查询默认地址 */ @GetMapping(&quot;/default&quot;) public Result&lt;AddressBook&gt; getDefault() &#123; LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId()); queryWrapper.eq(AddressBook::getIsDefault, 1); //SQL:select * from address_book where user_id = ? and is_default = 1 AddressBook addressBook = addressBookService.getOne(queryWrapper); if (null == addressBook) &#123; return Result.error(&quot;没有找到该对象&quot;); &#125; else &#123; return Result.success(addressBook); &#125; &#125; /** * 查询指定用户的全部地址 */ @GetMapping(&quot;/list&quot;) public Result&lt;List&lt;AddressBook&gt;&gt; list() &#123; AddressBook addressBook = new AddressBook(); addressBook.setUserId(BaseContext.getCurrentId()); //条件构造器 LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId()); queryWrapper.orderByDesc(AddressBook::getUpdateTime); //SQL:select * from address_book where user_id = ? order by update_time desc return Result.success(addressBookService.list(queryWrapper)); &#125;&#125; 核心业务思路 设置默认地址 一个用户的默认收货地址只能有一个，如何保证在设置默认地址时，每个用户的默认地址只有一个呢？那就是每次操作address_book数据表时，先将该用户的所有is_default字段都设置为0，再将选中的设置为1。 查询指定用户的全部地址 ​ 这里不需要请求参数，只需要用户userId，这个可以从Session中获取。 购物车需求分析 移动端用户可以将菜品/套餐添加到购物车 对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车（前端实现） 对于套餐来说，可以直接点击当前套餐加入购物车 在购物车中可以修改菜品/套餐的数量，也可以清空购物车 表现层代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117@RestController@RequestMapping(&quot;/shoppingCart&quot;)@Slf4jpublic class ShoppingCartController &#123; @Autowired private ShoppingCartService shoppingCartService; /** * 向购物车中新增菜品或套餐 * @param shoppingCart * @return */ @RequestMapping(&quot;/add&quot;) public Result&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart)&#123; // 获取当前用户的id，指定是哪个用户的购物车数据 Long currentId = BaseContext.getCurrentId(); shoppingCart.setUserId(currentId); Long dishId = shoppingCart.getDishId(); // 菜品和套餐的区别是发送的请求参数一个是dishId一个是setmealId // SQL: select * from shopping_cart where user_id = ? and [dish_id = ? 或者 setmeal_id = ?] LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId); if(dishId == null)&#123; // 加入购物车的是套餐setmealId lambdaQueryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId()); &#125;else&#123; // 加入购物车的是单菜品 lambdaQueryWrapper.eq(ShoppingCart::getDishId, shoppingCart.getDishId()); &#125; // shopping_cart中的一行数据 ShoppingCart shoppingCartOne = shoppingCartService.getOne(lambdaQueryWrapper); // 还要检查加入购物车菜品或者套餐的数量 -- 如果是第一次添加则setNumber=1，并执行save操作；如果不是第一次添加则updateNumber++ if(shoppingCartOne == null)&#123; // 第一次添加 shoppingCart.setNumber(1); shoppingCart.setCreateTime(LocalDateTime.now()); shoppingCartService.save(shoppingCart); shoppingCartOne = shoppingCart; &#125;else&#123; // 不是第一次添加 Integer number = shoppingCartOne.getNumber(); shoppingCartOne.setNumber(++number); shoppingCartService.updateById(shoppingCartOne); &#125; return Result.success(shoppingCartOne); &#125; /** * 向购物车中减少菜品或套餐 * @param shoppingCart * @return */ @RequestMapping(&quot;/sub&quot;) public Result&lt;ShoppingCart&gt; sub(@RequestBody ShoppingCart shoppingCart)&#123; Long userId = BaseContext.getCurrentId(); shoppingCart.setUserId(userId); // 实际请求参数只有dishId或者setmealId LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId, userId); if(shoppingCart.getDishId() != null)&#123; // 菜品 lambdaQueryWrapper.eq(ShoppingCart::getDishId, shoppingCart.getDishId()); &#125; else&#123; // 套餐 lambdaQueryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId()); &#125; ShoppingCart one = shoppingCartService.getOne(lambdaQueryWrapper); if(one.getNumber() == 1)&#123; shoppingCartService.remove(lambdaQueryWrapper); &#125; else if(one.getNumber() &gt; 1)&#123; one.setNumber(one.getNumber() - 1); shoppingCartService.updateById(one); &#125; return Result.success(one); &#125; /** * 根据登录用户的id查询购物车的列表清单 * @return */ @GetMapping(&quot;/list&quot;) public Result&lt;List&lt;ShoppingCart&gt;&gt; list()&#123; Long currentId = BaseContext.getCurrentId(); LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId); lambdaQueryWrapper.orderByAsc(ShoppingCart::getCreateTime); List&lt;ShoppingCart&gt; list = shoppingCartService.list(lambdaQueryWrapper); return Result.success(list); &#125; /** * 清空购物车 * @return */ @DeleteMapping(&quot;/clean&quot;) public Result&lt;String&gt; cleanShoppingCart()&#123; Long currentId = BaseContext.getCurrentId(); LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId); shoppingCartService.remove(lambdaQueryWrapper); return Result.success(&quot;清空购物车成功&quot;); &#125;&#125; 用户下单流程分析 在订单确认页面中，发送ajax请求，请求服务端，获取当前登录用户的默认地址 在订单确认页面，发送ajax请求，请求服务端，获取当前登录用户的购物车数据 在订单确认页面点击去支付按钮，发送ajax请求，请求服务端，完成下单操作 数据模型 orders数据表： order_detail数据表： “下单”核心业务思路 步骤1：查询当前用户的购物车，判断购物车是否为空，如果为空抛出业务异常无法下单； 步骤2：向订单表orders插入(1条)数据； 步骤3：向订单明细表order_detail插入(多条)数据； 步骤4：清空购物车数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 用户下单提交 * @param orders */@Overridepublic void submit(Orders orders) &#123; // 获得当前用户的id Long currentId = BaseContext.getCurrentId(); // 查询当前用户id的购物车数据 LambdaQueryWrapper&lt;ShoppingCart&gt; cartLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); cartLambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId); List&lt;ShoppingCart&gt; cartList = shoppingCartService.list(cartLambdaQueryWrapper); if (cartList == null || cartList.size() == 0)&#123; throw new ServiceException(&quot;购物车为空，无法下单&quot;); &#125; // 查询用户数据 User user = userService.getById(currentId); // 查询地址数据 Long addressBookId = orders.getAddressBookId(); AddressBook addressBook = addressBookService.getById(addressBookId); long orderId = IdWorker.getId();//订单号 AtomicInteger amount = new AtomicInteger(0); // 遍历购物车数据得到订单明细列表数据 List&lt;OrderDetail&gt; orderDetails = cartList.stream().map((item) -&gt; &#123; OrderDetail orderDetail = new OrderDetail(); orderDetail.setOrderId(orderId); orderDetail.setNumber(item.getNumber()); orderDetail.setDishFlavor(item.getDishFlavor()); orderDetail.setDishId(item.getDishId()); orderDetail.setSetmealId(item.getSetmealId()); orderDetail.setName(item.getName()); orderDetail.setImage(item.getImage()); orderDetail.setAmount(item.getAmount()); amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue()); return orderDetail; &#125;).collect(Collectors.toList()); // 订单表数据设置 orders.setId(orderId); orders.setOrderTime(LocalDateTime.now()); orders.setCheckoutTime(LocalDateTime.now()); orders.setStatus(2); orders.setAmount(new BigDecimal(amount.get()));//总金额 orders.setUserId(currentId); orders.setNumber(String.valueOf(orderId)); orders.setUserName(user.getName()); orders.setConsignee(addressBook.getConsignee()); orders.setPhone(addressBook.getPhone()); orders.setAddress((addressBook.getProvinceName() == null ? &quot;&quot; : addressBook.getProvinceName()) + (addressBook.getCityName() == null ? &quot;&quot; : addressBook.getCityName()) + (addressBook.getDistrictName() == null ? &quot;&quot; : addressBook.getDistrictName()) + (addressBook.getDetail() == null ? &quot;&quot; : addressBook.getDetail())); // 向订单表orders插入(1条)数据 this.save(orders); // 向订单明细表order_detail插入(多条)数据 orderDetailService.saveBatch(orderDetails); // 清空购物车数据 shoppingCartService.remove(cartLambdaQueryWrapper);&#125;","tags":[]},{"title":"瑞吉外卖项目实战day1","date":"2023-07-04T03:22:20.000Z","path":"2023/07/04/瑞吉外卖项目实战day1/","text":"适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。 项目构建配置静态资源映射为了访问静态资源，要进行静态资源映射的配置。 Springboot将静态资源都放在resource/static目录下，会进行自动配置静态资源映射。 image-20230704123442685 如果静态资源没放在resource/static目录，要书写配置类实现WebMvcConfigurer接口，重写addResourceHandlers方法，进行手动配置。 123456789@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射...&quot;); registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:/backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:/front/&quot;); &#125;&#125; 不推荐继承WebMvcConfigurationSupport类，而是使用实现WebMvcConfigurer接口，因为继承类会覆盖Springboot提供的自动静态资源映射配置，而实现接口是在原有的配置上附加映射配置。 配置文件配置Application.yml配置文件，核心是服务器端口号+数据库四要素。 此外还有mybatis-plus的一些配置。 1234567891011121314151617181920server: port: 8080spring: application: name: reggie_take_out datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/reggie username: root password: 12345678mybatis-plus: configuration: # 在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: ASSIGN_ID 实体类导入lombok依赖，通过@Data注释在实体类中只需要定义属性名，会自动生成默认的无参构造方法和setter/getter方法。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; @AllArgsConstructor：提供全部参数的构造方法，会覆盖@Data提供的无参构造方法。 @NoArgsConstructor：提供默认的无参构造方法。 统一结果封装使用Result类将服务器的响应进行统一格式的结果封装。 属性：状态位code（0/1）、错误信息msg（String）、数据data（泛型T） 1234567891011121314151617181920212223242526272829@Datapublic class Result&lt;T&gt; &#123; private Integer code; //编码：1成功，0和其它数字为失败 private String msg; //错误信息 private T data; //数据 private Map map = new HashMap(); //动态数据 public static &lt;T&gt; Result&lt;T&gt; success(T object) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); result.data = object; result.code = 1; return result; &#125; public static &lt;T&gt; Result&lt;T&gt; error(String msg) &#123; Result&lt;T&gt; result = new Result&lt;&gt;(); result.msg = msg; result.code = 0; return result; &#125; public Result&lt;T&gt; add(String key, Object value) &#123; this.map.put(key, value); return this; &#125;&#125; 业务实现编写Controller表现层业务方法时，首先需要通过前端代码以及浏览器开发者工具明确几个要素： 请求类型 请求路径 请求参数：尽量封装成实体类对象，通过getter得到请求参数。 @PathVariable：RESTful风格的参数 @RequestBody：json格式数据 @RequestParam 返回值类型：看前端代码需要服务器响应什么类型的数据。 后台登录功能表现层要素 12345678// login.jsfunction loginApi(data) &#123; return $axios(&#123; &#x27;url&#x27;: &#x27;/employee/login&#x27;, &#x27;method&#x27;: &#x27;post&#x27;, data &#125;)&#125; 请求类型：POST 请求路径：/employee/login 请求参数：包含username和password的json格式数据，可以封装成Employee实体类对象 1234567if (String(res.code) === &#x27;1&#x27;) &#123; localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify(res.data)) window.location.href= &#x27;../../index.html&#x27;&#125; else &#123; this.$message.error(res.msg) this.loading = false&#125; 返回值类型：由于前端需要服务端的响应包含data属性，所以返回值应该是Result&lt;Employee&gt;类型 核心业务思路 步骤1：先判断请求参数username/password是否为空，任一为空就不用再查表了； 步骤2：根据请求参数的username查表 – LambdaQueryWrapper封装查询条件； 步骤3：没查到数据（username）则返回失败； 步骤4：查询到了数据则进行密码比对，密码不一致返回失败 – 登录功能的密码考虑到安全性可以进行md5加密后再存入数据库：DigestUtils工具类的md5DigestAsHex(String.getBytes())方法； 步骤5：登陆成功，将员工id存入Session备用。 复习Session：一种服务端的会话跟踪技术，在一次会话的多次请求中共享数据。 123456// 创建SessionHttpServletRequset.getSession().setAttribute(String key, Object o);// 获取Session内容HttpServletRequset.getSession().getAttribute(String key);// 删除Session内容HttpServletRequset.getSession().removeAttribute(String key); 登录业务完善 只有登录成功了才得以访问其他页面，未登录则跳转到登录页面——在过滤器或拦截器中判断用户是否登录。 实现Filter过滤器 在LoginCheckFilter类中实现Filter接口，加类注释@WebFilter，重写doFilter方法； 123456789@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)public class LoginCheckFilter implements Filter &#123; /** * Servlet的过滤器对登录功能进行数据增强：访问界面如果未登录则自动跳转到登录界面 * */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; filterChain.doFilter(servletRequest, servletResponse); &#125; Springboot启动类上加@ServletComponentScan注释； 过滤器登录检查逻辑 获取本次请求的URI 定义不需要拦截的请求（静态资源+登录登出有关的资源路径），并判断本次请求是否需要被处理 1234567891011/* 包含通配符的路径匹配 */public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();// -----------具体实现-----------public boolean checkFilter(String[] urls, String requestURI) &#123; for (String url : urls) &#123; if (PATH_MATCHER.match(url, requestURI)) &#123; return true; &#125; &#125; return false; &#125; 如果不需要处理则直接放行 判断登录状态（通过Session），如果已登录则放行，如果未登录则通过输出流方式返回结果： 1response.getWriter().write(JSON.toJSONString(Result.error(&quot;NOTLOGIN&quot;))); 使用JSON.toJSONString要导入fastjson坐标。 添加员工功能表现层要素 12345678// member.js 新增---添加员工function addEmployee (params) &#123; return $axios(&#123; url: &#x27;/employee&#x27;, method: &#x27;post&#x27;, data: &#123; ...params &#125; &#125;)&#125; 请求类型：POST 请求路径：/employee 12345678910111213141516171819addEmployee(params).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;员工添加成功！&#x27;) if (!st) &#123; this.goBack() &#125; else &#123; this.ruleForm = &#123; username: &#x27;&#x27;, &#x27;name&#x27;: &#x27;&#x27;, &#x27;phone&#x27;: &#x27;&#x27;, // &#x27;password&#x27;: &#x27;&#x27;, // &#x27;rePassword&#x27;: &#x27;&#x27;,/ &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;idNumber&#x27;: &#x27;&#x27; &#125; &#125; &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;)&#125; 请求参数：包含username、name、phone、sex、idNumber的json格式数据，可以封装成Employee实体类对象 返回值类型：由于前端需要服务端的响应只有code和msg属性，所以返回值写成Result&lt;String&gt;类型。 核心业务思路 Controller表现层直接调用Service层的save添加实体轮类Employee对象，在Mapper层对象解析成Employee数据表中的字段进行数据添加。 添加员工业务完善 操作数据库时insert操作要注意：① 数据表中not null的字段必须有值； ② 数据表中主键、not unique字段都不能重复，要进行判断。 Employee数据表结构： 前端的表单中提交过来的参数填充的字段有：username、name、phone、sex、id_number，主键id雪花算法自动生成、status具有默认值1，所以后面4个not null字段的值需要我们手动来添加： 而创建人、创建时间、修改人、修改时间字段属于公共字段，不仅员工表有这些字段，在菜品表、分类表等其他表中，也拥有这些字段。那我们有没有办法让这些字段在一个地方统一管理呢？ 解决方案：使用MybatisPlus给我们提供的公共字段自动填充功能。 在Employee数据表中，username字段not unique不能重复： 步骤1：获取请求参数中的username，调用Service方法检查用户名是否重复； 步骤2：用户名重复则无法添加，抛出异常（进行统一异常处理）并响应给前端提示信息；用户名未重复则操作数据库进行添加操作。 公共字段自动填充 步骤1：按照框架要求编写元数据对象处理器MyMetaObjectHandler类，在此类中统一对公共字段赋值，此类需要实现MetaObjectHandler接口，实现接口之后，重写两个方法，一个是插入时填充，一个是修改时填充（字段填充方式，使用metaObject的setValue方法来实现）： 1234567891011121314151617181920212223242526272829@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; /** * 插入操作自动填充 * */ @Override public void insertFill(MetaObject metaObject) &#123; metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now()); metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now()); // 在元数据对象处理器中通过LocalThread获取用户id metaObject.setValue(&quot;createUser&quot;, BaseContext.getCurrentId()); metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId()); &#125; /** * 更新操作自动填充 * */ @Override public void updateFill(MetaObject metaObject) &#123; // 获取当前线程 Long id = Thread.currentThread().getId(); log.info(&quot;线程id: &#123;&#125;&quot;, id); metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now()); // 在元数据对象处理器中通过LocalThread获取用户id metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId()); &#125;&#125; 步骤2：在实体类的属性上方加入@TableFiled注解，指定自动填充的策略 1234567891011@TableField(fill = FieldFill.INSERT) // 插入时填充字段private LocalDateTime createTime;@TableField(fill = FieldFill.INSERT_UPDATE) // 插入和更新时填充字段private LocalDateTime updateTime;@TableField(fill = FieldFill.INSERT) // 插入时填充字段private Long createUser;@TableField(fill = FieldFill.INSERT_UPDATE) // 插入和更新时填充字段private Long updateUser; 通过LocalThread获取用户id 关于id的获取，我们之前是存到session里的，但在MyMetaObjectHandler类中不能获得HttpSession对象，所以我们需要用其他方式来获取登录用户id。 我们可以使用ThreadLocal来解决这个问题：在学习ThreadLocal之前，我们需要先确认一个事情，就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程： LoginCheckFilter中的doFilter方法 EmployeeController中的响应方法 MyMetaObjectHandler中的insertFill或者updateFill方法 ThreadLocal并不是一个Thread，而是Thread的局部变量；当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本；所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本；ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。 具体实现—— 我们可以在LoginCheckFilter过滤器的的doFilter方法中获取当前登录用户id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值（用户id)，然后在MyMetaObjectHandler的insertFill或updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值（用户id)。 步骤1：common包下新建BaseContext类 1234567891011121314/** * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户的id * */public class BaseContext &#123; public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void setCurrentId(Long id)&#123; threadLocal.set(id); &#125; public static Long getCurrentId()&#123; return threadLocal.get(); &#125;&#125; 步骤2：在LoginCheckFilter类（每次请求都会首先经过过滤器类）中获取当前Session的值(用户id)，使用BaseContext封装的setCurrentId方法封装id值 步骤3：在MyMetaObjectHandler类中获取当前请求所在线程的id值。 统一异常处理 统一异常处理框架 在common包下添加一个ProjectExceptionAdvice统一异常处理类，加类注释@RestControllerAdvice； 方法参数是异常类型的对象ex，方法上加类注释@ExceptionHandler(异常类型.class)，返回值一般是Result&lt;String&gt;； 1234567891011@RestControllerAdvicepublic class ProjectExceptionAdvice &#123; @ExceptionHandler(SQLIntegrityConstraintViolationException.class) public Result&lt;String&gt; doSqlException(SQLIntegrityConstraintViolationException ex)&#123; log.info(ex.getMessage()); // Duplicate entry &#x27;lisi&#x27; for key &#x27;employee.idx_username&#x27; /* --- 异常逻辑判断（可选） --- */ return Result.error(&quot;&quot;); &#125;&#125; 异常逻辑判断（有些时候需要，有时不用）– ex.getMessage()方法很重要 12345if(ex.getMessage().contains(&quot;Duplicate entry&quot;))&#123; // Duplicate entry &#x27;lisi&#x27; for key &#x27;employee.idx_username&#x27; String[] split = ex.getMessage().split(&quot; &quot;); String msg = split[2] + &quot;已存在&quot;; return Result.error(msg);&#125; 员工信息分页查询表现层要素 12345678// member.js function getMemberList (params) &#123; return $axios(&#123; url: &#x27;/employee/page&#x27;, method: &#x27;get&#x27;, params &#125;)&#125; 请求类型：GET 请求路径：/employee/page 12345678910111213141516methods: &#123; async init () &#123; const params = &#123; page: this.page, pageSize: this.pageSize, name: this.input ? this.input : undefined &#125; await getMemberList(params).then(res =&gt; &#123; if (String(res.code) === &#x27;1&#x27;) &#123; this.tableData = res.data.records || [] this.counts = res.data.total &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125;, image-20230704170513895 请求参数：包含page、pageSzie和可选参数name，因为是get请求，所以请求参数是在请求头中的普通参数 返回值类型：由于前端需要服务端的响应除了code属性还有res.data.records和res.data.total属性，很明显方法返回值是Result&lt;Page&gt;类型。 Mybatis-Plus中分页插件配置 要在Springboot项目中使用分页查询，必须要配置Mybatis-Plus的分页插件： 在config包下新建MybatisPlusConfig配置类，在方法中首先创建一个MybatisPlus拦截器，在拦截器中再添加分页查询的拦截器，不要忘了将方法注释为@Bean方法。 123456789101112/** * 配置MybatisPlus的分页插件 * */@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; &#125;&#125; 核心业务思路 分页查询的请求参数是page、pageSize，响应参数也是page，它的业务逻辑比较固定，直接展示实现基本分页功能的表现层代码了： 1234567891011121314@GetMapping(&quot;/page&quot;) public Result&lt;Page&gt; pageSelect(Integer page, Integer pageSize, String name)&#123; // 构造分页构造器 Page&lt;Employee&gt; pageInfo = new Page&lt;&gt;(page, pageSize); // 构造条件构造器 LambdaQueryWrapper&lt;Employee&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); // 添加过滤条件 lambdaQueryWrapper.like(StringUtils.hasText(name), Employee::getName, name); // 或者 name != null // 添加排序条件 lambdaQueryWrapper.orderByDesc(Employee::getUpdateTime); // 执行查询 employeeService.page(pageInfo, lambdaQueryWrapper); // IService的page函数会将查询数据自动封装到pageInfo当中 return Result.success(pageInfo); &#125; 禁用/启用员工账号在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作：账号禁用的员工不能登录系统，启用后的员工可以正常登录。【前端业务】需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。 表现层要素 12345678// member.js --启用禁用接口function enableOrDisableEmployee (params) &#123; return $axios(&#123; url: &#x27;/employee&#x27;, method: &#x27;put&#x27;, data: &#123; ...params &#125; &#125;)&#125; 请求类型：PUT 请求路径：/employee image-20230704173524643 请求参数：包含id和status的json格式数据，可以封装成Employee实体类对象（这里注意一下，status为0则表示客户端的禁用请求，status为1则表示客户端的启用请求） 1234567enableOrDisableEmployee(&#123; &#x27;id&#x27;: this.id, &#x27;status&#x27;: !this.status ? 1 : 0 &#125;).then(res =&gt; &#123; console.log(&#x27;enableOrDisableEmployee&#x27;,res) if (String(res.code) === &#x27;1&#x27;) &#123; this.$message.success(&#x27;账号状态更改成功！&#x27;) this.handleQuery() &#125;&#125; 返回值类型：由于前端需要服务端的响应只有code属性，所以返回值写成Result&lt;String&gt;类型。 核心业务思路 将请求参数传入Service的updateById方法，就可以更改相应employee数据的status字段值。 但是通过日志我们发现，数据并没有修改成功，原因是服务端接收到的Long类型的请求参数employee.id 通过前端js已经丢失了精度，导致id不准确，无法从数据库中找到相应id的数据！ 解决方案是：我们可以在服务端给页面响应json数据时进行处理，将Long型数据统一转为String字符串。 拓展mvc的消息转换器 可以自定义服务器Result对象序列化成json数据的细节，比如数据类型Long→String，比如自定义时间格式等。 步骤1：common包下配置对象映射器（工具类可以直接复制代码） 1234567891011121314151617181920212223242526272829303132333435/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123; public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; public JacksonObjectMapper() &#123; super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(BigInteger.class, ToStringSerializer.instance) .addSerializer(Long.class, ToStringSerializer.instance) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); &#125;&#125; 步骤2：扩展Mvc框架的消息转换器 config包下的WebMvcConfig配置类，实现WebMvcConfigurer接口，重写extendMessageConverters方法（方法在项目启动时就被调用）。springboot自己的消息转换器可以把返回的Result对象序列化成json数据响应给前端，而我们可以根据自己的需要扩展消息转换器。 1234567891011121314151617@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; /** * 扩展mvc框架的消息转换器: springboot自己的消息转换器可以把返回的Result对象序列化成json数据响应给前端，而我们可以根据自己的需要扩展消息转换器 * (方法在项目启动时调用) * */ @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; log.info(&quot;扩展消息转换器...&quot;); // 创建消息转换器对象 MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); // 设置对象转换器，底层使用jackson将Java对象转换成json数据 messageConverter.setObjectMapper(new JacksonObjectMapper()); // 将上面的消息转换器对象追加到mvc框架的转换器集合中 converters.add(0, messageConverter); &#125;&#125; 编辑员工信息流程分析 后续我们会开发一些比较复杂的业务功能，一个业务功能处理多个请求发送多个响应数据，所以流程分析是很重要的。 在list.html页面中，点击编辑按钮，页面跳转到add.html中，并在url中携带employee的id； 发送ajax请求（回显数据的请求），将id提交给服务器； 服务器接收请求，根据id查询employee信息，并将员工信息响应给页面； 页面接收服务端的json数据，并通过Vue的双向绑定进行员工信息回显； 点击保存按钮，发送ajax请求（修改数据的请求），将id和表单数据一起提交至服务端； 服务端接收员工信息，根据id修改员工的信息，完成后给页面响应。 表现层要素 回显数据的请求 1234567// member.js -- 修改页面反查详情接口function queryEmployeeById (id) &#123; return $axios(&#123; url: `/employee/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;)&#125; image-20230704201830485 请求类型：GET 请求路径：/employee/&#123;id&#125; 请求参数：只有员工id，且是RESTful风格，需要加@PathVariable注解 1234567891011queryEmployeeById(this.id).then(res =&gt; &#123; console.log(res) if (String(res.code) === &#x27;1&#x27;) &#123; console.log(res.data) this.ruleForm = res.data this.ruleForm.sex = res.data.sex === &#x27;0&#x27; ? &#x27;女&#x27; : &#x27;男&#x27; // this.ruleForm.password = &#x27;&#x27; &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 返回值类型：前端需要服务端的响应data属性，所以方法返回值是Result类型。 修改数据的请求 12345678// 修改---添加员工function editEmployee (params) &#123; return $axios(&#123; url: &#x27;/employee&#x27;, method: &#x27;put&#x27;, data: &#123; ...params &#125; &#125;)&#125; 请求类型：PUT 请求路径：/employee image-20230704210234755 请求参数：json格式的员工信息 12345678editEmployee(params).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;员工信息修改成功！&#x27;) this.goBack() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 返回值类型：前端只要服务端的响应code和msg属性，所以方法返回值是Result&lt;String&gt;类型即可。 核心业务思路 通过员工id查询Employee数据表进行数据回显；前端点击修改按钮后，服务端接收修改后的Employee对象请求参数，调用Service层的updateById传回employee对象即可修改数据表内容。 新增菜品分类数据模型 image-20230705093303752 菜品分类id字段是主键，name分类名称是unique唯一的，type为1表示菜品分类，type为2表示套餐分类。 表现层要素 12345678// category.js -- 新增接口 const addCategory = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category&#x27;, method: &#x27;post&#x27;, data: &#123; ...params &#125; &#125;) &#125; 请求类型：POST 请求路径：/employee image-20230705094033530 image-20230705094411620 123456789101112131415addCategory(&#123;&#x27;name&#x27;: classData.name,&#x27;type&#x27;:this.type, sort: classData.sort&#125;).then(res =&gt; &#123; console.log(res) if (res.code === 1) &#123; this.$message.success(&#x27;分类添加成功！&#x27;) if (!st) &#123; this.classData.dialogVisible = false &#125; else &#123; this.classData.name = &#x27;&#x27; this.classData.sort = &#x27;&#x27; &#125; this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 请求参数：json格式的请求参数，包含name、type、sort字段，可以封装成Category对象 返回值类型：前端需要服务端的响应只有code和msg属性，所以方法返回值是Result&lt;String&gt;类型 核心业务思路 前面已经做过新增员工的业务逻辑，新增菜品分类的其实都是一样的，（新增业务的重点）保证每一个not null的字段都有赋值且unique的字段没有重复，再通过Service层的save方法调用进而mapper操作数据库进行添加数据。 分类信息分页查询表现层要素 12345678// category.js -- 查询列表接口 const getCategoryPage = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category/page&#x27;, method: &#x27;get&#x27;, params &#125;) &#125; 请求类型：GET 请求路径：/category/page image-20230705094851492 12345678await getCategoryPage(&#123;&#x27;page&#x27;: this.page, &#x27;pageSize&#x27;: this.pageSize&#125;).then(res =&gt; &#123; if (String(res.code) === &#x27;1&#x27;) &#123; this.tableData = res.data.records this.counts = Number(res.data.total) &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 请求参数：分页查询，请求参数是普通请求头里的page、pageSize。 返回值类型：Result&lt;Page&gt;类型 核心业务思路 对于分页查询来说，我们一定要记得配置MybatisPlus的分页查询插件。除此之外，表现层的业务代码非常简单：分页构造器+条件构造器（排序条件），调用Service层的page函数即可，最终把分页构造器响应给前端用来页面的展示。 分页插件的配置，再复习一下： 123456789@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; &#125;&#125; 删除菜品分类表现层要素 12345678// category.js -- 删除当前列的接口 const deleCategory = (ids) =&gt; &#123; return $axios(&#123; url: &#x27;/category&#x27;, method: &#x27;delete&#x27;, params: &#123; ids &#125; &#125;) &#125; image-20230705100107054 请求类型：DELETE 请求路径：/category/&#123;ids&#125; 请求参数：RESTful风格的菜品id参数，如果方法参数名和前端请求参数名不一致，需要在注释后面加@PathVariable(&quot;参数名&quot;)参数名进行映射。 12345678deleCategory(id).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;删除成功！&#x27;) this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 返回值类型：Result&lt;String&gt;类型 核心业务思路 因为请求参数是Category数据表的主键值id，所以直接调用Service层的removeById删除数据即可。和新增业务必须考虑的not null和unique字段一样，删除业务也有必须考虑的点：也就是当前要删除的数据，是否跟其他表中的数据相关联。对于当前来说，当菜品分类或套餐分类关联了其他菜品或套餐时，该分类将不允许被删除，所以我们需要进一步完善我们的删除业务逻辑。（是否可以直接把关联通过外键约束等体现在数据库中，这需要进一步优化数据库表？复习完mysql再回来研究） MybatisPlus中的Service层提供的删除方法不能满足我们的业务需求，所以我们在Service层手动添加remove方法：我们需要在删除数据之前，根据id值，去Dish表和Setmeal表中（category_id字段）查询是否关联了数据：如果存在关联数据，则不能删除，并抛一个自定义的业务异常。 复习一下统一异常处理：自定义业务异常 步骤1：在exception包下创建响应的Exception类 12345678/** * 自定义的业务异常 * */public class ServiceException extends RuntimeException&#123; public ServiceException(String message)&#123; super(message); &#125;&#125; 步骤2：在统一异常处理类中自定义异常处理方法 12345678/** * 异常处理方法 * */@ExceptionHandler(ServiceException.class)public Result&lt;String&gt; doServiceException(ServiceException ex)&#123; log.info(ex.getMessage()); return Result.error(ex.getMessage());&#125; 修改菜品分类表现层要素 12345678// category.js -- 修改接口 const editCategory = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category&#x27;, method: &#x27;put&#x27;, data: &#123; ...params &#125; &#125;) &#125; image-20230705105056053 请求类型：PUT 请求路径：/category image-20230705105128881 请求参数：json格式的菜品id、name、sort参数，封装成Category对象。 123456789editCategory(&#123;&#x27;id&#x27;:this.classData.id,&#x27;name&#x27;: this.classData.name, sort: this.classData.sort&#125;).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;分类修改成功！&#x27;) this.classData.dialogVisible = false this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 返回值类型：Result&lt;String&gt;类型 这里的数据回显完全交由前端来处理，我们简单了解下前端是如何完成数据回显的即可。页面首先通过scope.row 传递当前行的数据对象，通过v-model双向绑定完成数据的回显。 核心业务思路 没什么好讲的，直接调用Service原生的updateById方法把实体类对象传进去。 文件上传与下载文件上传 文件上传，也叫upload，是指将本地图片、视频、音频等文件上传到服务器中，可以供其他用户浏览或下载的过程。 文件上传的前端业务我们不需要掌握，只需要了解文件上传是通过采用post方式提交数据即可。Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件： 1234567891011@RestController@RequestMapping(&quot;/common&quot;)public class CommonController &#123; /** * 文件上传 * */ @PostMapping(&quot;/upload&quot;) public Result&lt;String&gt; upload(MultipartFile file) throws IOException &#123; // 请求参数名是Form-Data的name值 return Result.success(fileName); &#125; &#125; 这里的MultipartFile类型的参数名不是随意定的，要和前端请求参数中Form-Data的name值一致才可以！ image-20230705112408492 文件下载 文件下载，也称为了download，是指将文件从服务器传输到本地计算机的过程，本质上就是服务端将文件以流的形式写回浏览器的过程。通过浏览器进行文件下载，通常有两种表现形式：① 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录；② 直接在浏览器中打开。 文件上传核心业务实现 image-20230705161814263 请求类型：POST 请求路径：/common/upload 请求参数：MultipartFile类型的对象 file 方法返回值：Result&lt;String&gt; 123456789101112131415161718192021222324252627 // 注入配置文件的属性 @Value(&quot;$&#123;reggie.path&#125;&quot;) private String basePath;@PostMapping(&quot;/upload&quot;) public Result&lt;String&gt; upload(MultipartFile file) throws IOException &#123; // 请求参数名是Form-Data的name值 log.info(file.toString()); /* * 本地的是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除 * */ String originalFilename = file.getOriginalFilename(); // xxxxxxx.jpg String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)); // 使用UUID重新生成文件名，防止文件名重复造成的文件覆盖 String fileName = UUID.randomUUID().toString() + suffix; /* 判断文件目录basePath确实存在，若不存在则先进行创建 */ // 创建一个目录对象 File dir = new File(basePath); if(!dir.exists())&#123; dir.mkdirs(); &#125; file.transferTo(new File(basePath + fileName)); // 转存文件 return Result.success(fileName); &#125; 因为上传至服务器的是一个临时文件（完成本次请求后会被删除），所以我们需要设定文件转存到指定位置，在yml配置文件中设置保存在服务器中的路径并通过@Value(&quot;$&#123;xxx&#125;&quot;)获得路径： 123# 自定义下载上传图片的路径配置reggie: path: /Users/NUC/git/SSM/reggie_take_out/src/main/resources/picture/ 文件下载核心业务实现 前端页面的ElementUI在上传完图片后发送请求，服务端以流的方式（输出流）将文件写回给浏览器，在浏览器中展示图片： 123456789handleAvatarSuccess (response, file, fileList) &#123; // 拼接down接口预览 if(response.code === 0 &amp;&amp; response.msg === &#x27;未登录&#x27;)&#123; window.top.location.href = &#x27;../login/login.html&#x27; &#125;else&#123; this.imageUrl = `/common/download?name=$&#123;response.data&#125;` this.ruleForm.image = response.data &#125;&#125;, image-20230705162548370 请求类型：GET 请求路径：/common/download 请求参数：String类型的文件名name 方法返回值：无 1234567891011121314151617181920212223/** * 文件下载 * */@GetMapping(&quot;/download&quot;)public void download(HttpServletResponse response, @RequestParam(&quot;name&quot;) String fileName) throws Exception &#123; // 输入流，通过输入流读取文件内容 FileInputStream fileInputStream = new FileInputStream(new File(basePath + fileName)); // 输出流，通过输出流将文件写回浏览器，在浏览器展示图片 ServletOutputStream outputStream = response.getOutputStream(); // 设置响应数据的类型 response.setContentType(&quot;image/jpeg&quot;); int len = 0; byte[] bytes = new byte[1024]; while((len = fileInputStream.read(bytes)) != -1)&#123; outputStream.write(bytes,0 ,len); outputStream.flush(); &#125; // 关闭资源 outputStream.close(); fileInputStream.close();&#125; 文件下载中有一个容易被忽视的点：浏览器需要知道文件的类型，所以必须设置相应数据的类型response.setContentType，否则会导致下载失败。 新增菜品流程分析 add.html页面发送ajax请求，请求服务器获取菜品分类并展示到下拉框中 选择图片进行上传，请求服务器将图片保存在服务器当中 上传成功后前端会自动发送下载请求，回显上传的图片 点击保存按钮，发送ajax请求，将菜品相关json数据提供到服务器端进行处理 表现层要素 上传下载请求上一节讲的很明白了这里就不说了，主要讲一下第一个请求（是容易被忽略掉的）和第四个请求。 获取菜品分类并展示到下拉框 12345678// 获取菜品分类列表const getCategoryList = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category/list&#x27;, method: &#x27;get&#x27;, params &#125;)&#125; 请求类型：GET 请求路径：/category/list image-20230705171036768 12345678910// 获取菜品分类getDishList () &#123; getCategoryList(&#123; &#x27;type&#x27;: 1 &#125;).then(res =&gt; &#123; if (res.code === 1) &#123; this.dishList = res.data &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;)&#125;, 请求参数：菜品分类Category对象中的分类类型type，可以封装成Category对象 方法返回值：前端得到服务器响应的结果有data属性，返回值应该是Result&lt;List&gt;类型，将查询到的列表响应给前端 将新增菜品json数据提交 image-20230705163823971 请求类型：POST 请求路径：/dish image-20230705163902869 请求参数：json格式的dish菜品信息，外加flavors是一个json数组。而flavors不是Dish类中的属性，Dish对象不足以接收本次请求的参数，所以需要导入Dish的增强类DishDto，用于封装页面提交的数据。 DTO，全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之间的数据传输。 123456789@Datapublic class DishDto extends Dish &#123; private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;(); private String categoryName; private Integer copies;&#125; 123456789101112131415161718192021222324252627if (this.actionType == &#x27;add&#x27;) &#123; delete params.id addDish(params).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;菜品添加成功！&#x27;) if (!st) &#123; this.goBack() &#125; else &#123; this.dishFlavors = [] // this.dishFlavorsData = [] this.imageUrl = &#x27;&#x27; this.ruleForm = &#123; &#x27;name&#x27;: &#x27;&#x27;, &#x27;id&#x27;: &#x27;&#x27;, &#x27;price&#x27;: &#x27;&#x27;, &#x27;code&#x27;: &#x27;&#x27;, &#x27;image&#x27;: &#x27;&#x27;, &#x27;description&#x27;: &#x27;&#x27;, &#x27;dishFlavors&#x27;: [], &#x27;status&#x27;: true, categoryId: &#x27;&#x27; &#125; &#125; &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;) 返回值类型：Result&lt;String&gt;类型 核心业务思路 获取菜品分类并展示到下拉框 ​ 将请求参数type作为查询条件，调用Service层的list将菜品分类列表响应给前端即可。 将新增菜品json数据提交 ​ 由于请求参数是json格式的嵌套，且flavors口味数据并不在Dish数据表中，所以要完成新增菜品的业务我们需要：① 在dish数据表中添加菜品基本信息； ② 在dish_flavor数据表中添加口味信息。 ​ 步骤1：因为要在两张数据表中添加数据，所以不能用MyabtisPlus提供好的Service层方法，我们在Service中自定义新增方法； ​ 因为这里要在多张表中添加或修改数据，所以要加入事务管理：① 在Service层方法或类上加注释@Transactional； ② 在启动类上加注释@EnableTransactionManagement. ​ 步骤2：添加菜品的基本信息到dish菜品表this.save(dishDto);；（这里可以直接传dishDto对象） ​ 步骤3：添加菜品口味数据flavors到菜品口味表dish_flavor，要注意dish_id（是一个not null字段）无法通过flavors列表赋值要通过Dto对象手动set。 ​ 菜品信息分页查询流程分析 这里的分页查询其实也是发送了两次请求： 请求参数page、pageSize和可选参数name，发送分页请求并回显在页面上； 向服务端发送下载请求，将图片回显到页面上。（这个请求前面的CommonController表现层已经实现功能响应） 核心业务思路 分页查询前面已经做过好多了，这里的分页查询图片列和菜品分类列比较特殊： 图片列：会用到文件的下载功能 菜品分类列：由于我们的dish菜品表只保存了category_id，所以我们需要在category分类表中查询category_id对应的菜品分类名称，从而回显数据 image-20230705184128037 因为代码中用到了几个比较关键的知识点，所以这里我直接展示业务代码，也方便到时候复习来看： 123456789101112131415161718192021222324252627282930@GetMapping(&quot;/page&quot;) public Result&lt;Page&gt; pageSelect(int page, int pageSize, String name) &#123; Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page, pageSize); Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;(); LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.like(name != null, Dish::getName, name); lambdaQueryWrapper.orderByDesc(Dish::getUpdateTime); dishService.page(pageInfo, lambdaQueryWrapper); // 对象拷贝pageInfo除了&quot;records&quot;属性 BeanUtils.copyProperties(pageInfo, dishDtoPage, &quot;records&quot;); List&lt;Dish&gt; records = pageInfo.getRecords(); List&lt;DishDto&gt; dishDtoList = records.stream().map((item) -&gt; &#123; DishDto dishDto = new DishDto(); BeanUtils.copyProperties(item, dishDto); Long categoryId = item.getCategoryId(); Category category = categoryService.getById(categoryId); String categoryName = category.getName(); dishDto.setCategoryName(categoryName); return dishDto; &#125;).collect(Collectors.toList()); dishDtoPage.setRecords(dishDtoList); return Result.success(dishDtoPage); &#125; 修改菜品流程分析 页面发送ajax请求，请求服务器获取分类数据，用于菜品分类下拉框的数据回显（之前已经实现过了） 页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显 页面发送请求，请求服务端进行图片下载，用于页面图片回显（之前已经实现过了） 点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端 表现层要素 回显数据 image-20230705214455637 请求类型：GET 请求路径：/dish/&#123;id&#125; 请求参数：RESTful风格的菜品id 123456789101112131415queryDishById(this.id).then(res =&gt; &#123; console.log(res) if (String(res.code) === &#x27;1&#x27;) &#123; this.ruleForm = &#123; ...res.data &#125; this.ruleForm.price = String(res.data.price/100) this.ruleForm.status = res.data.status == &#x27;1&#x27; this.dishFlavors = res.data.flavors &amp;&amp; res.data.flavors.map(obj =&gt; (&#123; ...obj, value: JSON.parse(obj.value),showOption: false &#125;)) console.log(&#x27;this.dishFlavors&#x27;,this.dishFlavors) // this.ruleForm.id = res.data.data.categoryId // this.imageUrl = res.data.data.image this.imageUrl = `/common/download?name=$&#123;res.data.image&#125;` &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 方法返回值：前端用到了响应的data.flavors属性，所以响应的数据一定是Result类型 提交修改数据 image-20230705215233049 请求类型：PUT 请求路径：/dish 请求参数：json格式的DishDto对象 12345678editDish(params).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;菜品修改成功！&#x27;) this.goBack() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125;&#125;) 方法返回值：Result&lt;String&gt; 核心业务思路 回显数据 ​ 这里的数据回显还是值得一提的。通常来说数据回显就是以id作为请求参数向服务端发送查询请求，在以id作为主键的数据表中查询到该条数据并将该对象作为相应参数返回并回显在页面上。但是这里回显的数据内容除了以id作为主键的dish菜品表外，还有flavors口味信息，需要在dish_flavor表中查询多条数据。 ​ 步骤1：在Service层自定义一个根据菜品id查询的业务层方法； ​ 步骤2：根据id查询dish菜品表中的基本信息，只需要调用MybatisPlus原生的getOne方法得到查询到的Dish对象； ​ 步骤3：因为要在dish_flavor表再做查询，而Dish对象没有flavors属性，所以定义一个DishDto增强对象，并进行Dish的对象拷贝； ​ 步骤4：根据DishDto的id属性查询dish_id = id的DishDto对象列表，set给DishDto的flavors属性，将DishDto响应给前端。 提交修改数据 很显然这里也要涉及两张表dish表和dish_flavor表的修改操作，所以先在Service实现类上加上注释@Transactional。 步骤1：先在Service实现类上加上注释@Transactional； ​ 步骤2：将请求参数DishDto传入MybatisPlus原生的updateById方法修改dish表中的菜品基本信息； ​ 步骤3：在dish_flavor表中涉及多条数据的修改，所以这里的修改我们将其拆分为删除+添加两个过程来完成：首先是将dish_id = DishDto.id的数据删除； ​ 步骤4：再将DishDto.flavors这个列表通过saveBatch方法添加到口味表中，其中dish_id字段在DishDto.flavors中没有相应的属性对应，要进行手动的set。","tags":[]},{"title":"IDEA中集成git","date":"2023-06-30T09:21:51.000Z","path":"2023/06/30/IDEA中集成git/","text":"这篇博客主要记录git的常用命令以及在IDE中集成git简化版本控制操作。 git安装以及更新（macOS）：安装Homebrew git常用命令git全局设置 git版本 1git --version 设置用户信息 12git config --global user.name &quot;KiCheng&quot;git config --global user.email &quot;lijiacehng053@gmail.com&quot; 查看配置信息 1git config --list 获取本地仓库 在本地初始化一个git仓库（不常用） 1git init 从远程仓库克隆（常用） 1git clone [URL] 本地仓库操作 查看文件状态 1git status 将文件的修改加入暂存区 1git add [文件名] / git add . 将暂存区的文件取消暂存或者是切换到指定版本 12git reset [文件名] / git reset .git reset --hard [版本号] 将暂存区的文件修改提交到本地版本库 1git commit -m &quot;[注释内容]&quot; 查看日志 1git log 远程仓库操作 查看远程仓库 1git remote / git remote -v 连接到远程仓库 1git remote add [远程仓库名(通常是origin)] [URL] 从远程仓库克隆 1git clone [URL] 从远程仓库拉取 1git pull [远程仓库名] [分支名] 推送到远程仓库 1git push [远程仓库名] [分支名] 分支操作 查看分支 1git branch 创建分支 1git branch [分支名] 切换分支 1git checkout [分支名] 推送至远程仓库分支 1git push [远程仓库名] [分支名] 合并分支 1git merge [分支名] 分支合并时冲突：手动处理合并冲突再重新add + commit -i. 标签操作 列出已有标签 1git tag 创建标签 1git tag [标签名] 将标签推送至远程仓库 1git tag [远程仓库名] [标签名] 创建新分支检出标签 1git checkout -b [新建分支名] [标签名] IDEA中集成git 获取本地仓库方法一：本地初始化仓库 路径选择IDE中的demo目录即可。 方法二：从远程仓库克隆 image-20230630182549048 image-20230630182656435 本地仓库操作 将文件加入暂存区 IDEA会弹出提示框，自动把新建或修改的文件add到暂存区，也可以手动添加。 未加入暂存区的文件是红色的，加入暂存区的文件是绿色的： image-20230630183314045 将暂存区的文件提交到版本库 ​ 查看日志 image-20230630184053887 远程仓库操作 查看并添加远程仓库 推送至远程仓库 从远程仓库拉取 分支操作 image-20230630193635799 将分支推送到远程仓库 合并分支","tags":[]},{"title":"Maven进阶","date":"2023-06-22T02:20:18.000Z","path":"2023/06/22/Maven进阶/","text":"Maven就是是专门为Java项目打造的管理和构建工具，它 提供了一套标准化的项目结构、提供了一套标准化的构建流程等等。 分模块开发分模块开发设计1、按照功能拆分：如果把不同业务场景的模块代码放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动，从而导致多个业务都无法正常运行。所以我们会按照功能将项目进行拆分。 2、按照模块拆分：比如电商的项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期的维护成本就比较高。我们就想能不能将它们公共的部分抽取成一个独立的模块，其他模块要想使用可以像添加第三方jar包依赖一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就说我们所说的按照模块拆分。 我们可以将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享： 这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。 分模块开发实现这里就基于SSM整合的项目来实现对项目的拆分。 环境准备（之前ssm整合的框架） 抽取domain层步骤1：创建新模块maven_03_pojo 步骤2：项目中创建domain包，将Book实体类复制进来 步骤3：删除原项目(maven_02_ssm)中的domain包 image-20230622161341910 这时在原项目中用到Book实体类的地方都会出现报错。解决问题的办法是在maven_02_ssm中添加maven_03_pojo的依赖。 步骤4：建立依赖关系 在maven_02_ssm项目的pom.xml添加maven_03_pojo的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;maven_03_pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 步骤5：编译maven_02_ssm模块 这时虽然不再报错了，但是不意味着程序可以正常运行。报错提醒我们在maven_02_ssm模块中找不到maven_03_pojo的jar包： image-20230622163816397 那么为什么找不到呢？因为Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包，所以我们需要手动将maven_03_pojo项目安装到本地仓库即 可。 步骤6：将项目安装到本地仓库 image-20230622164033568 此时maven_02_ssm模块就可以编译成功了。 抽取dao层步骤1：创建新模块并在项目中创建dao包 image-20230622164526229 这时候存在两个问题： 1）实体类Book类不存在：添加maven_03_pojo的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;maven_03_pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 2）Mybatis在dao层的增删改查注解无法识别：添加mybatis和mysql依赖 image-20230622164827822 步骤2：删除原项目(maven_02_ssm)的dao包，添加maven_04_dao的依赖 分模块开发总结1、创建Maven模块 2、书写模块代码 分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。 3、通过maven指令安装模块到本地仓库(install 指令) 依赖管理依赖指当前项目运行所需的jar，一个项目可以设置多个依赖。在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用标签来进行jar包的引入即可。 依赖的格式： 1234567891011&lt;dependencies&gt; &lt;!--设置具体的依赖--&gt; &lt;dependency&gt; &lt;!--依赖所属群组id--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;!--依赖所属项目id--&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;!--依赖版本号--&gt; &lt;version&gt;5.2.24.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 依赖传递与依赖冲突问题依赖传递 这个jar包下面还包含有其他的jar包： image-20230622165753892 会发现有两个maven_03_pojo的依赖被加载到Dependencies中，那么maven_04_dao中的maven_03_pojo能不能使用呢？答案是可以的。 A依赖了B和C，B和C又分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递。 依赖传递有直接依赖和间接依赖（相对的概念）：相对于A来说，A直接依赖B和C，间接依赖了D1,E1,G,F,D2和E2。 依赖冲突 因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题。这里所说的依赖冲突是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。 情况一：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。 image-20230622170145521 情况二：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高。 情况三：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。 ​ 关于依赖冲突的规则我们不需要记住，可以在面板上查看详细的依赖关系包括版本信息等： 可选依赖和排除依赖maven_02_ssm 依赖了 maven_04_dao，maven_04_dao 依赖了 maven_03_pojo，因为现在有依赖传递，所以maven_02_ssm能够使用到maven_03_pojo的内容。但是如果说现在不想让maven_02_ssm依赖到maven_03_pojo，有哪些解决方案? 方案一：可选依赖 可选依赖指对外隐藏当前所依赖的资源。 对于我们的需求是：不想让maven_02_ssm依赖到maven_03_pojo。我们可以在maven_04_dao的pom.xml中在引入maven_03_pojo的时候，添加optional从而切断依赖传递。 1234567&lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;maven_03_pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 方案二：排除依赖 排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。 前面我们已经通过可选依赖实现了阻断maven_03_pojo的依赖传递。对于排除依赖，则是maven_02_ssm项目中已经通过依赖传递用到了maven_03_pojo，此时我们需要做的是将其进行排除。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;maven_04_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.Lijiacheng&lt;/groupId&gt; &lt;artifactId&gt;maven_03_pojo&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; A依赖B，B依赖C，C通过依赖传递会被A使用到，现在要想办法让A不去依赖C： 可选依赖是在B上设置&lt;optional&gt;， A不知道有C的存在； 排除依赖是在A上设置&lt;exclusions&gt;，A知道有C的存在，主动将其排除掉。 聚合和继承聚合 缺点一：分模块开发后，需要将这几个项目都安装到本地仓库，目前我们只能通过项目Maven面板的install来安装，并且需要安装多个，如果我们的项目足够多，那么一个个安装起来还是比较麻烦的。 缺点二：如果几个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他项目模块，我们需要对所有的模块进行重新编译。 解决方案：所以我们就想能不能抽取一个项目，把所有的项目管理起来，以后我们要想操作这些项目，只需要操作这一个项目，这就用到了我们接下来要讲解的聚合——将多个模块组织成一个整体，同时进行项目构建的过程称为聚合。聚合工程通常是一个不具有业务功能的空工程（有且仅有一个pom文件）。 当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。 步骤1：创建一个空的Maven工程 步骤2：将项目的打包方式改为pom 1234&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;maven_01_parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 目前我们接触到的项目打包方式有三种： ① jar：默认情况，说明该项目为java项目； ② war：说明该项目为web项目； ③ pom：说明该项目为聚合或继承项目。 步骤3：pom.xml添加所要管理的项目 123456&lt;!--设置管理的模块名称--&gt;&lt;modules&gt; &lt;module&gt;../maven_02_ssm&lt;/module&gt; &lt;module&gt;../maven_03_pojo&lt;/module&gt; &lt;module&gt;../maven_04_dao&lt;/module&gt;&lt;/modules&gt; 步骤4：使用聚合统一管理项目 image-20230623093529641 测试发现，当maven_01_parent的compile被点击后，所有被其管理的项目都会被执行编译操作，这就是聚合工程的作用。 说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序，和配置的顺序无关。 继承接下来我们再来考虑多模块开发存在的另外一个问题，依赖的重复配置。 问题一：spring-webmvc、spring-jdbc在三个项目模块中都有出现，这样就出现了重复的内容； 问题二：spring-test只在部分项目模块中出现，而在某些项目模块中没有出现，这里是部分重复的内容； 问题三：我们使用的spring版本目前是5.2.24.RELEASE ,假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高。 面对上面的这些问题，我们就得用到接下来要学习的继承（简化配置、减少版本冲突）：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。 步骤1：创建一个空Maven工程并将打包方式设置为pom 步骤2：在子项目中设置其父项目 java里面的继承，也是在子类声明它继承的父类。 1234567&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;maven_01_parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 可选项：设置父项目pom.xml位置路径 --&gt; &lt;relativePath&gt;../maven_01_parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 步骤3：优化子项目共有依赖导入问题 1）将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中 2）删除子项目中已经被抽取到父项目的pom.xml中的jar包，如在maven_02_ssm的pom.xml中将已经出现在父项目的jar包删除掉 将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。 步骤4：优化子项目依赖版本问题 如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。 那针对于这种部分项目有的jar包，我们该如何管理优化呢? 在父工程mavne_01_parent的pom.xml来定义依赖管理&lt;dependencyManagement&gt; 1234567891011&lt;!-- 定义依赖管理--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; &lt;dependencyManagement&gt;标签不真正引入jar包，而是配置可供子项目选择的jar包依赖。子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定&lt;version&gt; 。 这样做的好处就是当父工程dependencyManagement标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化。 继承总结：父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源 1）将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发 2）将所有项目的jar包配置到父工程的dependencyManagement标签下，实现版本管理，方便维护 聚合和继承的区别聚合和继承的区别聚合用于快速构建项目，对项目进行管理；继承用于快速配置和管理子项目中所使用jar包的版本。 聚合和继承的相同点 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 聚合和继承的不同点 聚合是在当前模块中配置关系&lt;modules&gt;，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系&lt;parent&gt;，父模块无法感知哪些子模块继承了自己 IDEA构建聚合与继承工程步骤1：创建一个空的Maven项目，可以将项目中的src目录删除掉，这个项目作为聚合工程和父工程 步骤2：创建子项目，该项目可以继承并聚合父工程。 属性属性如果我们现在想更新Spring的版本，你会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。我们可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方，就会跟着修改。 步骤1：父工程中定义属性 123&lt;properties&gt; &lt;spring.version&gt;5.2.24.RELEASE&lt;/spring.version&gt;&lt;/properties&gt; 步骤2：修改依赖的version 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护。 配置文件的属性加载想让Maven对于属性的管理范围能更大些，比如我们之前项目中的jdbc.properties，这个配置文件中的属性，能不能也来让Maven进行管理呢？ 步骤1：父工程定义属性 123&lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;&lt;/properties&gt; 步骤2：jdbc.properties文件中引用属性 在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性. 1jdbc.url=$&#123;jdbc.url&#125; 步骤3：设置maven过滤文件范围 Maven在默认情况下是从当前项目的”src\\main\\resources”下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。 12345678910&lt;build&gt; &lt;!-- 设置maven过滤文件范围 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;../maven_02_ssm/src/main/resources&lt;/directory&gt; &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 步骤4：测试是否生效 测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为父工程中Maven配置的内容。 image-20230623125438205 如果不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢？ 方式一：使用多个&lt;resource&gt;标签在下面继续配置； 方式二：$&#123;project.basedir&#125;，当前项目所在目录。子项目继承了父项目， 相当于所有的子项目都添加了资源目录的过滤： 1234567891011&lt;build&gt; &lt;!-- 设置maven过滤文件范围 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- &lt;directory&gt;../maven_02_ssm/src/main/resources&lt;/directory&gt;--&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main.resources&lt;/directory&gt; &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 上面我们所使用的都是Maven的自定义属性，除了$&#123;project.basedir&#125;，它属于Maven的内置系统属性。 多环境配置与应用多环境开发 不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，要想实现不同环境之间的配置切换又该如何来实现呢？ Maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。 步骤1：父工程配置多个环境，并指定默认激活环境： 12345678910111213141516171819202122232425262728&lt;!-- 多开发环境配置 --&gt;&lt;profiles&gt; &lt;profile&gt; &lt;!-- 开发环境 --&gt; &lt;id&gt;env_dep&lt;/id&gt; &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;!--设定是否为默认启动环境--&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 生产环境 --&gt; &lt;id&gt;env_pro&lt;/id&gt; &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;env_test&lt;/id&gt; &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢? 步骤2：命令行实现环境切换（这里我反正是测试失败了。。。） 跳过测试前面在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test，对于test来说有它存在的意义：可以确保每次打包或者安装的时候，程序的正确性。但是有时候，功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。 方式一：IDEA工具 image-20230623132550500 方式二：命令行跳过测试 1mvn 指令 -D skipTests 该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。 私服公司或者团队一般会搭建自己的私服，这里暂时先不展开实践了，就简单了解一下什么是私服以及配置私服的原理。 Maven的中央仓库不允许私人上传自己的jar包，那么自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用。私服就是公司内部搭建的用于存储Maven资源的服务器，用于解决团队内部的资源共享与资源同步问题。 搭建Maven私服的方式有很多，其中一种使用量比较大的实现方式：Nexus。","tags":[]},{"title":"03-SSM整合","date":"2023-06-19T03:40:18.000Z","path":"2023/06/19/03-SSM整合/","text":"前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发。 SSM整合流程分析创建工程1、创建Maven的Web工程 2、在pom.xml中导入SSM需要的依赖jar包： ​ ① SpringMVC的核心依赖spring-webmvc ​ ② Spring和jdbc、mybatis的依赖spring-test, spring-jdbc , mybatis-spring, mybatis 这里要注意Spring和jdk的版本兼容问题：当使用java8时，webmvc、test、jdbc保持版本一致且5.2.x以下的版本，mybatis-spring要保持2.x的版本。 ​ ③ 数据库mysql和数据库连接池Druid ​ ④ Servlet（使用java8时要用4.0.1以下的版本） ​ ⑤ 其他：jackson自动解析json格式数据，juint测试依赖 3、编写Web项目的入口配置类ServletInitConfig，实现AbstractAnnotationConfigDispatcherServletInitializer并重写以下方法： ​ ① getRootConfigClasses() ：返回Spring的配置类-&gt;需要SpringConfig配置类 ​ ② getServletConfigClasses() ：返回SpringMVC的配置类-&gt;需要SpringMvcConfig配置类 ​ ③ getServletMappings() : 设置SpringMVC请求拦截路径规则 ​ ④ getServletFilters() （这个要记住函数名因为没有快捷override方式）：设置过滤器，解决POST请求中文乱码问题 SSM整合1、SpringConfig ​ ① 标识该类为配置类 @Configuration ​ ② 扫描Service所在的包 @ComponentScan ​ ③ 在Service层要管理事务 @EnableTransactionManagement ​ ④ 读取外部的properties配置文件 @PropertySource ​ ⑤ 整合Mybatis需要引入Mybatis相关配置类 @Import 1234567@Configuration@ComponentScan(&#123;&quot;com.Lijiacheng.service&quot;&#125;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;MybatisConfig.class, JdbcConfig.class&#125;)@EnableTransactionManagementpublic class SpringConfig &#123;&#125; ​ 1) 第三方数据源配置类 JdbcConfig：构建DataSource数据源DruidDataSouroce，需要注入数据库连接四要素，@Bean和@Value注解。构建平台事务管理器DataSourceTransactionManager，@Bean注解。 1234567891011121314151617181920212223242526public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; // 创建jdbc事务管理 @Bean public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager ds = new DataSourceTransactionManager(); ds.setDataSource(dataSource); return ds; &#125;&#125; ​ 2) Mybatis配置类 MybatisConfig：构建SqlSessionFactoryBean并设置别名扫描与数据源，@Bean注解。构建MapperScannerConfigurer并设置DAO层的包扫描，@Bean注解。 123456789101112131415public class MybatisConfig &#123; @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setTypeAliasesPackage(&quot;com.Lijiacheng.domain&quot;); return sqlSessionFactoryBean; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.Lijiacheng.dao&quot;); return msc; &#125;&#125; 2、SpringMvcConfig ​ ① 标识该类为配置类 @Configuration ​ ② 扫描Controller所在的包 @ComponentScan ​ ③ 开启SpringMVC注解支持 @EnableWebMvc 12345@Configuration@ComponentScan(&quot;com.Lijiacheng.controller&quot;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; 功能模块1、创建数据库表 2、根据数据库表创建对应的模型类 3、通过Dao层完成数据库表的增删改查（接口+自动代理） 4、编写Service层（Service接口+实现类）：@Service, @Transactional；整合Junit对业务层进行单元测试@RunWith, @ContextConfiguration, @Test 5、编写Controller层：@RestController；接收请求(@RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping)；接收数据(@RequestParam, @PathVariable, @RequestBody)；转发业务层@Autowired 整合配置步骤1：创建项目包结构 ​ 步骤2：创建SpringConfig配置 12345678@Configuration@ComponentScan(&#123;&quot;com.Lijiacheng.service&quot;&#125;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;MybatisConfig.class, JdbcConfig.class&#125;)// 创建事务管理@EnableTransactionManagementpublic class SpringConfig &#123;&#125; 步骤3：创建JdbcConfig配置类 1234567891011121314151617181920212223242526public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; // 创建jdbc事务管理 @Bean public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager ds = new DataSourceTransactionManager(); ds.setDataSource(dataSource); return ds; &#125;&#125; 步骤4：创建MybatisConfig配置类 123456789101112131415public class MybatisConfig &#123; @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setTypeAliasesPackage(&quot;com.Lijiacheng.domain&quot;); return sqlSessionFactoryBean; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.Lijiacheng.dao&quot;); return msc; &#125;&#125; 步骤5：创建jdbc.properties 在resources下提供jdbc.properties，设置数据库连接四要素 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm_db?useSSL=falsejdbc.username=rootjdbc.password=xxxxxxx 步骤6：创建SpringMvcConfig配置类 12345@Configuration@ComponentScan(&quot;com.Lijiacheng.controller&quot;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; 步骤7：创建Web项目入口ServletInitConfig配置类 12345678910111213141516public class ServletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;SpringMvcConfig.class&#125;; &#125; protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; protected Filter[] getServletFilters()&#123; CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(&quot;utf-8&quot;); return new Filter[]&#123;filter&#125;; &#125;&#125; 总结 Web项目入口配置类ServletInitConfig → SpringConfig配置类：扫描Service层、导入外部properties、导入JdbcConfig、MybatisConfig等配置类 ​ → SpringMvcConfig配置类：扫描Controller层 功能模块开发步骤1：编写pojo模型类 步骤2：编写Dao接口 12345678910111213141516public interface BookDao &#123; @Insert(&quot;insert into tbl_book values(null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;) public void save(Book book); @Delete(&quot;delete from tbl_book where id = #&#123;id&#125;&quot;) public void delete(Integer id); @Update(&quot;update tbl_book set type = #&#123;type&#125;, name = #&#123;name&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;) public void update(Book book); @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;) public Book getById(Integer id); @Select(&quot;select * from tbl_book&quot;) public List&lt;Book&gt; getAll();&#125; 步骤3：编写Service接口和实现类 123456789101112131415161718192021222324252627282930313233343536@Transactionalpublic interface BookService &#123; public boolean save(Book book); public boolean delete(Integer id); public boolean update(Book book); public Book getById(Integer id); public List&lt;Book&gt; getAll();&#125;/** ======================================================== */@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; public boolean save(Book book) &#123; bookDao.save(book); return true; &#125; public boolean delete(Integer id) &#123; bookDao.delete(id); return true; &#125; public boolean update(Book book) &#123; bookDao.update(book); return true; &#125; public Book getById(Integer id) &#123; return bookDao.getById(id); &#125; public List&lt;Book&gt; getAll() &#123; return bookDao.getAll(); &#125;&#125; bookDao在Service中注入的会提示一个红线提示：这是因为BookDao是一个接口，没有实现类，接口是不能创建对象的，所以最终注入的应该是代理对象。而代理对象是由Spring的IOC容器来创建管理的，IOC容器又是在Web服务器启动的时候才会创建，没有找到适合的类注入所以会提示错误提示。 image-20230619221050923 不去理会当然可以正常运行程序，但作为追求完美的强迫症程序员，可以设置IDEA的错误提示级别： image-20230619221318810 在这里取消勾选，或者将其降级为warning级别都可以： image-20230619221402465 步骤4：编写Controller类 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123; @Autowired private BookService bookService; @PostMapping public boolean save(@RequestBody Book book) &#123; return bookService.save(book); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public boolean delete(@PathVariable Integer id) &#123; return bookService.delete(id); &#125; @PutMapping public boolean update(@RequestBody Book book) &#123; return bookService.update(book); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Book getById(@PathVariable Integer id) &#123; return bookService.getById(id); &#125; @GetMapping public List&lt;Book&gt; getAll() &#123; return bookService.getAll(); &#125;&#125; 单元测试对于图书模块的增删改查就已经完成了编写，接下来我们就先把业务层Service的代码使用Spring整合Junit进行单元测试： 步骤1：新建测试类 步骤2：注入Service类 步骤3：编写测试方法 123456789101112131415161718@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class BookServiceTest &#123; @Autowired private BookService bookService; @Test public void testGetById()&#123; Book book = bookService.getById(1); System.out.println(book); &#125; @Test public void testGetAll()&#123; List&lt;Book&gt; books = bookService.getAll(); System.out.println(books); &#125;&#125; Service层的代码测试成功，结果就不在这放嘞，接着往下看。 PostMan测试新增 前端发送新增请求： 后台数据库： image-20230619223001724 修改 前端发送修改请求： 后台数据库： image-20230619223124913 删除 前端发送删除请求： 后台数据库： image-20230619223300861 查询 前端发送查询请求： 统一结果封装表现层与前端数据传输协议定义在Controller层增删改返回给前端的是boolean类型数据、在Controller层查询单个返回给前端的是对象、在Controller层查询所有返回给前端的是集合对象……对于前端来说，如果后台能够返回一个统一的数据结果，前端在解析的时候就可以按照一种方式进行解析，开发就会变得更加简单。 所以我们就想能不能将返回结果的数据进行统一，具体如何来做，大体的思路为: 为了封装返回的结果数据：创建结果模型类，封装数据到data属性中 为了封装返回的数据是何种操作及是否操作成功：封装操作结果到code属性中 操作失败后为了封装返回的错误信息：封装特殊消息到message(msg)属性中 解决方案是我们可以设置统一数据返回结果类，Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作： 表现层与前端数据传输协议实现步骤1：创建Result类 1234567891011121314151617public class Result &#123; // 描述统一格式中的数据 private Integer code; // 描述统一格式中的编码 private Object data; // 描述统一格式中的消息，可选属性 private String msg; public Result(Integer code, Object data) &#123; this.code = code; this.data = data; &#125; public Result(Integer code, Object data, String msg) &#123; this.code = code; this.data = data; this.msg = msg; &#125;&#125; 步骤2：定义返回码Code类 12345678910public class Code &#123; public static final Integer SAVE_OK = 20011; public static final Integer DELETE_OK = 20021; public static final Integer UPDATE_OK = 20031; public static final Integer GET_OK = 20041; public static final Integer SAVE_ERR = 20010; public static final Integer DELETE_ERR = 20020; public static final Integer UPDATE_ERR = 20030; public static final Integer GET_ERR = 20040;&#125; 步骤3：修改Controller类的返回值为Result对象 1234567891011121314151617181920212223242526272829@PostMappingpublic Result save(@RequestBody Book book) &#123; boolean flag = bookService.save(book); return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);&#125;@DeleteMapping(&quot;/&#123;id&#125;&quot;)public Result delete(@PathVariable Integer id) &#123; boolean flag = bookService.delete(id); return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);&#125;@PutMappingpublic Result update(@RequestBody Book book) &#123; boolean flag = bookService.update(book); return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);&#125;@GetMapping(&quot;/&#123;id&#125;&quot;)public Result getById(@PathVariable Integer id) &#123; Book book = bookService.getById(id); Integer code = book != null ? Code.GET_OK : Code.GET_ERR; String msg = book != null ? &quot;&quot; : &quot;未查询到信息，请重试&quot;; return new Result(code, book, msg);&#125;@GetMappingpublic Result getAll() &#123; List&lt;Book&gt; books = bookService.getAll(); Integer code = books != null ? Code.GET_OK : Code.GET_ERR; String msg = books != null ? &quot;&quot; : &quot;未查询到信息，请重试&quot;; return new Result(code, books, msg);&#125; 至此，我们的返回结果就已经能以一种统一的格式返回给前端。前端根据返回的结果，先从中获取code，根据code判断，如果成功则取data属性的值；如果失败则取msg中的值做提示（随便举一个根据id查询的例子）： 统一异常处理异常处理概述当我们在表现Controller层的getById方法中手动添加一个异常，可以发现在前端发送请求时出现接收到的信息和之前约定的数据格式不一致的问题： 我们在开发的过程中在任何一个位置都可能会出现异常。 框架内部抛出的异常：因使用不合规导致 数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时） 业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等） 表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常） 工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等） 各个层级均出现异常，异常处理代码书写在哪一层？所有的异常均抛出到表现层进行处理 异常的种类很多，表现层如何将所有的异常都处理到呢？异常分类 表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决？AOP 针对上述的问题，SpringMVC已经为我们提供了一套异常处理器的解决方案，集中的统一的处理项目中出现的异常。 1234567@RestControllerAdvicepublic class ProjectExceptionAdvice &#123; @ExceptionHandler(Exception.class) public Result doException(Exception ex)&#123; return new Result(666, null); &#125;&#125; 异常处理器的使用步骤1：创建异常处理器类 要确保SpringMvcConfig能够扫描到异常处理器类 123456789// @RestControllerAdvice用于标识当前类为REST风格对应的异常处理器@RestControllerAdvicepublic class ProjectExceptionAdvice &#123; //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常 @ExceptionHandler(Exception.class) public void doException(Exception ex)&#123; System.out.println(&quot;嘿嘿，异常你往哪里跑！&quot;); &#125;&#125; 步骤2：让程序抛出异常 步骤3：运行程序测试（异常已经被拦截并执行了doException方法） image-20230620102849723 步骤4：异常处理器类返回结果给前端 12345@ExceptionHandler(Exception.class) public Result doException(Exception ex)&#123; System.out.println(&quot;嘿嘿，异常你往哪里跑！&quot;); return new Result(666, null, &quot;呵呵，异常你往哪里跑！&quot;); &#125; image-20230620103149866 就算后台执行的过程中抛出异常，最终也能按照我们和前端约定好的数据格式返回给前端。 @RestControllerAdvice注解：此注解自带@ResponseBody注解与@Component注解，REST风格的(异常处理)控制器类。 @ExceptionHandler注解：专用于异常处理的控制器方法上方，出现异常后终止原始控制器执行，并转入当前方法执行。 项目异常处理方案异常分类因为异常的种类有很多，如果每一个异常都对应一个@ExceptionHandler，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类。 业务异常(BusinessException) 用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串； 不规范的用户行为操作产生的异常，如用户故意传递错误数据。 系统异常(SystemException) ​ 项目运行过程中可预计但无法避免的异常，比如数据库或服务器宕机。 其他异常(Exception) ​ 编程人员未预期到的异常，如:用到的文件不存在。 将异常分类以后，针对不同类型的异常，要提供具体的解决方案。 异常解决方案 业务异常（BusinessException） ​ 发送对应消息传递给用户，提醒规范操作（大家常见的就是提示用户名已存在或密码格式不正确等） 系统异常（SystemException） ​ 发送固定消息传递给用户，安抚用户（系统繁忙，请稍后再试） ​ 发送特定消息给运维人员，提醒维护（可以发送短信、邮箱或者是公司内部通信软件） ​ 记录日志（发消息和记录日志对用户来说是不可见的，属于后台程序） 其他异常（Exception） ​ 发送固定消息传递给用户，安抚用户 ​ 发送特定消息给编程人员，提醒维护（纳入预期范围内） ​ 记录日志（一般是程序没有考虑全，比如未做非空校验等） 异常解决方案的具体实现 思路： 先通过自定义异常，完成BusinessException和SystemException的定义 将其他异常包装成自定义异常类型 在异常处理器类中对不同的异常进行处理 步骤1：自定义异常类（新建一个exception包目录） 12345678910111213141516171819202122public class SystemException extends RuntimeException&#123; private Integer code; public SystemException() &#123; &#125; public SystemException(Integer code, String message) &#123; super(message); this.code = code; &#125; public SystemException(Integer code, String message, Throwable cause) &#123; super(message, cause); this.code = code; &#125; public SystemException(Integer code) &#123; this.code = code; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125; 让自定义异常类继承RuntimeException的好处是，后期在抛出这两个异常的时候，就不用try…catch…或throws了。 自定义异常类中添加code属性的原因是为了更好的区分异常是来自哪个业务的。 步骤1.5：在Code类中再新增需要的属性 步骤2：将其他异常包装成自定义异常 具体的包装方式有两种： 方式一：try{…}catch(){…}在catch中重新throw我们自定义异常即可； 方式二：直接throw自定义异常即可； 123456789101112131415161718@GetMapping(&quot;/&#123;id&#125;&quot;)public Result getById(@PathVariable Integer id) &#123; //模拟业务异常，包装成自定义异常 if(id == 1)&#123; throw new BusinessException(Code.BUSINESS_ERR, &quot;请不要用你的技术挑战我的饭碗！&quot;); &#125; //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常 try &#123; int i = 1 / 0; &#125;catch (Exception e)&#123; throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,&quot;服务器访问超时，请重试！&quot;, e); &#125; Book book = bookService.getById(id); Integer code = book != null ? Code.GET_OK : Code.GET_ERR; String msg = book != null ? &quot;&quot; : &quot;未查询到信息，请重试&quot;; return new Result(code, book, msg);&#125; 步骤3：处理器类中处理自定义异常 1234567891011121314151617181920212223242526// @RestControllerAdvice用于标识当前类为REST风格对应的异常处理器@RestControllerAdvicepublic class ProjectExceptionAdvice &#123; // @ExceptionHandler用于设置当前处理器类对应的异常类型 @ExceptionHandler(SystemException.class) public Result doSystemException(SystemException ex)&#123; //记录日志 // 发送消息给运维 // 发送邮件给开发人员,ex对象发送给开发人员 return new Result(ex.getCode(), null, ex.getMessage()); &#125; @ExceptionHandler(BusinessException.class) public Result doBusinessException(BusinessException ex)&#123; return new Result(ex.getCode(), null, ex.getMessage()); &#125; //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常 @ExceptionHandler(Exception.class) public Result doException(Exception ex)&#123; // 记录日志 // 发送消息给运维 // 发送邮件给开发人员,ex对象发送给开发人员 return new Result(Code.SYSTEM_UNKNOWN_ERR, null, &quot;系统繁忙，请稍后再试！&quot;); &#125;&#125; 步骤4：进行异常测试 在根据id查询中，如果查询请求id为1报错BusinessException错，如果id不为1则报SystemException错。 对于异常我们就已经处理完成了。不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。 小结 项目中的异常处理方式为： 前后台协议联调 因为添加了静态资源，SpringMVC会拦截，所以需要将静态资源进行放行： 复习一下如何将静态资源放行？ 1）新建SpringMvcSupport配置类，继承WebMvcConfigurationSupport，重写addResourceHandlers方法。 2）在SpringMvcConfig中扫描SpringMvcSupport 列表功能 页面加载完后发送异步请求到后台获取列表数据进行展示。 1234567//列表getAll() &#123; // 发送ajax请求 axios.get(&quot;/books&quot;).then((res)=&gt;&#123; this.dataList = res.data.data; &#125;);&#125;, 添加功能 “新建”按钮上绑定了@click=”handleCreate()”方法；在method中找到handleCreate方法，方法中打开”新增“面板。 ”确定”按钮上绑定了@click=”handleAdd()”方法；在method中找到handleAdd方法，在方法中发送请求和数据，响应成功后将新增面板关闭并重新查询数据。 12345678910111213//弹出添加窗口handleCreate() &#123; this.dialogFormVisible = true;&#125;,//添加handleAdd () &#123; //发送ajax请求 // this.formData是表单中的数据，最后是一个json数据 axios.post(&quot;/books&quot;, this.formData).then((res)=&gt;&#123; this.dialogFormVisible = false; // 关闭弹窗 this.getAll(); // 刷新显示全部 &#125;)&#125;, image-20230620231613537 但是我们发现在新增成功后，再次点击新增按钮会发现之前的数据还存在，这个时候就需要在新增的时候将表单内容清空。 123456789//弹出添加窗口handleCreate() &#123; this.dialogFormVisible = true; this.resetForm();&#125;,//重置表单resetForm() &#123; this.formData = &#123;&#125;;&#125;, 添加功能状态处理 新增成功是关闭面板，重新查询数据，但是我们还需要考虑新增失败的异常情况：即在handlerAdd方法中根据后台返回的数据来进行不同的处理。 123456789101112131415161718192021//添加handleAdd () &#123; //发送ajax请求 axios.post(&quot;/books&quot;, this.formData).then((res)=&gt;&#123; // 如果请求成功，则关闭弹层，显示数据 if(res.data.code == 20011)&#123; this.dialogFormVisible = false; // 关闭弹窗 this.$message.success(&quot;添加成功！&quot;); &#125; // 如果请求失败，则弹窗提醒 else if(res.data.code == 20010)&#123; this.$message.error(&quot;添加失败！&quot;); &#125; // 其他的未知异常 else&#123; this.$message.error(res.data.msg); &#125; &#125;).finally(()=&gt;&#123; this.getAll(); &#125;)&#125;, 修改功能 “编辑”按钮绑定了@click=”handleUpdate(scope.row)”；在method的handleUpdate方法中发送异步请求根据ID查询图书信息。根据后台返回的结果，判断是否查询成功：如果查询成功打开修改面板回显数据，如果失败提示错误信息。 修改完成后“确定”按钮绑定了@click=”handleEdit()”，在method的handleEdit方法中发送异步请求提交修改数据。 12345678910111213141516171819202122232425262728//弹出编辑窗口handleUpdate(row) &#123; axios.get(&quot;/books/&quot; + row.id).then((res)=&gt;&#123; // 展示弹层，加载数据 if(res.data.code == 20041)&#123; this.formData = res.data.data; this.dialogFormVisible4Edit = true; &#125; else&#123; this.$message.error(res.data.msg); &#125; &#125;)&#125;,//编辑handleEdit() &#123; axios.put(&quot;/books&quot;, this.formData).then((res)=&gt;&#123; // 如果操作成功，关闭弹层，显示数据 if(res.data.code == 20031)&#123; this.dialogFormVisible4Edit = false; this.$message.error(&quot;修改成功！&quot;); &#125; else if(res.data.code == 20030)&#123; this.$message.error(&quot;修改失败！&quot;); &#125; else&#123; this.$message.error(res.data.msg); &#125; &#125;).finally(()=&gt;&#123; this.getAll(); &#125;)&#125;, 删除功能 ”删除“按钮上绑定了@click=”handleDelete(scope.row)”，method的handleDelete方法弹出提示框。 1234567891011121314151617181920// 删除handleDelete(row) &#123; this.$confirm(&quot;此操作永久删除当前数据，是否继续？&quot;,&quot;提示&quot;,&#123; type:&#x27;info&#x27; &#125;).then(()=&gt;&#123; //2.做删除业务 axios.delete(&quot;/books/&quot;+row.id).then((res)=&gt;&#123; if(res.data.code == 20021)&#123; this.$message.success(&quot;删除成功&quot;); &#125;else&#123; this.$message.error(&quot;删除失败&quot;); &#125; &#125;).finally(()=&gt;&#123; this.getAll(); &#125;); &#125;).catch(()=&gt;&#123; //3.取消删除 this.$message.info(&quot;取消删除操作&quot;); &#125;);&#125; 拦截器拦截器概念 (1) 浏览器发送一个请求会先到Tomcat的web服务器； (2) Tomcat服务器接收到请求以后，会去判断请求的是静态资源还是动态资源； (3) 如果是静态资源，会直接到Tomcat的项目部署目录下去直接访问； (4) 如果是动态资源，就需要交给项目的后台代码进行处理； (5) 在找到具体的方法之前，我们可以去配置过滤器(可以配置多个)，按照顺序进行执行； (6) 然后进入到到中央处理器(SpringMVC中的内容)，SpringMVC会根据配置的规则进行拦截； (7) 如果满足规则，则进行处理，找到其对应的controller类中的方法进行执行，完成后返回结果； (8) 如果不满足规则，则不进行处理； (9) 这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现？——拦截器 拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行：在指定的方法调用前后执行预先设定的代码来阻止原始方法的执行。 SpringMVC的拦截器和Servlet的过滤器的区别： 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术； 拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强。 拦截器入门案例环境准备 拦截器开发步骤1：在controller表现层创建拦截器类 让类实现HandlerInterceptor接口，重写接口中的三个方法。同时要注意Interceptor类必须受Spring容器控制和被SpringMVC扫描到。 12345678910111213141516@Component // 注意当前类必须受Spring容器控制// 定义拦截器类，实现HandlerInterceptor接口public class ProjectInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle...&quot;); return true; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle...&quot;); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion...&quot;); &#125;&#125; 步骤2：配置拦截器类 12345678910111213141516@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor projectInterceptor; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;); &#125; // 配置拦截器 @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;); &#125;&#125; 自动装配前面创建的拦截器类，在Support配置中配置拦截的路径。 步骤3：SpringMvcConfig添加SpringMvcSupport包(config包下)扫描 当拦截器拦截的路径是(“/books”)时，则发送http://localhost/books/100会发现拦截器没有被执行， 因为没有匹配上，想要拦截则要设置”/books/*”。 当有拦截器后，请求会先进入preHandle方法，如果方法返回true，则放行继续执行后面的handle（controller的方法）和后面的方法；如果返回false，则直接跳过后面方法的执行。 （可选）步骤4：简化SpringMvcSupport的编写 在SpringMvcConfig中实现WebMvcConfigurer接口后面就不用写SpringMvcSupport配置类了，但具有一定的侵入性。 拦截器参数前置处理方法 request：请求对象 response：响应对象 handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装 使用request对象可以获取请求数据中的内容，如获取请求头的Content-Type（要使用post请求）： 12345public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String contentType = request.getHeader(&quot;Content-Type&quot;); System.out.println(&quot;preHandle...&quot; + contentType); return true;&#125; 使用handler参数，可以获取方法的相关信息： 1234567public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String contentType = request.getHeader(&quot;Content-Type&quot;); HandlerMethod hm = (HandlerMethod) handler; String methodName = hm.getMethod().getName(); //可以获取方法的名称 System.out.println(&quot;preHandle...&quot; + contentType + &quot;, &quot; + methodName); return true;&#125; 后置处理方法 原始方法运行后运行，如果原始方法被拦截，则不执行。 modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整。因为现在都是返回json数据，所以该参数的使用率不高。 完成处理方法 拦截器最后执行的方法，无论原始方法是否执行。 ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理。因为现在已经有全局异常处理器类，所以该参数的使用率也不高。 总结 这三个方法中，最常用的是preHandle，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截。 拦截器链配置步骤1：创建多个拦截器类ProjectInterceptor1、ProjectInterceptor2… 步骤2：配置拦截器链 拦截器执行的顺序是和配置顺序有关：先进后出（preHandle是与配置顺序相同，必定运行的）。 执行过程：当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行；当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作，见下图所示：","tags":[]},{"title":"02-RESTful开发","date":"2023-06-13T03:18:31.000Z","path":"2023/06/13/02-RESTful开发/","text":"REST（Representational State Transfer），表现形式状态转换，它是一种软件架构风格，听不懂很正常。说通俗点就是用URL定位资源，用HTTP动词（GET, POST, DELETE, PUT）描述操作的一种开发方式。 REST简介当我们想表示一个网络资源的时候，可以使用两种方式： （1）传统风格资源描述形式 ​ ① http://localhost/user/getById?id=1 查询id为1的用户信息 ​ ② http://localhost/user/saveUser 保存用户信息 （2）REST风格描述形式 ​ ① http://localhost/users/1 ​ ② http://localhost/users 传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全，因为会程序的人读取了你的请求url地址，就大概知道该url实现的是一个什么样的操作。 所以REST的优点有: 隐藏资源的访问行为，无法通过地址得知对资源是何种操作 书写简化 那么对于REST来说，一个相同的url地址即可以是新增也可以是修改或者查询，那么到底我们该如何区分该请求到底是什么操作呢? 按照REST风格访问资源时使用的行为动作（一共有8种，常用的只有以下4种）区分对资源进行了何种操作： http://localhost/users 查询全部用户信息 GET（查询） http://localhost/users/1 查询指定用户信息 GET（查询） http://localhost/users 添加用户信息 POST（新增/保存） http://localhost/users 修改用户信息 PUT（修改/更新） http://localhost/users/1 删除用户信息 DELETE（删除） 按照不同的请求方式代表不同的操作类型：发送GET请求是用来做查询；发送POST请求是用来做新增；发送PUT请求是用来做修改；发送DELETE请求是用来做删除。 REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性。 上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范。REST中规定GET/POST/PUT/DELETE针对的是查询/新增/修改/删除，但是我们如果非要用GET请求做删除，这点在程序上运行是可以实现的，但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。 根据REST风格对资源进行访问称为RESTful，所以可以说以后都是基于RESTful来进行开发的。 RESTful入门案例环境准备 思路分析将之前的增删改查替换成RESTful开发方式： 之前不同的请求有不同的路径，现在要将其修改成统一的请求路径 修改前：新增: /save ，修改: /update，删除 /delete … 修改后：增删改查: /users 根据GET查询、POST新增、PUT修改、DELETE删除对方法的请求方式进行限定 修改RESTful风格新增 请求路径更改为/users，并且使用method属性限定该方法的访问方式为POST： 123456789/** * 设置当前请求方法为POST，表示REST风格中的添加操作 * */ @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST) @ResponseBody public String save(User user)&#123; System.out.println(&quot;user save...&quot; + user); return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;; &#125; 删除 对于RESTful开发，如何携带数据参数？ 前端发送请求的时候使用：http://localhost/users/1 ，路径中的1就是我们想要传递的参数。 后端获取参数，需要做如下修改：① 修改@RequestMapping的value属性，将其中修改为/users/&#123;id&#125;，目的是和路径匹配；② 在方法的形参前添加@PathVariable注解。 12345678910 /** * 设置当前请求方法为DELETE，表示REST风格中的删除操作 * */ @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE) @ResponseBody// public String delete(@PathVariable(&quot;id&quot;) Integer userid)&#123; public String delete(@PathVariable Integer id)&#123; System.out.println(&quot;user delete...&quot; + id); return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;; &#125; 如果方法形参的名称和路径{}中的值不一致： 如果有多个参数需要传递该如何编写： 1public String delete(@PathVariable Integer id,@PathVariable String name) 修改 123456789/** * 设置当前请求方法为PUT，表示REST风格中的修改操作 * */ @RequestMapping(value = &quot;/users&quot;,method = RequestMethod.PUT) @ResponseBody public String update(@RequestBody User user)&#123; System.out.println(&quot;user update...&quot; + user); return &quot;&#123;&#x27;module&#x27;:&#x27;user update&#x27;&#125;&quot;; &#125; 复习一下：只有在请求参数是json格式的时候，才需要在control方法的形参前加@RequestBody注解。 根据ID查询 123456789/** * 设置当前请求方法为GET，表示REST风格中的查询操作 * */ @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.GET) @ResponseBody public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;user getById...&quot; + id); return &quot;&#123;&#x27;module&#x27;:&#x27;user getById&#x27;&#125;&quot;; &#125; 查询全部 123456@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.GET) @ResponseBody public String getAll()&#123; System.out.println(&quot;user getAll...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;user getAll&#x27;&#125;&quot;; &#125; RESTful入门开发总结 设定Http请求动作(method动词) 1@RequestMapping(value=&quot;&quot;,method = RequestMethod.POST|GET|PUT|DELETE) 设定请求参数(路径变量) 1234@RequestMapping(value=&quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)@ReponseBodypublic String delete(@PathVariable Integer id)&#123;&#125; 三大接收参数@RequestBody、@RequestParam、@PathVariable： 区别： (1) @RequestParam用于接收url地址传参或表单传参； (2) @RequestBody用于接收json数据； (3) @PathVariable用于接收路径参数，使用参数名称描述路径参数； 应用： (1) 如果发送非json格式数据，选用@RequestParam接收请求参数； (2) 后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广； (3) 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值； RESTful快速开发简化前面RESTful入门开发的繁琐流程： 每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高：将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。 每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高：使用@GetMapping @PostMapping @PutMapping @DeleteMapping代替。 每个方法响应json都需要加上@ResponseBody注解，重复性太高：将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能；使用@RestController注解替换@Controller与@ResponseBody注解，简化书写。 1234567891011121314151617181920212223242526272829@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123; @PostMapping public String save(@RequestBody Book book)&#123; System.out.println(&quot;book save...&quot; + book); return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; System.out.println(&quot;book delete...&quot; + id); return &quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;; &#125; @PutMapping public String update(@RequestBody Book book)&#123; System.out.println(&quot;book update...&quot; + book); return &quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;; &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;book getById...&quot; + id); return &quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;book getAll...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;; &#125;&#125; RESTful案例此次案例的重点是在SpringMVC中如何使用RESTful实现前后台交互，所以本案例并没有和数据库进行交互，所有数据使用假数据来完成开发。 需求分析需求一：图书列表查询，从后台返回数据，将数据展示在页面上。 需求二：新增图书，将新增图书的数据传递到后台，并在控制台打印。 环境准备 后台接口开发步骤1：编写Controller类并使用RESTful进行配置 123456789101112131415161718192021222324252627@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123; // 查询全部 @GetMapping public List&lt;Book&gt; getAll()&#123; // 不与数据库进行交互，这里使用假数据 ArrayList&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); Book book1 = new Book(); book1.setName(&quot;C# primer&quot;); book1.setType(&quot;编程图书&quot;); book1.setDescription(&quot;C语言入门图书&quot;); bookList.add(book1); Book book2 = new Book(); book2.setName(&quot;计算机网络：自顶向下&quot;); book2.setType(&quot;计算机网络&quot;); book2.setDescription(&quot;计算机四大件之计算机网络&quot;); bookList.add(book2); return bookList; &#125; // 添加 @PostMapping public String save(@RequestBody Book book)&#123; System.out.println(&quot;book save =====&gt; &quot; + book); return &quot;&#x27;module&#x27;:&#x27;Book save successfully...&#x27;&quot;; &#125;&#125; 步骤2：使用PostMan进行测试 测试新增 测试查询全部 页面访问处理步骤1：拷贝静态页面 image-20230618165134339 步骤2：访问pages目录下的books.html image-20230618165232338 报错的原因是：SpringMVC拦截了静态资源，根据/pages/books.html去controller找对应的方法，找不到所以会报404的错误。 因为在ServletInitConfig配置文件中拦截了静态资源： 1234@Overrideprotected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;;&#125; 所以必须将静态资源在ServletInitConfig中进行放行：创建一个新的SpringMvcSupport配置类！ 123456789101112//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; protected void addResourceHandlers(ResourceHandlerRegistry registry)&#123; //当访问/pages/????时候，从/pages目录下查找内容 registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;); registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/css/&quot;); registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/js/&quot;); registry.addResourceHandler(&quot;/plugins/**&quot;).addResourceLocations(&quot;/plugins/&quot;); &#125;&#125; 该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改： 1@ComponentScan(&#123;&quot;com.Lijiacheng.controller&quot;,&quot;com.Lijiacheng.config&quot;&#125;) 步骤3：修改books.html页面 1234567891011//添加 saveBook () &#123; axios.post(&quot;/books&quot;,this.formData).then((res)=&gt;&#123; &#125;); &#125;,//主页列表查询 getAll() &#123; axios.get(&quot;/books&quot;).then((res)=&gt;&#123; this.dataList = res.data; &#125;); &#125;, image-20230618170855805 前端的新增图书请求到后端来接收： image-20230618171022178","tags":[]},{"title":"algorithm04 字符串","date":"2023-06-05T12:55:33.000Z","path":"2023/06/05/algorithm04-字符串/","text":"字符串比较简单，直接来看题目！ 基础知识字符串很简单，这里我就记录一下几个字符串、数组、char类型相互转化的方法。 toCharArray() String.ValueOf() 相关题目344. 反转字符串 image-20230605205843387 双指针，没什么可说的，重拳出击！ 12345678910class Solution &#123; public void reverseString(char[] s) &#123; int len = s.length; for(int left=0,right=len-1;left&lt;right;left++,right--)&#123; char temp = s[left]; s[left] = s[right]; s[right] = temp; &#125; &#125;&#125; 541. 反转字符串 II image-20230605210330082 这种题目属于模拟类问题，模拟类问题要进行明确的分情况讨论： 情况①：字符串剩余字符小于k个 → 全部翻转 情况②：字符串剩余字符大于等于k个，且少于2k个 → 翻转前k个 情况③：字符串剩余字符大于2k个 → 正常翻转前k个 1234567891011121314151617181920212223242526class Solution &#123; public String reverseStr(String s, int k) &#123; int len = s.length(); char[] chs = s.toCharArray(); for(int i=0;i&lt;len;i+=2*k)&#123; /** if(i+k &lt;= len)&#123; reverse(chs, i, i+k-1); &#125;else&#123; reverse(chs, i, len-1); &#125; */ reverse(chs, i, Math.min(i+k-1,len-1)); &#125; return String.valueOf(chs); &#125; public void reverse(char[] chs, int left, int right)&#123; while(left &lt; right)&#123; char temp = chs[left]; chs[left] = chs[right]; chs[right] = temp; left++; right--; &#125; &#125;&#125; 剑指 Offer 05. 替换空格 image-20230607113006876 写一个函数实现该方法：s.replace(&quot; &quot;, &quot;%20&quot;); 思路1：使用额外的空间 123456789101112131415class Solution &#123; public String replaceSpace(String s) &#123; String ans = &quot;&quot;; String[] strs = new String[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; if(&#x27; &#x27; == s.charAt(i))&#123; strs[i] = &quot;%20&quot;; &#125;else&#123; strs[i] = String.valueOf(s.charAt(i)); &#125; ans += strs[i]; &#125; return ans; &#125;&#125; 思路2：如果要将这道题做到极致，就不要用额外的辅助空间了 思路是用双指针，首先使用数组扩充为每个空格填充为”%20”之后的大小（java数组在创建之后不可以改变大小，但是cpp中vector的resize可以），然后从后向前（从前向后的话每次填充”%20”后都要将后面的数组元素向后移动）替换空格，i指向新长度的末尾，j指向旧长度的末尾。 151. 反转字符串中的单词 思路：和C++语言字符串可变的特性不同，Java语言的字符串是不可变的，所以必须要开辟可变的辅助空间来完成这道题目。主要采用的思路是这样的，先去掉字符串中多余的空格，再将整个数组倒置（这时每个单词也都是倒序的），再对每个单词的字母进行倒置，就完成了题目的要求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 class Solution &#123; public String reverseWords(String s) &#123; StringBuilder sb = trimSpaces(s); reverse(sb, 0 ,sb.length()-1); reverseEachWord(sb); return sb.toString().trim(); &#125; // 去除字符串多余的空格 public StringBuilder trimSpaces(String s)&#123; s = s.trim(); // 删除头尾的空白 int left = 0, right = s.length()-1; // 删除中间多余的空白 StringBuilder sb = new StringBuilder(); while(left &lt;= right)&#123; char c = s.charAt(left); if(c != &#x27; &#x27;)&#123; sb.append(c); &#125; else if(sb.charAt(sb.length()-1) != &#x27; &#x27;)&#123; sb.append(c); &#125; left++; &#125; return sb; &#125; // 将字符串倒序 public void reverse(StringBuilder sb, int left, int right)&#123; while(left &lt; right)&#123; char temp = sb.charAt(left); sb.setCharAt(left++, sb.charAt(right)); sb.setCharAt(right--, temp); &#125; &#125; // 将字符串中的每个单词倒序 public void reverseEachWord(StringBuilder sb)&#123; sb.append(&#x27; &#x27;); // 防止最后一个单词不被倒序 // 快慢指针法 int slow = 0, fast = 0; for(fast = 0;fast &lt; sb.length();fast++)&#123; if(sb.charAt(fast) == &#x27; &#x27;)&#123; reverse(sb, slow, fast-1); slow = fast + 1; &#125; &#125; &#125; &#125; 这是我初次做法，感觉也不错：单独把每个单词取出来放入一个list中，再倒序遍历。 12345678910111213141516171819202122class Solution &#123; public String reverseWords(String s) &#123; int start=0, end=0; ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;(); String ans = &quot;&quot;; for(end=0;end&lt;s.length();end++)&#123; if(&#x27; &#x27; == s.charAt(end) &amp;&amp; start == end)&#123; start++; &#125;else if(&#x27; &#x27; == s.charAt(end) &amp;&amp; start != end)&#123; lists.add(s.substring(start,end)); start = end + 1; &#125;else if(end == s.length()-1 &amp;&amp; s.charAt(end) != &#x27; &#x27;)&#123; lists.add(s.substring(start)); &#125; &#125; ans += lists.get(lists.size()-1); for(int i=lists.size()-2;i&gt;=0;i--)&#123; ans = ans + &quot; &quot; + lists.get(i); &#125; return ans; &#125;&#125; 剑指 Offer 58 - II. 左旋转字符串 image-20230621223954771 法一： 1234567class Solution &#123; public String reverseLeftWords(String s, int n) &#123; String startStr = s.substring(0,n); String endStr = s.substring(n); return endStr + startStr; &#125;&#125; 法二： 123456789101112class Solution &#123; public String reverseLeftWords(String s, int n) &#123; StringBuilder sb = new StringBuilder(); for(int i=n;i&lt;s.length();i++)&#123; sb.append(s.charAt(i)); &#125; for(int i=0;i&lt;n;i++)&#123; sb.append(s.charAt(i)); &#125; return sb.toString(); &#125;&#125; 字符串总结和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 StringBuilder的父类和String实现了相同的接口，所以StringBuilder可以使用String所有的方法，除此之外比较常用的有： 1）append 2）修改字符串的元素：setCharAt(索引，修改的元素)","tags":[]},{"title":"01-SpringMVC入门","date":"2023-06-05T02:39:50.000Z","path":"2023/06/05/01-SpringMVC入门/","text":"SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。 SpringMVC概述Web架构现在web程序大都基于三层架构来实现： 浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据； 如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利；将后端服务器Servlet拆分成三层，分别是web、service和dao； web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端； service层主要负责业务逻辑的处理； dao层主要负责连接数据库，进行数据的增删改查操作； servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求；针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和model： controller负责请求和数据的接收，接收后将其转发给service进行业务处理； service根据需要调用dao对数据进行增删改查； dao把数据处理完后将结果交给service，service再交给controller； 同步请求：controller根据需求组装成Model和View，Model和View组合起来生成页面转发给前端浏览器（这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作）； 现在更多使用的是异步请求方式，后端不需要返回view视图，而是将数据以json格式返回 SpringMVCSpringMVC是一种基于Java实现MVC模型的轻量级Web框架，相比于Servlet使用更加简单、开发更加便捷。 SpringMVC主要负责的就是：① controller如何接收请求和数据；② 如何将请求和数据转发给业务层；③ 如何将响应数据转换成json发回到前端。 SpringMVC入门案例SpringMVC是一个Web框架，是用来替换Servlet的，在JavaWeb中如何使用Servlet进行开发呢？忘记的话看前面的文章【JavaWeb_Servlet】 SpringMVC的制作流程与Servlet几乎一致： 1、创建Maven结构的web工程 2、设置tomcat服务器：tomcat插件 3、导入坐标（SpringMVC+Servlet） 4、定义处理请求的功能类（Controller） 5、设置请求映射 6、将SpringMVC设定加载到tomcat容器中 SpringMVC实现流程步骤1：创建webapp内核的Maven项目 步骤2：导入依赖坐标（Servlet、SpringMVC） ​ 注意导入的版本，建议使用JDK8以及5.3.0以下的SpringMVC版本配置，否则后面会出现奇奇怪怪的bug…到现在不知道如何解决jdk17不兼容的问题，后面做大项目的时候一定解决这个问题！ 12345678910111213&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;!-- 如果不设置默认是compile在编译、运行、测试时均有效；如果运行有效的话就会和tomcat中的servlet-api包发生冲突 --&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.24.RELEASE&lt;/version&gt; &lt;/dependency&gt; 步骤3：创建SpringMvcConfig配置类 1234@Configuration@ComponentScan(&quot;com.Lijiacheng.controller&quot;)public class SpringMvcConfig &#123;&#125; 步骤4：创建Controller类 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;User save...&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;; &#125;&#125; ​ Controller要注意的点有如下几个： （1）@Controller将其作为Bean交给Spring管理； （2）@RequestMapping(&quot;/save&quot;)指定request请求访问的地址，相当于Servlet中的WebServlet； （3）@ResponseBody指定后端返回的response响应是json数据； 步骤5：使用Servlet容器启动配置类替换web.xml 1234567891011121314151617181920public class ServletInitConfig extends AbstractDispatcherServletInitializer &#123; //加载springmvc配置类 protected WebApplicationContext createServletApplicationContext() &#123; //初始化WebApplicationContext对象 AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); //加载指定配置类 ctx.register(SpringMvcConfig.class); return ctx; &#125; //设置由springmvc控制器处理的请求映射路径(设置为接收所有路径) protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载spring配置类 protected WebApplicationContext createRootApplicationContext() &#123; return null; &#125;&#125; ​ 配置类要继承这个AbstractDispatcherServletInitializer类；并且初始化时所需的对象和前面的不同，是AnnotationConfigWebApplicationContext。 步骤6：配置Tomcat环境 我一般是习惯用IDEA自带的Tomcat插件，唯一的缺点是只能用Tomcat7，但是Tomcat7和JDK17已经不兼容了，所以我这里降低版本到JDK8了。 123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 步骤7：运行Tomcat服务器，在浏览器访问/save image-20230605164950934 流程解析将SpringMVC的使用过程总共分两个阶段来分析，分别是启动服务器初始化过程和单次请求过程。 启动服务器初始化1、服务器启动，执行ServletInitConfig类，初始化web容器（功能类似于以前的web.xml） 2、执行createServletApplicationContext方法，创建了WebApplicationContext对象，加载SpringMvcConfig配置类来初始化SpringMVC的容器 1234//初始化WebApplicationContext对象AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();//加载指定配置类ctx.register(SpringMvcConfig.class); 3、加载SpringMvcConfig配置类，执行@ComponentScan加载对应的bean，扫描指定包及其子包下所有类上的注解，这里是@Controller 1@ComponentScan(&quot;com.Lijiacheng.controller&quot;) 4、加载Controller类，每个@RequestMapping的名称对应一个具体的方法：建立了/save和save方法的对应关系 123456@RequestMapping(&quot;/save&quot;)@ResponseBodypublic String save()&#123; System.out.println(&quot;User save...&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;;&#125; 5、执行getServletMappings方法，设定SpringMVC拦截请求的路径规则：/代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求 1return new String[]&#123;&quot;/&quot;&#125;; 单次请求过程1、发送请求 http://localhost:8080/springmvc_01_quickstart/save 2、web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理 3、解析请求路径/save，由/save匹配执行对应的方法save() 4、检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方 Bean加载控制问题分析之前我们创建过SpringConfig配置类，在MVC中也创建了SpringMvcConfig配置类，它们都需要加载资源，它们分别都加载哪些内容呢？ 我们目前写过的Config配置类有：ServletInitConfig, SpringConfig, SpringMvcConfig, JdbcConfig, MybatisConfig。 controller目录存放的是SpringMVC的controller类、service目录存放的是service接口和实现类、dao目录存放的是dao/Mapper接口。controller、service和dao这些类都需要被容器管理成bean对象，SpringMVC加载表现层bean，也就是controller包下的类；Spring控制业务层service的bean和功能bean（DataSource, SqlSessionFactoryBean, MapperScannerConfigurer等），我们需要让Spring和SpringMVC分开加载各自的内容。 在SpringMVC的配置类SpringMvcConfig中使用注解@ComponentScan，我们只需要将其扫描范围设置到controller即可： 1234@Configuration@ComponentScan(&quot;com.Lijiacheng.controller&quot;)public class SpringMvcConfig &#123;&#125; 在Spring的配置类SpringConfig中使用注解@ComponentScan ，当时扫描的范围中其实是已经包含了controller： 1234@Configuration@ComponentScan(&quot;com.Lijiacheng&quot;)public class SpringConfig &#123;&#125; 因为功能不同，所以我们需要避免Spring错误加载到SpringMVC的bean。 环境准备 设置Bean加载控制方式一：修改Spring配置类，设定扫描范围为精准范围 1234@Configuration@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)public class SpringConfig &#123;&#125; 上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给MapperScannerConfigurer对象来进行扫描处理的，我们只需要将其扫描到service包即可。 方式二：修改Spring配置类，排除掉controller包中的bean 123456789@Configuration@ComponentScan(value = &quot;com.Lijiacheng&quot;, excludeFilters = @ComponentScan.Filter( // 设置扫描加载bean时，排除的过滤规则 type = FilterType.ANNOTATION, // 设置排除规则，当前使用按照bean定义时的注解类型进行排除 classes = Controller.class // 设置具体排除的注解类 ))public class SpringConfig &#123;&#125; 这样，通过getBean获取Controller类，如果获取不到就说明在SpringConfig配置类中排除成功了。 需要把SpringMvcConfig配置类上的@ComponentScan注解注释掉才可以测试成功。因为SpringConfig类中扫描的包是com.Lijiacheng下除了controller包，config中的SpringMvcConfig就会被扫描到，里面又有一个@ComponentScan又将controller类扫描进来了。 最后一点也很重要，有了SpringConfig配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletInitConfig配置类中的最后一个函数，将Spring配置也加载进来，很简单： 12345protected WebApplicationContext createRootApplicationContext() &#123; AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); ctx.register(SpringConfig.class); return ctx; &#125; 简化ServletInitConfig配置类开发（以后用它更简单，不过上面的是老母子） 12345678910111213public class ServletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;SpringMvcConfig.class&#125;; &#125; protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; Bean加载控制总结 @ComponentScan有个很重要的属性：excludeFilters排除扫描路径中加载的bean，需要指定类别（type）和具体项（classes）；includeFilter相反。 SpringMVC的请求与响应SpringMVC是web层的框架，主要的作用是接收请求、响应结果，所以这一部分是学习SpringMVC的重点内容。 设置请求映射路径环境准备 开启Tomcat服务器，发生报错： image-20230606102344014 意思是/save已经是bookController这个bean的方法进行匹配了，而另一个UserController这个bean也有一个/save，出现了request请求的匹配模糊。 问题分析前面说到报错，是因为两个Controller中出现了重复的请求路径： 12345678910111213141516171819202122232425@Controllerpublic class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;Book save...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;; &#125;&#125;// =====================================@Controllerpublic class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;User save...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;; &#125; @RequestMapping(&quot;/delete&quot;) @ResponseBody public String delete()&#123; System.out.println(&quot;User delete...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;; &#125;&#125; 解决思路其实也很好想到：为不同模块设置模块名作为请求路径前缀。 对于BookController的save，将其访问路径设置 http://localhost:8080/springmvc_03_request_mapping/book/save；对于UserController的save，将其访问路径设置 http://localhost:8080/springmvc_03_request_mapping/User/save。 设置映射路径类上也可以添加@RequestMapping注解： 123456789101112131415161718192021222324252627@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;Book save...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;; &#125;&#125;// =====================================@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;User save...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;; &#125; @RequestMapping(&quot;/delete&quot;) @ResponseBody public String delete()&#123; System.out.println(&quot;User delete...&quot;); return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;; &#125;&#125; image-20230606105142414 @RequestMapping注解value属性前面加不加/都可以，这一点和Servlet有所不同！ 请求参数请求路径设置好后，只要确保页面发送请求地址和后台Controller类中配置的路径一致，就可以接收到前端的请求，接收到请求后，如何接收页面传递的参数。请求参数的传递与接收是和请求方式有关系的，目前比较常见的两种请求方式POST和GET。 环境准备 参数传递GET发送单个参数 客户端发送请求与参数： 服务端接收参数： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/commonParam&quot;) @ResponseBody public String commonParam(String name)&#123; System.out.println(&quot;来自浏览器的普通参数传递 name =====&gt;&quot; + name); return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;; &#125;&#125; 这里controller方法的形参负责接收来自客户端的请求参数（注意形参名要和请求参数名一致！） image-20230606120718965 客户端接收到的返回数据： image-20230606120053621 GET发送多个参数 发送请求与参数： 服务端接收参数： 12345678910@Controllerpublic class UserController &#123; @RequestMapping(&quot;/commonParam&quot;) @ResponseBody public String commonParam(String name, Integer age)&#123; System.out.println(&quot;来自浏览器的普通参数传递 name =====&gt;&quot; + name); System.out.println(&quot;来自浏览器的普通参数传递 age =====&gt;&quot; + age); return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;; &#125;&#125; image-20230606122229281 GET请求中文乱码问题 如果我们传递的请求参数中有中文，你会发现接收到的参数会出现中文乱码问题。 出现乱码的原因相信大家都清楚（忘了的话回去看JavaWeb的博客），Tomcat8以后的版本已经处理了中文乱码的问题，但是IDEA中的Tomcat插件目前只更新到Tomcat7，所以需要修改pom.xml中tomcat插件的配置来解决GET请求中文乱码问题。 1234&lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt; &lt;!--访问路径编解码字符集--&gt;&lt;/configuration&gt; image-20230606122858098 POST发送参数 发送请求与参数：post的请求参数在请求体上 接收参数和GET完全一致！ POST请求中文乱码问题 解决方案：在ServletInitConfig中配置过滤器 1234567/* 乱码处理 */ @Override protected Filter[] getServletFilters()&#123; CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(&quot;utf-8&quot;); return new Filter[]&#123;filter&#125;; &#125; image-20230606161430634 CharacterEncodingFilter是在spring-web包中，而spring-web包又在SpringMVC包里。 五种类型的参数传递前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递：普通参数、POJO类型参数、嵌套POJO类型参数、数组类型参数、集合类型参数。 普通参数普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。 能接收到参数的前提是：这两个值必须一致！ 那如果方法形参和请求参数名不一致怎么办？ image-20230606163422184 使用@RequestParam注解：写上@RequestParam注解框架就不需要自己去解析注入，能提升框架处理性能。 12345678910@Controllerpublic class UserController &#123; @RequestMapping(&quot;/commonParam&quot;) @ResponseBody public String commonParam(@RequestParam(&quot;name&quot;) String username, Integer age)&#123; System.out.println(&quot;来自浏览器的普通参数传递 name =====&gt;&quot; + username); System.out.println(&quot;来自浏览器的普通参数传递 age =====&gt;&quot; + age); return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;; &#125;&#125; POJO类型参数简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。 POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数（请求参数key的名称要和POJO中属性的名称一致，否则无法封装）。 先看看前面封装的pojo类： 12345public class User &#123; private String name; private Integer age; // ...后部分省略...&#125; 发送请求和参数（请求参数key的名称要和POJO中属性的名称一致，否则无法封装）： 服务器接收参数： 123456@RequestMapping(&quot;/pojoParam&quot;) @ResponseBody public String pojoParam(User user)&#123; System.out.println(&quot;来自浏览器的pojo参数传递 user =====&gt;&quot; + user); return &quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;; &#125; image-20230606165101676 嵌套POJO类型参数嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数。 发送请求和参数（请求参数key的名称要和POJO中属性的名称一致，否则无法封装）： 服务器接收参数： 123456@RequestMapping(&quot;/containPojoParam&quot;) @ResponseBody public String containPojoParam(User user)&#123; System.out.println(&quot;来自浏览器的嵌套pojo参数传递 user =====&gt;&quot; + user.toString()); return &quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;; &#125; image-20230606171728620 数组类型参数数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数。 发送请求和参数（请求参数名必须一致才能封装到一个数组当中）： 服务器接收参数： 123456@RequestMapping(&quot;/arrayParam&quot;) @ResponseBody public String arrayParam(String[] likes)&#123; System.out.println(&quot;来自浏览器的数组参数传递 likes =====&gt;&quot; + Arrays.toString(likes)); return &quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;; &#125; image-20230606172647070 集合类型数据发送请求和参数： image-20230606184441837 服务器接收参数： 123456@RequestMapping(&quot;/listParam&quot;) @ResponseBody public String listParam(List&lt;String&gt; likes)&#123; System.out.println(&quot;来自浏览器的列表参数传递 likes =====&gt;&quot; + likes); return &quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;; &#125; 出现报错： image-20230606184417780 错误的原因是：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。 解决方案：RequestParam注解（对于简单数据类型使用数组会比集合更简单些） 123456@RequestMapping(&quot;/listParam&quot;) @ResponseBody public String listParam(@RequestParam List&lt;String&gt; likes)&#123; System.out.println(&quot;来自浏览器的列表参数传递 likes =====&gt;&quot; + likes); return &quot;&#123;&#x27;module&#x27;,&#x27;listParam&#x27;&#125;&quot;; &#125; 总结 RequestParam注解用在SpringMVC控制器方法形参定义前面：情况1——简单数据类型参数名和请求参数名不一致时进行映射；情况2——对于List列表形参前要加该注释将其标明为非POJO对象。 JSON数据传输参数前面我们说过，现在比较流行的开发方式为异步调用。前后端以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收。 SpringMVC接收JSON数据的实现步骤为： 导入jackson包； 客户端发送JSON数据； 开启SpringMVC注解驱动，在SpringMvcConfig配置类上添加@EnableWebMvc注解； Controller方法的参数前添加@RequestBody注解. JSON普通数组步骤1：pom.xml添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.2&lt;/version&gt;&lt;/dependency&gt; 步骤2：PostMan发送JSON数据 步骤3：开启SpringMVC注解支持 ​ 在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。 123456@Configuration@ComponentScan(&quot;com.Lijiacheng.controller&quot;)//开启json数据类型自动转换@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; 步骤4：参数前添加@RequestBody将外部传递的json数组数据映射到形参的集合对象中作为数据 1234567// 使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据 @RequestMapping(&quot;/listParamForJson&quot;) @ResponseBody public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123; System.out.println(&quot;来自浏览器的JSON普通数组参数传递 likes =====&gt;&quot; + likes); return &quot;&#123;&#x27;module&#x27;,&#x27;listParamForJson&#x27;&#125;&quot;; &#125; 因为json数据是异步请求，参数和数据在表单中，所以不能用@RequestParam，而用@RequestBody. image-20230606201541316 JSON对象数据请求和数据的发送： 后端接收数据： 123456@RequestMapping(&quot;/pojoForJson&quot;) @ResponseBody public String pojoForJson(@RequestBody User user)&#123; System.out.println(&quot;来自浏览器的JSON实体类对象参数传递 User =====&gt;&quot; + user); return &quot;&#123;&#x27;module&#x27;,&#x27;pojoForJson&#x27;&#125;&quot;; &#125; 这里也不要忘记在controller方法形参对象前加上@RequestBody进行json类型转换。 image-20230606202648795 JSON对象数组json对象数组即为在集合中保存多个POJO。 请求和数据的发送： 后端接收数据： 123456@RequestMapping(&quot;/listPojoForJson&quot;) @ResponseBody public String listPojoForJson(@RequestBody List&lt;User&gt; users)&#123; System.out.println(&quot;来自浏览器的JSON对象数组参数传递 users =====&gt;&quot; + users); return &quot;&#123;&#x27;module&#x27;,&#x27;listPojoForJson&#x27;&#125;&quot;; &#125; image-20230606204104084 @RequestBody与@RequestParam的区别： @RequestParam用于接收url地址传参，表单传参【application/x-www-form-urlencoded】；@RequestBody用于接收json数据【application/json】. 后期开发中，发送json格式数据为主，@RequestBody应用较广；如果发送非json格式数据，选用@RequestParam接收请求参数。 日期类型参数传递前面我们处理过简单数据类型、POJO数据类型、数组和集合数据类型以及JSON数据类型，接下来我们还得处理一种开发中比较常见的一种数据类型：日期类型。 日期的格式有N多中输入方式，比如：2088-08-18、2088/08/18、08/18/2088……这么多日期格式，SpringMVC如何接收。 步骤1：编写方法接收日期数据 1234567891011@RequestMapping(&quot;/dataParam&quot;) @ResponseBody public String dataParam(Date date, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date date1, @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) Date date2) &#123; System.out.println(&quot;来自浏览器的日期参数传递 date =====&gt;&quot; + date); System.out.println(&quot;来自浏览器的日期参数传递 date1(YYYY-MM-dd) =====&gt;&quot; + date1); System.out.println(&quot;来自浏览器的日期参数传递 date2(YYYY-MM-dd HH:mm:ss)&quot; + date2); return &quot;&#123;&#x27;module&#x27;,&#x27;dataParam&#x27;&#125;&quot;; &#125; 步骤2：客户端发送请求 SpringMVC默认支持的字符串转日期的格式为yyyy/MM/dd ，而如果传递的不符合其默认格式，SpringMVC就无法进行格式转换，所以报错： image-20230606205513452 所以使用@DateTimeFormat注解的pattern值来解决这个问题。 image-20230606225051826 参数传递的内部实现原理前端传递字符串，后端使用日期Date接收；前端传递JSON数据，后端使用对象接收；前端传递字符串，后端使用Integer接收。在数据的传递过程中存在很多类型的转换，那么谁来做这个类型转换——是SpringMVC提供的很多类型转换接口和实现类。 在框架中，有一些类型转换接口，其中有： Converter接口：convert方法就是将从页面上接收的数据(S)转换成我们想要的数据类型(T)返回，框架中有提供很多对应Converter接口的实现类，用来实现不同数据类型之间的转换，如：请求参数年龄数据（String→Integer）、日期格式转换（String → Date）。 HttpMessageConverter接口：该接口是实现对象与JSON之间的转换工作（配置@EnableWebMvc）。 响应SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后都需要将结果告知给用户。对于响应，主要就包含两部分内容：响应页面、响应数据（文本数据、json数据），因为异步调用是目前常用的主流方式，所以我们需要更关注的就是如何返回JSON数据。 环境准备 响应页面（了解）响应页面时不能使用@responseBody注解，否则会把”page.jsp”当做字符串返回，这里需要返回页面： 123456// 不能使用@responseBody，否则会把&quot;page.jsp&quot;当做字符串返回，这里需要返回页面 @RequestMapping(&quot;/jumpToPage&quot;) public String jumpToPage()&#123; System.out.println(&quot;跳转页面&quot;); return &quot;page.jsp&quot;; &#125; image-20230607101201195 响应文本数据响应文本时一定要使用@responseBody注解，返回纯文本字符串类型数据。 123456@RequestMapping(&quot;/toText&quot;) @ResponseBody public String toText()&#123; System.out.println(&quot;返回纯文本数据&quot;); return &quot;response text&quot;; &#125; 响应JSON数据响应POJO对象 返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖@ResponseBody注解和@EnableWebMvc注解。 123456789@RequestMapping(&quot;/toPojoJson&quot;) @ResponseBody public User toPojoJson()&#123; System.out.println(&quot;返回json格式的对象类型&quot;); User user = new User(); user.setName(&quot;李嘉诚123&quot;); user.setAge(22); return user; &#125; 响应POJO集合对象 123456789101112131415@RequestMapping(&quot;/toJsonList&quot;) @ResponseBody public List&lt;User&gt; toJsonList()&#123; System.out.println(&quot;返回json对象列表的类型&quot;); User u1 = new User(); u1.setName(&quot;李嘉诚&quot;); u1.setAge(21); User u2 = new User(); u2.setName(&quot;廖梓汀&quot;); u2.setAge(22); List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(u1); users.add(u2); return users; &#125; @ResponseBody总结 位置：SpringMVC控制器方法定义上方和控制类上，写在类上则该类的所有方法都有该注解功能； 作用：设置当前控制器返回值作为响应体（除了返回页面之外都要加该注释）：① 方法的返回值为字符串，会将其作为文本内容直接响应给前端；② 方法的返回值为对象，会将对象转换成JSON响应给前端（通过Converter接口）。","tags":[]},{"title":"ChatGPT本地安装","date":"2023-06-05T00:24:52.000Z","path":"2023/06/05/ChatGPT本地安装/","text":"本地搭建ChatGPT，无需API、 免翻墙使用纯正OpenAI的全部功能。 和官网的比较优点： 不需要挂代理就可以访问 相比官网而言速度更快 缺点： 后台要挂Docker 和使用API不同，并不是真正意义上的本地部署，只是通过自己的Access TOKEN避免了网络代理 操作步骤1、下载并安装Docker（官网链接） 2、使用开源项目：潘多拉 (Pandora) ​ 一键安装命令： 1docker pull pengzhile/pandora 1docker run -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora 3、获取自己的Access TOKEN：http://chat.openai.com/api/auth/session 14天内免代理登录 4、访问本地链接：http://127.0.0.1:8899 可以实现与官网的同步 ​","tags":[]},{"title":"05-Spring事务管理","date":"2023-06-04T04:06:46.000Z","path":"2023/06/04/05-Spring事务管理/","text":"数据库的事务在数据库还有JavaWeb中也多次提到了，事务管理保障了一系列的数据库操作同成功同失败，事务管理非常重要。下面就来讲一下Spring是如何进行事务管理的。 Spring事务简介相关概念 事务作用：在数据层保障一系列的数据库操作同成功同失败； Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败； 为什么业务层需要进行事务管理？举个例子来说，转账业务会有两次数据层的调用，一次是加钱一次是减钱；把事务放在数据层，加钱和减钱就有两个事务；没办法保证加钱和减钱同时成功或者同时失败；这个时候就需要将事务放在业务层进行处理。 Spring为了管理事务，提供了一个平台事务管理器（接口）PlatformTransactionManager： 除此之外，Spring还为其提供了一个具体的实现（类）：DataSourceTransactionManager. 我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。 Spring事务转账案例需求：实现任意两个账户间转账操作（账户A加钱，账户B减钱） 实现：基于Spring整合MyBatis环境，实现转账操作。忘记如何整合Mybatis环境的去看03-Spring整合三方框架。 环境搭建 事务管理如果在转账过程中出现了异常，如： 12345public void transfer(String in, String out, double money) &#123; accountDao.outMoney(out, money); int x = 1/0; // 模拟异常 accountDao.inMoney(in, money); &#125; 程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败： image-20230604161633065 正常来说，Tom账户应该收到来自Jerry账户转账的100元，但是由于在转出之后程序出现异常，后面的转入操作根本没有进行，这在现实中是肯定不允许出现的。这就体现出事务管理的重要性，程序出现异常时要进行事务回滚，这个事务应该是在业务层（Service），Spring事务管理就是做这个的： 步骤1：在需要被事务管理的方法上添加注解 1234@Transactionalpublic interface AccountService &#123; public void transfer(String in, String out, double money);&#125; @Transactional可以写在接口类上、接口方法上、实现类上和实现类方法上，建议（标准）写在接口或接口的方法上。 步骤2：在JdbcConfig类中配置事务管理器（mybatis使用的是jdbc事务） 123456@Beanpublic PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager;&#125; 事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用DataSourceTransactionManager。 步骤3：SpringConfig开启事务注解 1@EnableTransactionManagement 发现在转换的业务出现错误后，事务就可以控制回滚，保证数据的正确性： image-20230604163037324 Spring事务管理总结 注意两个注释： 配置类注释：@EnableTransactionManagement设置当前Spring环境中开启注解式事务支持； 业务层接口注释：@Transactional为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）。 Spring事务角色重点要理解两个概念，分别是事务管理员和事务协调员。 1、未开启Spring事务之前： AccountDao的outMoney因为是修改操作，会开启一个事务T1；AccountDao的inMoney因为是修改操作，会开启一个事务T2；AccountService的transfer没有事务。 如果运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确；如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行，就会出现数据错误。 2、开启Spring事务后 transfer上添加了@Transactional注解，在该方法上就会有一个事务T，AccountDao的outMoney方法的事务T1加入到transfer的事务T中，AccountDao的inMoney方法的事务T2加入到transfer的事务T中。这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。 事务管理员：发起事务方，在Spring中通常指业务层开启事务的方法； 事务协调员：加入事务方，在Spring中通常指数据层方法，也可以是业务层方法； 注意：目前的事务管理是基于DataSourceTransactionManager和SqlSessionFactoryBean使用的是同一个DataSource数据源。 Spring事务属性事务配置这些属性都可以在@Transactional注解的参数上进行设置。 readOnly：true只读事务，false读写事务，增删改要设为false（默认），查询设为true。 timeout：设置超时时间（单位秒），在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。 rollbackFor：当出现指定异常进行事务回滚 noRollbackFor：当出现指定异常不进行事务回滚 关于Spring事务异常回滚的问题，Spring的事务只会对Error异常和RuntimeException异常及其子类（运行时异常）进行事务回滚，其他的异常类型是不会回滚的，比如IOException不符合上述条件所以不回滚。 此时就可以使用rollbackFor属性来设置IOException异常回滚。 事务传播行为为了讲解事务传播行为属性propagation的设置，我们需要完成下面的案例。 转账业务追加日志案例需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕（数据库记录日志），无论转账操作是否成功，均进行转账操作的日志留痕。 环境准备 步骤1：数据库创建日志表 步骤2：添加LogDao接口 1234public interface LogDao &#123; @Insert(&quot;insert into tbl_log (info,createDate) values(#&#123;info&#125;,now())&quot;) void log(String info);&#125; 步骤3：添加LogService接口与实现类 123456789101112public interface LogService &#123; void log(String out,String in,double money);&#125;@Service@Transactionalpublic class LogServiceImpl &#123; @Autowired private LogDao logDao; public void log(String out,String in,double money)&#123; logDao.log(&quot;转账操作由 &quot; + out + &quot;到&quot; + in + &quot;，金额：&quot; + money); &#125;&#125; 步骤4：在转账的业务中添加记录日志 12345678910111213@Autowired private AccountDao accountDao; @Autowired private LogService logService; @Override public void transfer(String in, String out, double money) &#123; try &#123; accountDao.outMoney(out, money); accountDao.inMoney(in, money); &#125;finally &#123; logService.log(out,in,money); &#125; &#125; 当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功；当转账业务之间出现异常（int i =1/0），转账失败，tbl_account成功回滚，但是tbl_log表未添加数据。而我们希望无论转账操作是否成功，日志都必须保留。 失败原因：日志的记录与转账操作隶属同一个事务，同成功同失败。 事务传播行为 log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1、T2、T3，@Transactional注释开启事务T，把T1、T2、T3都加入到事务T中来，当转账失败后，所有事务都回滚，所以日志没有记录下来。如果要想让log方法单独开启一个事务，就用到了事务传播行为。 事务传播行为是指事务协调员对事务管理员所携带事务的处理态度，用到了@propagation属性。 修改logSevice的@Transactional属性值，改变事务传播行为（当前操作需要新事务） 1@Transactional(propagation = Propagation.REQUIRES_NEW) 事务传播行为的可选值","tags":[]},{"title":"网页调试工具PostMan","date":"2023-06-04T01:58:21.000Z","path":"2023/06/04/网页调试工具PostMan/","text":"PostMan是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，常用于进行接口测试。 PostMan简介代码编写完后，我们要想测试，只需要打开浏览器直接输入地址发送请求即可。发送的是GET请求可以直接使用浏览器，但是如果要发送的是POST请求呢？如果要求发送的是post请求，我们就得准备页面在页面上准备form表单，测试起来比较麻烦。所以我们就需要借助一些第三方工具，如PostMan。 PostMan安装官网链接下载 注册一个账号直接来到这个界面： PostMan使用创建WorkSpace工作空间 发送请求 也可以请求访问我们在Tomcat返回的页面： image-20230606094044962 保存当前请求","tags":[]},{"title":"04-AOP","date":"2023-06-02T03:33:15.000Z","path":"2023/06/02/04-AOP/","text":"前面对Spring介绍时说过，Spring有两个核心的概念，一个是IOC/DI，另一个就是AOP。接下来要学习AOP了，AOP总的来说就是在不改变原有代码的前提下对其进行增强。 AOP简介什么是AOPAOP(Aspect Oriented Programming)面向切面编程，是一种编程范式，指导开发者组织程序结构。（熟知的oop也是一种编程范式） AOP作用在不惊动原始设计的基础上为其进行功能增强。（前面有技术可以实现这样的功能，即代理模式） AOP核心概念Spring的AOP的核心就是在不改动原始代码的前提下，想给谁添加功能就给谁添加，这个也是Spring的理念：无侵入式。 那Spring是如何做到的呢？ image-20230602170709205 连接点：Spring的AOP是对一个类的方法在不进行任何修改前提下进行增强。对于save, update, delete, select方法，叫做连接点。 切入点：update和delete只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能；那也就是说update和delete方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫切入点（匹配连接点进行数据增强的式子）。 通知：执行update和delete方法时都被添加了一个计算执行万次消耗时间的功能，将这个功能抽取到一个方法中，也就是一个存放共性功能的方法中，我们叫这个方法为通知（在切入点处执行的操作）；方法存在的类叫做通知类。 切面：通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，需要对通知和切入点的关系有一个明确的描述，这个关系描述我们叫做切面。 AOP入门案例需求分析：使用SpringAOP的注解方式完成在方法执行前打印出系统当前时间。 AOP操作思路1、导入坐标（pom.xml） 2、制作连接点（原始操作，比如Dao接口和实现类） 3、制作共性功能（通知类与通知） 4、定义切入点（那些连接点需要被增强） 5、绑定切入点和通知的关系（切面） AOP实现步骤 导入spring和aspectj依赖坐标 aop依赖是spring的子包，所以不需要单独导入了。 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.19&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 制作连接点——添加Dao接口和Impl实现类 12345678910111213141516public interface BookDao &#123; public void save(); public void update();&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; public void save()&#123; System.out.println(System.currentTimeMillis()); System.out.println(&quot;Book dao save...&quot;); &#125; public void update() &#123; System.out.println(&quot;Book dao upodate...&quot;); &#125;&#125; 创建SpringConfig配置类和App主程序运行类 定义通知类和通知 通知就是将共性功能抽取出来形成的方法，类名和方法名都自定义。 123456public class MyAdvice &#123; // 将共性抽取出来形成的方法 public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; 定义切入点（连接点中的哪些方法需要增强） 我们要增强连接点中的update方法： 12345678910public class MyAdvice &#123; /* ======================================================== */ @Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) private void fn()&#123;&#125; /* ======================================================== */ // 将共性抽取出来形成的方法 public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; ​ ① 切入点定义依托一个不具有实际意义的方法（无参数、无返回值、方法体无逻辑）进行； ​ ② Pointcut后面execution内的内容，是连接点的返回值+具体的连接点方法。 制作切面（切面用来描述通知和切入点之间的联系） 指定通知添加到原始连接点的具体执行位置。 1234567891011public class MyAdvice &#123; @Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) private void fn()&#123;&#125; /* ======================================================== */ @Before(&quot;fn()&quot;) // 通知会在切入点方法执行之前执行 /* ======================================================== */ // 将共性抽取出来形成的方法 public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; 将通知类配给容器并标识其为切面类 将通知类通过@Component注释配置为一个Bean；再通过@Aspect注释将其配置为可以使用AOP的通知类。 1234@Component@Aspectpublic class MyAdvice &#123;&#125; 开启注释格式AOP功能（@EnableAspectJAutoProxy） 12345@Configuration@ComponentScan(&quot;com.Lijiacheng&quot;) // 默认会扫描该类所在的包下所有的配置类@EnableAspectJAutoProxy // 配置类中开启AOP功能public class SpringConfig &#123;&#125; 运行程序 1234567public class AppForAOP &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); &#125;&#125; 发现在执行update方法前打印了系统的时间戳，说明对原始update方法进行了功能增强，AOP编程成功。 AOP总结1、配置类注解@EnableAspectJAutoProxy：开启注释格式的AOP功能； 2、通知类注解@Aspect：设置当前类为AOP切面类； 3、切入点方法注解@Pointcut，设置切入点方法； 4、通知方法注解@Before，设置当前通知方法与切入点之间的绑定关系。 AOP工作流程由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起。 AOP流程 流程1：Spring容器启动 ​ 容器启动就需要去加载bean：像需要被增强的类、通知类等都需要被加载。（此时bean对象还没有被创建成功） 流程2：读取所有切面配置中的切入点 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.save())&quot;) private void fnx()&#123;&#125; @Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) private void fn()&#123;&#125; @Before(&quot;fn()&quot;) public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; 上述代码有两个切入点的配置，但是第一个fnx()并没有被使用，所以不会被读取。 流程3：初始化bean 判定bean对应的类中的方法是否匹配到任意切入点： 匹配失败：创建原始对象，如UserDao（匹配失败则说明不需要增强，直接调用原始对象的方法即可）； 匹配成功：创建原始对象的代理对象，如BookDao（匹配成功则说明需要增强，；对哪个类进行增强，这个类对应的对象就叫做目标对象；由于要对目标对象进行功能增强，而采用的是动态代理技术，所以会为其创建一个代理对象；最终运行的是代理对象的方法，该方法对原始方法进行了功能增强）。 流程4：获取bean执行方法 获取的bean是原始对象，调用方法并执行，完成操作； 获取的bean是代理对象，根据代理对象的运行模式运行原始方法和增强内容，完成操作。 验证IOC容器中创建的对象是原始对象还是代理对象：通过.getClass()实现： image-20230602195821441 值得注意的是：不能直接打印对象，因为直接打印对象走的是对象的toString()方法，内部对该方法进行了重写，无论是否是代理方法打印的结果都相同。 AOP核心概念这里主要讲一下前面提到的目标对象和代理： 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的。 代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象来实现。 目标对象就是要增强的类（比如说BookServiceImpl类）对应的对象，也叫原始对象，不是说他不能运行而是他在运行过程中对于要增强的内容是缺失的；SpringAOP是在不改变原有设计的前提下进行内容增强，他底层采用的是代理模式实现的，所以要对原始对象创建代理对象，在代理对象中的方法把通知内容（如MyAdvice类中的method方法）加进去，实现了增强，这就是我们所说的代理。 AOP配置管理AOP切入点表达式 切入点：要进行增强的方法；切入点表达式：要进行增强的方法的描述方式。对于切入点表达式，需要掌握三块内容：语法格式、通配符、书写技巧。 语法格式因为调用接口方法的时候最终运行的还是其实现类的方法，所以有两种表达式的描述方式： 描述方式1：执行BookDao接口下的无参update方法； 1@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) 描述方式2：执行BookDaoImpl实现类中的无参update方法： 1@Pointcut(&quot;execution(void com.Lijiacheng.dao.impl.BookDaoImpl.update())&quot;) 所以切入点表达式的语法是：动作关键词([访问修饰符] 返回值 包名.类/接口名.方法名(参数) [异常名])，（”[]”表示可省略） 通配符切入点表达式就是要找到具体增强的方法，但是需要增强的方法有很多，如果每一个方法都要对应一个切入点表达式就比较繁琐，所以用通配符来描述切入点，简化之前的配置。 *：单个独立的任意符号，可以独立出现，也可以作为前缀或后缀的匹配符出现 1execution(public * com.Lijiacheng.*.UserService.find*(*)) 匹配com.Lijiacheng包下任意包中的UserService类或接口中所有find开头的带有一个方法参数的方法； ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 1execution(public User com..UserService.findById(..)) 匹配com包下任意包中的UserService类或接口中所有名称为findById的方法； +：专用于匹配子类类型 1execution(* *..*Service+.*(..)) 这个使用率很低。*Service+表示所有以Service结尾的接口的子类。 书写技巧1、描述切入点通常描述接口，而不描述实现类，如果描述到实现类，就出现紧耦合； 2、访问控制修饰符针对接口开发均采用public（可省略）； 3、返回值类型对于增删改查使用精准匹配，对于查询类使用*快速匹配； 4、包名书写尽量不使用..匹配，效率过低；常使用*做单个包描述匹配，或精准匹配； 5、接口名/类名采用*匹配，例如UserService书写成*Service，绑定业务层接口； 6、方法名书写以动词精准匹配，例如getById书写成getBy*，selectAll书写成selectAll。 AOP通知类型AOP通知描述了抽取的共性功能，AOP需要将通知和切入点进行绑定，并指定增强内容的执行位置。 类型介绍1、前置通知：追加功能到方法执行前； 2、后置通知：追加功能到方法执行后，不论方法执行过程中有没有抛出异常都会执行； 3、返回后通知：追加功能到方法执行后，但是只有方法正常执行结束后才进行，如果方法执行抛出异常，返回后通知将不被执行； 4、抛出异常后通知：追加功能到方法抛出异常后，只有方法抛出异常后才会被添加； 5、环绕通知：可以追加到方法执行的前后，最常用的方式。 环境准备具体就不展开了，创建好的项目结构如下： 通知类型的使用 前置通知：修改MyAdvice，在before方法上加@Before注解 123456@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) public void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void before()&#123; System.out.println(&quot;before advice...&quot;); &#125; image-20230603105857801 后置通知：修改MyAdvice，加@After注解 123456@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) public void pt()&#123;&#125;@After(&quot;pt()&quot;) public void after()&#123; System.out.println(&quot;after advice...&quot;); &#125; 环绕通知：修改MyAdvice，加@Around注解 相比于前置和后置通知，环绕通知需要在原始内容的前后进行内容增强，所以我们需要指定哪些内容在原始内容前执行，哪些内容在原始内容后执行，所以必须能对原始操作进行调用。 12345678@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;) public void pt()&#123;&#125; @Around(&quot;pt()&quot;) public void around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;around before advice...&quot;); pjp.proceed(); // 对原始操作进行调用 System.out.println(&quot;around after advice...&quot;); &#125; image-20230603112123746 ​ 刚才针对的是原始方法无返回值的情况，原始方法有返回值的情况如何处理呢？ 12345/* =================实现类中的原始方法=============== */public int select()&#123; System.out.println(&quot;Book dao select is running...&quot;); return 100; &#125; ​ 修改通知，返回值设置为通用的Object基类。 1234567891011/* =================通知类======================== */@Pointcut(&quot;execution(int com.Lijiacheng.dao.BookDao.select())&quot;) public void pt2()&#123;&#125;@Around(&quot;pt2()&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;around before advice...&quot;); // 对原始操作进行调用 Object ret = pjp.proceed(); System.out.println(&quot;around after advice...&quot;); return ret; &#125; ​ 当原始方法有返回值时，需要根据原始方法的返回值设置环绕通知的返回值，否则就会报如下的错误：大概意思是空的返回不匹配原始方法的返回值。 image-20230603112555069 返回后通知 1234@AfterReturning(&quot;pt2()&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning advice...&quot;); &#125; ​ 返回后通知是需要在原始方法select正常执行后才会被执行，如果select方法在执行过程中出现了异常，那么返回后通知是不会被执行的（而后置通知是无论是否抛出异常都会被执行）： image-20230603124407104 异常后通知 1234@AfterThrowing(&quot;pt2()&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing advice...&quot;); &#125; 异常后通知只有在抛出异常时才会被执行： ​ 环绕通知总结：环绕通知可以控制原始方法执行，所以把增强的代码写在调用原始方法的前后位置，就可以实现不同通知类型的功能： ​ （1）环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知； ​ （2）环绕通知未使用ProceedingJoinPoint调用原始方法，将跳过原始方法的执行； ​ （3）最好将环绕通知的返回值都设置成Object； ​ （4）环绕通知无法预知调用的原始方法是否会抛出异常，所以在通知方法要手动抛出Throwable异常。 业务层接口执行效率需求分析：任意业务层接口执行均可显示其执行时长。 实现思路：开始执行方法前记录一个时间，执行方法结束后记录一个时间，得到的时间差值就是执行效率。要在原始方法前后添加业务，就用到环绕通知。 环境准备具体就不展开了，如果不熟悉了要记得复习前面的博客，创建好的项目结构如下： 功能开发步骤1：开启SpringAOP的注释功能 1@EnableAspectJAutoProxy 步骤2：创建AOP的通知类 ① 通知类要被Spring管理，添加@Component注释；② 要标识通知类是个切面类，添加@Aspect注释；③ 配置切入点表达式，需要添加一个方法并添加@Pointcut. 12345678910@Component@Aspectpublic class ProjectAdvice &#123; // 配置业务层的所有方法 @Pointcut(&quot;execution(* com.Lijiacheng.service.*Service.*(..))&quot;) private void servicePt()&#123;&#125; @Around(&quot;servicePt()&quot;) public void runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123; &#125;&#125; 步骤3：添加环绕通知（目前没有任何增强） 12345@Around(&quot;servicePt()&quot;)public Object runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = pjp.proceed(); return ret;&#125; 步骤4：完成核心业务，记录万次执行时间 123456Long startTime = System.currentTimeMillis();for(int i=0;i&lt;10000;i++)&#123; pjp.proceed();&#125;Long endTime = System.currentTimeMillis();System.out.println(&quot;万次执行时间为: &quot; + (endTime-startTime) + &quot; ms&quot;); 步骤5：运行单元测试类（注意看单元测试类怎么写） 12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTestCase &#123; @Autowired private AccountService accountService; @Test public void testFindById()&#123; Account ac = accountService.findById(2); &#125; @Test public void testFindAll()&#123; List&lt;Account&gt; acs = accountService.findAll(); &#125;&#125; 但是此时无法知道是哪个接口的哪个方法执行耗时： image-20230603225751338 所以我们要对步骤4的核心业务代码进行优化： 123456789101112131415@Around(&quot;servicePt()&quot;) public void runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123; // 获取执行签名信息 Signature signature = pjp.getSignature(); // 通过签名获取执行操作名称(接口名) String className = signature.getDeclaringTypeName(); // 通过签名获取执行操作名称(方法名) String methodName = signature.getName(); Long startTime = System.currentTimeMillis(); for(int i=0;i&lt;10000;i++)&#123; pjp.proceed(); &#125; Long endTime = System.currentTimeMillis(); System.out.println(&quot;万次执行时间为: &quot; + className + &quot;.&quot; + methodName + &quot;-----&gt;&quot; + (endTime-startTime) + &quot; ms&quot;); &#125; image-20230603230159251 AOP通知获取数据刚才写AOP仅是在原始方法前后追加一些操作，接下来要说一下AOP中数据相关内容，主要有：获取参数、获取返回值、获取异常。 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知 ProceedingJoinPoint：适用于环绕通知 获取切入点方法的返回值：主要研究返回后通知和环绕通知； 获取切入点方法的异常信息：主要研究抛出异常后通知和环绕通知。 环境准备 image-20230603235831233 获取参数 非环绕通知获取方式：在方法上添加JoinPoint，通过JoinPoint来获取参数 123456@Before(&quot;fn()&quot;) public void before(JoinPoint jp)&#123; Object[] args = jp.getArgs(); System.out.println(Arrays.toString(args)); // 将数组以字符串的形式输出 System.out.println(&quot;before advice...&quot;); &#125; 环绕通知获取方式：环绕通知使用的是ProceedingJoinPoint 因为ProceedingJoinPoint是JoinPoint类的子类，所以ProceedingJoinPoint一定有getArgs()方法. 此外值得注意的是，pjp.proceed有两个方法都可以完成功能：①调用无参数的proceed方法，当原始方法有参数时，会在调用的过程中自动传入参数；②但是当需要修改原始方法的参数时，必须采用带有参数的proceed方法，如下所示： 12345678@Around(&quot;fn()&quot;) public Object around(ProceedingJoinPoint pjp)throws Throwable&#123; Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); // 将args作为参数传回原始调用方法 return ret; &#125; 有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性。 获取返回值对于返回值只有返回后AfterReturing和环绕Around这两个通知类型可以获取。 环绕通知获取返回值 和环绕通知获取参数一样，ret就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改。 返回后通知获取返回值（注意returning的值与通知方法的形参名一定要一致！） image-20230604100651690 ​ 根据以下代码分析一下程序执行结果： 123456789101112/* ===================主程序执行======================= */String name = bookDao.findName(100, &quot;hfut&quot;);System.out.println(name);/* ===================实现类======================== */@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public String findName(int id, String password) &#123; System.out.println(&quot;id: &quot; + id); return &quot;lijiacheng&quot;; &#125;&#125; ​ 首先调用bookDao接口中的切入点方法findName，由于切面是返回后通知，所以优先执行原始方法；原始方法将返回值“lijiacheng”赋值给name变量后，执行返回后通知的增强内容，也就是获取返回值并将返回值修改为”liaoziting”并打印；最后一步再打印出第一步得到的name变量值。如下结果所示： image-20230604101417654 有一个非常关键的点，当AfterReturning有JoinPoint参数时，必须将其放在第一位，否则将会报错： 1public void afterReturning(JoinPoint jp, Object ret)&#123;&#125; 获取异常（了解）对于获取抛出异常，只有抛出异常后AfterThrowing和环绕Around这两个通知可以获取。 环绕通知获取异常：以前我们是抛出异常，现在只需要将异常捕获，就可以获取到原始方法的异常信息 12345678910111213@Around(&quot;fn()&quot;) public Object around(ProceedingJoinPoint pjp)&#123; Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = null; try &#123; ret = pjp.proceed(args); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; return ret; &#125; 抛出异常后通知获取异常：也是要注意throwing的值和通知方法的形参值要一致！ 1234@AfterThrowing(value = &quot;fn()&quot;, throwing = &quot;t&quot;) public void afterThrowing(Throwable t)&#123; System.out.println(&quot;afterThrowing advice... ----&gt;&quot; + t); &#125; image-20230604102743788 AOP案例：百度网盘密码数据兼容处理需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理。 以后涉及到需要去除前后空格的业务可能会有很多，这个去空格的代码是每个业务都写么？当功能的泛化性很强时，我们考虑使用AOP来统一处理。要做到这一点，我们先要在业务方法执行之前对所有的输入参数进行格式处理、再使用处理后的参数调用原始方法。 因为要先获取原始方法的参数，进行处理后再将参数传回给原始方法，所以必须用到ProceedingJoinPoint中的proceed方法，也就是只能使用环绕通知来实现。 环境准备 当输入密码为”root”控制台打印为true,如果密码改为” root “（前后有空格）控制台打印的是false。需求是使用AOP将参数进行统一处理，不管输入的密码前后包含多少个空格，最终控制台打印的都是true。 具体实现不多叨叨，直接展示业务核心代码： 12345678910111213@Around(&quot;fn()&quot;)public Object passwordTrim(ProceedingJoinPoint pjp) throws Throwable &#123; // 核心业务 1、获取参数并格式处理 2、交还给原始方法 Object[] args = pjp.getArgs(); for (int i = 0; i &lt; args.length; i++)&#123; // 判断是否为字符串 if(args[i].getClass().equals(String.class))&#123; args[i] = args[i].toString().trim(); // toString()返回对象的字符串形式 &#125; &#125; Object ret = pjp.proceed(args); return ret;&#125; AOP总结AOP（Aspect Oriented Programming）面向切面编程 AOP是一种编程范式，作用是在不惊动原始设计的基础上为方法进行功能增强。 （1）代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的 （2）连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行 （3）切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述 （4）通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法 （5）切面（Aspect）：描述通知与切入点的对应关系 （6）目标对象（Target）：被代理的原始对象称为目标对象 切入点表达式 1execution([访问修饰符] 返回值 包名.类/接口名.方法名（参数）[异常名]) 三种通配符：*, .., +. 五种通知类型 前置通知、后置通知、环绕通知（重点）、返回后通知、抛出异常后通知. 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用；它可以隔离原始方法的执行；它可以获取原始方法的参数或返回值并进行修改再交还给原始方法；它可以对原始方法的异常进行处理。 通知中获取参数 获取切入点方法的参数：JoinPoint和ProceedingJoinPoint 获取切入点方法返回值Returning：返回后通知、环绕通知 获取切入点方法运行异常信息Throwing：抛出异常后通知、环绕通知","tags":[]},{"title":"03-Spring整合三方框架","date":"2023-06-01T03:33:15.000Z","path":"2023/06/01/03-Spring整合三方框架/","text":"Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方Bean了，下面结合IoC和DI，整合Mybatis框架，加深对Spring的理解。 Spring整合Mybatis（2）","tags":[]},{"title":"利用Git实现多台电脑同步工作","date":"2023-05-26T08:56:31.000Z","path":"2023/05/26/git/","text":"去年新买了一台mac台式机放在宿舍，就不用每天回到宿舍还要把笔记本插上各种线再启动了。有时候在外面写的代码想要回到宿舍继续用台式机写，所以我需要在两台电脑之间实现无缝协作，即需求：两台电脑里同一个文件夹的内容可以相互同步。 首先说一下，我下面总结的只是我使用git的一个小应用，git的功能强大作用远远不止这些，更多的功能仍然等待着去挖掘呢。 安装Git：下载地址 https://git-scm.com/download ，安装一路点next即可。 构建本地仓库1、在本地建立一个目录，在该目录里防止需要同步的文件。 2、在当前目录下打开git控制台 界面为： 3、初始化本地仓库 1git init 输出Initialized empty Git repository in C:/Users/13668/Desktop/git/.git/ 即成功。 4、Add文件到暂存区 1git add . 上述命令是添加所有文件到暂存区，但不包含已删除的。或者使用git add xxx(文件名)来添加指定文件。 5、commit文件到本地仓库 1git commit -m &quot;提交注释&quot; 提交注释为本次提交的说明，这里我直接使用提交的日期作为提交注释。 将本地仓库推送到github上1、在github上创建新仓库 image-20230516110734048 2、将本地仓库与远程仓库关联 一个新建的空仓库会有一个提示页面，对应不同情况的操作命令。我们现在已经创建好本地仓库，需要做的就是将本地仓库推送到远程，也就是情况2。直接复制提示页面给出的命令即可。 image-20230516110844342 添加远程仓库 1git remote add origin git@github.com:KiCheng/Git.git 可以通过如下命令查看与本地仓库关联的远程仓库： 1git remote -v 输出如下： origin &#103;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;:KiCheng/Git.git (fetch)origin &#x67;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;:KiCheng/Git.git (push) 删除与远程仓库的关联： 1git remote rm origin 推送到远程 12git branch -M maingit push -u origin main 再次刷新github中的仓库，本地仓库的内容已经推送到远程了。 将远程仓库clone到本地在另一台安装好了git的电脑上，在文件夹目录下打开git控制台。输入如下代码： 1git clone git@github.com:账户名/仓库名.git 将上述替换成自己的github账户名和仓库名： image-20230526165230679 这就说明clone成功了，在当前文件夹就可以找到远程备份的文件了。","tags":[]},{"title":"02-Spring注解开发","date":"2023-04-04T16:08:54.000Z","path":"2023/04/05/02-Spring注解开发/","text":"Part1记录了关于IOC/DI的配置开发，但是使用起来相对来说还是比较复杂的，要想真正简化开发，就需要用到Spring的注解开发。 关于Spring的注解开发，从Spring2.0开始支持注解，Spring3.0已经支持纯注解开发。关于注解开发，主要学习两块内容：注解开发定义bean和纯注解开发。 IOC/DI注解开发使用注解开发，也就意味着我们需要通过注解的方式，来取代Spring配置文件中的内容。 注解开发定义bean注解定义bean和纯注解开发是有本质区别的，后者完全摒弃了Spring配置文件，而注解定义bean还需要配置文件来做一些工作（包扫描）。 步骤1：配置Spring的注解包扫描 为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描（在配置文件中定义context的命名空间）。 1&lt;context:component-scan base-package=&quot;com.Lijiacheng&quot;/&gt; 步骤2：在Dao类和Service类上添加@Component注解 123456789101112131415161718@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; public void save()&#123; System.out.println(&quot;user dao save...&quot;); &#125;&#125;@Componentpublic class UserServiceImpl implements UserService&#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; System.out.println(&quot;book service save ...&quot;); userDao.save(); &#125;&#125; 一行注解取代了在配置文件中通过&lt;bean&gt;中的id和class属性定义bean。 @Component注解不可以添加在接口上，因为接口是无法创建对象的。 步骤3：在App类中，从IOC容器中获取对应的bean对象 12345ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;);System.out.println(userDao);UserServiceImpl userService = ctx.getBean(UserServiceImpl.class); // 按类型获取beanSystem.out.println(userService); @Component注解如果不起名称，要么通过类型获取bean；要么有一个默认值就是当前类名首字母小写，所以也可以按照名称获取。 @Component的作用是设置该类为spring管理的bean。对于@Component注解，还衍生出了其他三个注解@Controller、@Service、@Repository，这三个注解和@Component注解的作用是一样的，只是方便我们后期在编写类的时候能很好的区分出这个类是属于表现层、业务层、数据层的类。 纯注解开发模式Spring3.0开启了纯注解开发模式，使用Java类替代Spring配置文件。 创建一个类，并将其用注解配置为配置类：替换applicationContext.xml 123@Configurationpublic class SpringConfig &#123;&#125; 用注解替换包扫描配置：@ComponentScan替换&lt;context:component-scan base-package=&quot;&quot;/&gt;（多个数据用数组格式）。 1@ComponentScan(&quot;com.Lijiacheng&quot;) 创建运行类并执行：new一个AnnotationConfigApplicationContext对象 123ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;);System.out.println(userDao); @Configuration作用是设置该类为spring配置类；@ComponentScan作用是设置spring配置类扫描路径，用于加载使用注解格式定义的bean。 注解开发Bean作用范围与生命周期管理Bean作用范围要想将UserDaoImpl变成非单例，只需要在其类上添加@scope注解： 1@Scope(&quot;prototype&quot;) // //@Scope设置bean的作用范围 设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象。默认值singleton（单例），可选值prototype（非单例）。 Bean的生命周期 为了使用@PostConstruct和@PreDestroy注解，导入annotation的坐标依赖： 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 在响应bean类中添加初始化和销毁方法： 12345678@PostConstructpublic void init()&#123; System.out.println(&quot;init...&quot;);&#125;@PreDestroypublic void destroy()&#123; System.out.println(&quot;destroy...&quot;);&#125; 注解开发 小结 注解开发依赖注入Spring为了使用注解简化开发，并没有提供构造函数注入、setter注入对应的注解，只提供了自动装配的注解实现。 注解实现按照类型注入在UserServiceImpl类的userDao属性上添加@Autowired注解： 12345678910@Componentpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void save() &#123; System.out.println(&quot;book service save ...&quot;); userDao.save(); &#125;&#125; @Autowired写在属性上，并将setter方法删除掉。 由于@Autowired是按照类型注入，那么对应UserDao接口如果有多个实现类，这时候运行类就会报错，因为按类型注入就不知道注入哪个对象了，所以要用按名称注入。 还一种解决方案是可以给两个Dao实现类分别起名称： 1234@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;&#125;@Component(&quot;userDao2&quot;)public class UserDaoImpl2 implements UserDao &#123;&#125; 此时就可以注入成功！@Autowired是按照类型注入的，尽管它还是有两个bean对象，但是由于：@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫userDao而容器中也有一个userDao，所以可以成功注入。 但是这种情况就找不到响应的Bean对象，因为容器中没有名称为userDao1或者userDao2的对象： 注解实现按照名称注入当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致（如上图情况），这个时候该如何解决？就需要使用到@Qualifier来指定注入哪个名称的bean对象。 1234567891011@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired @Qualifier(&quot;userDao2&quot;) private UserDao userDao; @Override public void save() &#123; System.out.println(&quot;book service save ...&quot;); userDao.save(); &#125;&#125; 在依赖注入自动装配时，在属性名上用@Qualifier来指定注入名称为 UserDao2 的bean对象（一定要配合Autowired注解使用）。 简单数据类型注入因为Spring只提供了自动装配注入的注解，而自动装配只能注入引用类型的数据。简单类型注入的是基本数据类型或者字符串类型，下面在UserDaoImpl类中添加一个name属性，用其进行简单类型注入： 12@Value(&quot;lijiacheng&quot;) private String name; 注释从@Autowire换成了@Value()，在括号内对属性进行赋值，注意数据格式要匹配。 注解读取properties配置文件@Value一般会被用在从properties配置文件中读取内容进行使用. 使用注解加载properties配置文件：在配置类上添加@PropertySource注解 1@PropertySource(&quot;jdbc.properties&quot;) 使用@Value读取配置文件中的内容： 12@Value(&quot;$&#123;name&#125;&quot;)private String name; @PropertySource注解属性中可以把classpath:加上，代表从当前项目的根路径找文件（但不支持使用通配符*）。 注解开发依赖注入 小结 @Autowired：为引用类型属性设置值； @Qualifier：为引用类型属性指定注入的bean id； @Value：为基本数据类型或字符串类型属性依赖注入并设置值； @PropertySource：加载properties文件中的属性值。 IOC/DI注解开发管理第三方Bean注解开发管理第三方Bean前面定义Bean的时候都是在自己开发的类上面写个注解就完事，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解，第三方的Bean该如何管理？下面以Druid数据源来举例。 导入对应的jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 在SpringConfig配置类中添加方法 123456789@Beanpublic DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;12345&quot;); return ds;&#125; 该方法的返回值就是要创建的Bean对象类型；但new的时候不能new这个DataSource类型，因为DataSource接口中没有对应的setter方法来设置属性。 在方法上添加@Bean注解 从IOC容器中获取对象并打印：按类型获取bean对象 如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。 引入外部配置类如果把所有的第三方bean都配置到Spring的配置类SpringConfig中，虽然可以，但是不利于代码阅读和分类管理，所以我们就想能不能按照类别将这些bean配置到不同的配置类中? 对于数据源的bean,我们新建一个JdbcConfig配置类，并把数据源配置到该类下： 123456789101112@Configurationpublic class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;12345&quot;); return ds; &#125;&#125; 这个配置类如何能被Spring配置类加载到，并在IOC容器中创建DataSource对象？对此有两个解决方案。 使用包扫描引入使用包扫描引入的两个关键点，如果前面书写的代码规范，则这里不需要添加或修改代码：① 在每一个bean的配置类上加注释将其配置为配置类@Configuration； ② 在SpringConfig配置类中添加包扫描@ComponentScan(&quot;com.itheima.config&quot;). 这种方式虽然能够扫描到，但是不能很快的知道都引入了哪些配置类，所以这种方式不推荐使用。 使用@Import引入这种方案可以不用在每一个bean的配置类加@Configuration注解，但是必须在SpringConfig配置类上使用@Import注解手动引入需要加载的配置类： 1234@Configuration@Import(JdbcConfig.class)public class SpringConfig &#123;&#125; 通过@Import引入配置类，不需要在每一个bean配置类加配置注解，而且Spring配置类中的扫描注解可以移除； @Import参数需要的是一个数组，可以引入多个配置类。 引入外部配置类 小结 @Bean是一种方法注解，作用是设置该方法的返回值作为spring管理的bean； @Import是一种类注解，作用是在SpringConfig配置类中定义导入的配置类类名。 注解开发为第三方Bean注入资源在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办？这些资源分为简单数据类型和引用数据类型。 简单数据类型对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取： 1234567891011public class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;12345&quot;); return ds; &#125;&#125; 修改JdbcConfig配置类： 123456789101112131415161718192021@PropertySource(&quot;jdbc.properties&quot;)public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driverName&#125;&quot;) private String driver; @Value(&quot;jdbc.url&quot;) private String url; @Value(&quot;jdbc.username&quot;) private String userName; @Value(&quot;jdbc.password&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 将连接数据库的四要素定义成属性，并通过@Value()设置值注入简单数据类型的依赖，并从jdbc.properties配置中读取相应的属性值进行设置（配置类需要使用@PropertySource(&quot;properties配置文件&quot;)注解）。 引用数据类型假设在构建DataSource对象的时候，需要用到UserDao对象，该如何把BookDao对象注入进方法内让其使用呢？ 在SpringConfig中扫描UserDao（扫描Dao包） 1@ComponentScan(&quot;com.Lijiacheng.dao&quot;) 在JdbcConfig类的方法上添加形参参数 123456789@Beanpublic DataSource dataSource(UserDao userDao)&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds;&#125; 引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。 注解开发总结前面我们已经完成了XML配置和注解的开发实现，至于两者之间的差异，咱们放在一块去对比回顾下：","tags":[]},{"title":"01-IOC/DI","date":"2023-04-04T16:02:48.000Z","path":"2023/04/05/01-IOC_DI/","text":"Spring框架主要的优势是在简化开发和框架整合上，针对特点Spring的学习主线就是IOC、AOP、声明式事务和整合MyBais框架。Part1主要学习IOC容器中的bean、依赖注入以及核心容器。 Spring相关概念初识Spring在 Spring官网 中提供了所有项目统称为Spring全家桶，我们主要需要掌握以下比较流行的技术： Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。 SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。 SpringCloud：这个是用来做分布式微服务架构的相关开发。 Spring系统架构至今Spring已经更新到6.x版本，而下面的是4.x版本的架构图。Spring Framework 的系统架构图只是一种概念上的表示，具体实现和细节可能会根据具体应用场景进行调整和优化，所以我们以4.x版本为例来研究。 （1）核心层 Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块； （2）AOP层 AOP：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强； Aspects：AOP是思想，Aspects是对AOP思想的具体实现； （3）数据层 Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术； Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis； Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容； （4）Web层 这一层的内容将在SpringMVC框架具体学习； （5）Test层 Spring主要整合了Junit来完成单元测试和集成测试。 Spring核心概念这部分内容中主要包含 IOC/DI 、IOC容器 和 Bean。 目前的问题业务层需要调用数据层的方法，就需要在业务层new数据层的对象；如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署，导致项目代码的耦合度偏高。 从上图我们也可以看到，业务层是通过new数据层的对象调用数据层的方法，从而造成耦合度高的问题。如果能把框中的内容给去掉，不就可以降低依赖了，但是如果直接去掉不做任何改动，会造成对象的NullPointer报错 。针对这个问题，Spring就提出了一个解决方案：在使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象，这种实现思想就是Spring的一个核心概念。 IOC、IOC容器、Bean、DI1、IOC（Inversion of Control）控制反转 （1）控制反转：使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。 （2）Spring和IOC的关系：Spring提供了一个容器，称为IOC容器，IOC思想中的“提供对象的外部”指的就是Spring的IOC容器。 （3）IOC容器： IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象； 被创建或被管理的对象在IOC容器中统称为Bean，IOC容器中放的就是一个个的Bean对象； （4）在IOC容器中创建好service对象和dao对象后，要将service对象建立对dao对象的依赖关系，在容器中建立对象与对象之间的绑定关系就要用到 DI。 2、DI（Dependency Injection）依赖注入 依赖注入：在容器中建立bean与bean之间的依赖关系的整个过程称为依赖注入。如业务层需要依赖数据层，service就要和dao建立依赖关系。 使用IOC和DI到达最终解耦的目的，最终结果是使用对象可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。 IOC、DI入门案例 步骤1：在pom.xml导入spring依赖坐标； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 步骤1.5：创建数据层和业务层代码 步骤2：在resource目录下创建spring的配置文件——applicationContext.xml，配置对应类作为Spring管理的Bean； 12&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; Bean定义时，id属性在同一个配置文件中不能重复。 步骤3：使用Spring提供的接口ApplicationContext完成IOC容器的创建； 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 步骤4：从IOC容器中获取对象进行方法调用； 1234UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;);userDao.save();UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);userService.save(); p.s. 标准的项目架构如下： 这时候在业务层仍然是用new创建了数据层的UserDaoImpl对象，为了实现IOC，还需要用到DI依赖注入。 步骤5：删除业务层中通过new方式创建的dao对象 12// private UserDao userDao = new UserDaoImpl();private UserDao userDao; 步骤6：提供对应的setter方法（快捷键：Fn+Alt+Insert） 123public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 因为不再程序中使用new对对象UserDao进行赋值操作，所以要为UserDao对象提供一个赋值的入口，就是setter方法，什么时候调用，谁来调用它会在后续提到。 步骤7：修改配置完成DI注入 12345678910&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;&gt; &lt;!-- 7.配置service与dao的关系--&gt; &lt;!-- property标签表示配置当前的bean属性 name属性表示配置的是哪一个具体的属性 ref属性表示参照的是哪一个bean --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; image-20230402163443276 IOC控制反转前面的入门案例尝试了bean如何定义配置、DI如何定义配置以及容器对象如何获取，接下来主要是把这三块内容展开进行详细的讲解。 Bean基础配置 Bean基础配置 1&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; id：使用id可以获取对应的bean，在一个容器中id值是唯一的 class：bean的类型，配置的bean的全路径类名 Bean别名配置：name属性 为bean指定别名，别名可以有多个，可以使用逗号、分号、空格进行分隔。这样从容器中获取bean对象时就可以使用name里的别名了（ref属性里指定的bean也可以使用别名，但正规写法是使用id属性）。 如果抛出NoSuchBeanDefinitionException的异常，表示从IOC容器中找不到该bean，这时候要去检查配置文件bean中的id属性和name属性，是否和getbean中的参数对应一致。 Bean作用范围配置：scope属性 singleton：单例（默认） prototype：非单例 将同一个bean获取两次，打印看地址输出是否一致： 12UserDao userDao1 = (UserDao) ctx.getBean(&quot;userDao&quot;);UserDao userDao2 = (UserDao) ctx.getBean(&quot;userDao&quot;); 将UserDao这个bean配置为非单例模式： 1&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; ① bean默认为单例是在Spring的IOC容器中只会有该类的一个对象，避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高。 ② 单例模式的bean：如果对象是有状态对象，即该对象有成员变量可以用来存储数据的；因为所有请求线程共用一个bean对象，所以会存在线程安全问题。反之则不存在线程安全问题。 ③ 像表现层、业务层、数据层、工具类对象，这样的bean对象适合交给容器进行管理，它们在单例模式下不会存在线程安全问题，且对bean对象进行复用；而示例对象则不适合交给容器进行管理。 Bean实例化现在bean已经放在了IOC容器中，那容器是如何进行bean的创建的呢？bean本质上是对象，通过new创建对象是调用类的构造方法，所以创建bean也是通过构造方法来完成的。 构造方法实例化在UserDaoImpl类中创建一个无参构造方法： 123public UserDaoImpl() &#123; System.out.println(&quot;userDaoImpl Constructor is running...&quot;);&#125; 控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数： 每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做，这也是我们以后比较常用的一种方式。 静态工厂实例化1、工厂方式创建bean （1）准备一个OrderDao和OrderDaoImpl类 （2）创建一个工厂类OrderDaoFactory并提供一个静态方法 12345public class OrderDaoFactory &#123; public static OrderDao getOrderDao()&#123; return new OrderDaoImpl(); &#125;&#125; （3）编写AppForInstanceOrder运行类，在类中通过工厂获取对象 2、静态工厂实例化 现在bean对象已经创建好了，如何将bean交给Spring来管理呢？ （1）在spring的配置文件applicationContext.properties中添加以下内容： 1&lt;bean id=&quot;orderDao&quot; class=&quot;com.Lijiacheng.dao.OrderDaoFactory&quot; factory-method=&quot;getOrderDao&quot;&gt;&lt;/bean&gt; class：工厂类的类全名； factory-mehod：具体工厂类中创建对象的方法名； （2）在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试（跟前面一致）。 这种方式一般是用来兼容早期的一些老系统，过去使用工厂类创建对象，是为了在new基础上添加一些其他的业务内容。 实例工厂与FactoryBean1、实例工厂方式创建bean （1）准备一个BookDao和BookDaoImpl类 （2）创建一个工厂类OrderDaoFactory并提供一个普通方法（注意此处和静态工厂的工厂类不同之处是方法不是静态方法） （3）编写AppForInstanceBook运行类，在类中通过工厂获取对象 2、实例工厂实例化 （1）在spring的配置文件中添加以下内容： 12&lt;bean id=&quot;bookFactory&quot; class=&quot;com.Lijiacheng.dao.factory.BookDaoFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookFactory&quot; factory-method=&quot;getBookDao&quot;&gt;&lt;/bean&gt; 实例化工厂的运行顺序： 创建实例化工厂对象，对应的是第一行配置； 调用对象中的方法来创建bean，对应的是第二行配置： factory-bean：工厂的实例对象（对应bean的id属性） factory-method：工厂对象中的具体创建对象的方法名，对应关系如下: （2）在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试。 3、FactoryBean Spring为了简化实例工厂进行bean实例化的配置方式就提供了FactoryBean来简化开发。 （1）创建一个BookDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法： 123456789101112public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123; //代替原始实例工厂中创建对象的方法 @Override public BookDao getObject() throws Exception &#123; return new BookDaoImpl(); &#125; //返回所创建类的Class对象 @Override public Class&lt;?&gt; getObjectType() &#123; return BookDao.class; &#125;&#125; 在FactoryBean接口中还有一个方法，默认是不需要重写的，就是isSingleton()，默认是单例模式return true. （2）在Spring的配置文件中进行配置 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.Lijiacheng.dao.factory.BookDaoFactoryBean&quot;/&gt; Bean实例化 小结 bean本质是对象，所以它是通过构造方法来创建的； Spring的IOC实例化对象的三种方式分别是：构造方法、静态工厂、实例工厂，这些方式中主要掌握构造方法和实例工厂中的FactoryBean方法即可； 在使用构造方法实例化对象时，如果重写了构造方法，建议把无参默认构造方法也重写。 Bean的生命周期bean的生命周期就是bean对象从创建到销毁的整体过程。 生命周期设置 bean创建之后添加内容，比如用来初始化需要用到资源 bean销毁之前添加内容，比如用来释放用到的资源 1、在配置文件添加method方式进行生命周期设置 步骤1：添加初始化和销毁的方法（方法名任意） 步骤2：配置生命周期 在配置文件中添加如下配置： 1&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 从执行结果来看，init方法执行了，但destroy方法没有执行。 因为Spring的IOC容器是运行在JVM中，运行main方法后，JVM启动，Spring加载配置文件生成IOC容器，从容器获取bean对象，然后调方法执行main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了，所以没有调用对应的destroy方法。 所以我们需要手动关闭容器来销毁bean。 方式1：close关闭容器 ApplicationContext中没有close方法，需要把ApplicationContext换成它是实现类ClassPathXmlApplicationContext，再调用close()方法即可。 方式2：注册钩子关闭容器 提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器。 1ctx.registerShutdownHook(); // JVM退出前调用关闭，可以放在任意位置 2、实现接口方式进行生命周期设置 添加初始化和销毁方法，既需要编码也需要配置，实现起来步骤比较多也比较乱，Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置init-method和destroy-method。 修改UserServiceImpl类，添加两个接口InitializingBean， DisposableBean并实现接口中的两个方法afterPropertiesSet和destroy. 123456789@Override public void destroy() throws Exception &#123; System.out.println(&quot;service destroy&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init&quot;); &#125; Bean的声明周期和是否getBean没有关系，bean随着加载配置文件生成IOC容器而被创建出来，随着IOC的关闭而销毁。 对于业务层的UserServiceImpl来说，userDao是它的一个属性，setUserDao方法是Spring的IOC容器为其注入属性的方法： 1&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;!-- setter为其注入name属性 --&gt; 而afterPropertiesSet()意为”属性创建之后“，所以bean的初始化方法会在类中属性设置之后执行。 bean的生命周期 小结 （1）关于Spring中对bean生命周期控制提供了两种方式： 在配置文件中的bean标签中添加init-method和destroy-method属性； 类实现InitializingBean与DisposableBean接口（了解即可）。 （2）bean的生命周期 初始化容器 创建对象（new内存分配） 执行构造方法 执行属性注入（setter操作） 执行bean初始化方法（init操作，生命周期开启） 使用bean：执行业务操作 关闭/销毁容器：执行bean销毁方法（destroy） （3）关闭容器的两种方式： close() 方法 registerShutdownHook() 方法 DI依赖注入向一个类中传递数据有2种方式：普通set方法、构造方法；依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，但有时bean运行需要的是数字或字符串。Spring基于上述为我们提供了2种注入方式： setter注入：引用类型、简单类型（这里将String归类到基本类型的注入中，但实际上String是个类，是引用数据类型） 构造器注入：引用类型、简单类型 setter注入setter注入引用类型 在bean中声明引用类型属性，并提供可访问的set方法 12345678private UserDao userDao;private BookDao bookDao;public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125;public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao;&#125; 配置中使用property标签ref属性注入引用类型对象 123456&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao&quot; class=&quot;com.Lijiacheng.dao.Impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 现在userDao、userService、bookDao对象都已经被注入成功。 setter注入简单类型 在bean中声明简单类型属性，并提供可访问的set方法 12345678private String databaseName; // 注入时把String看作简单类型private int connectionNum;public void setDatabaseName(String databaseName) &#123; this.databaseName = databaseName;&#125;public void setConnectionNum(int connectionNum) &#123; this.connectionNum = connectionNum;&#125; 配置中使用property标签注入简单类型对象 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;databaseName&quot; value=&quot;mysql&quot;&gt;&lt;/property&gt; &lt;property name=&quot;connectionNum&quot; value=&quot;10&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 构造器注入构造器注入引用数据类型 删除属性的setter方法并提供构造方法 1234private UserDao userDao;public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; 配置中使用constructor-arg标签注入引用类型对象 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 在constructor-arg标签中，name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。 构造器注入简单数据类型 删除属性的setter方法并提供构造方法 123456private String databaseName;private int connectionNum;public UserDaoImpl(String databaseName, int connectionNum) &#123; this.databaseName = databaseName; this.connectionNum = connectionNum;&#125; 注意：添加完构造方法后在配置文件中出现bean中class属性的报错： image-20230403103009826 意思是找不到匹配的构造函数，说明在使用构造函数创建bean的时候，默认的无参构造被覆盖了，只要重写一遍无参构造即可。 配置中使用constructor-arg标签注入简单类型对象 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;666&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 依赖注入 小结 强制依赖（强制依赖指对象在创建的过程中必须要注入指定的参数）使用构造器进行；可选依赖（可选依赖指对象在创建过程中注入的参数可有可无）使用setter注入进行，灵活性强。 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨；实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入。 自己开发的模块推荐使用setter注入（推荐setter）。 依赖自动装配IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配，从而简化配置文件的配置编写。 自动装配只需要修改applicationContext.xml配置文件： 123&lt;bean id=&quot;userDao&quot; class=&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;/&gt;&lt;!-- autowire属性：开启自动装配，通常使用按类型装配 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot; autowire=&quot;byType&quot;/&gt; 使用自动装配需要注意的点：① 需要注入属性的类中对应属性的setter方法不能省略；② 被注入的对象必须要被Spring的IOC容器管理；③ 按照类型装配在Spring的IOC容器中只能有该类型的唯一对象。 一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入：autowire=&quot;byName&quot;. 自动装配 自动装配用于引用类型依赖注入，不能对简单类型进行操作。 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用；使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用。 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效。 集合注入前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型集合，集合中既可以装简单数据类型也可以装引用数据类型，在Spring中该如何注入呢？ 12345678910111213141516public class UserDaoImpl implements UserDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; private Properties properties; public void save() &#123; System.out.println(&quot;user dao save ...&quot;); System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array)); System.out.println(&quot;遍历List&quot; + list); System.out.println(&quot;遍历Set&quot; + set); System.out.println(&quot;遍历Map&quot; + map); System.out.println(&quot;遍历Properties&quot; + properties); &#125; //setter....方法省略，自己使用工具生成&#125; 下面的所以配置方式，都是在userDao的bean标签中使用进行注入： 注入数组类型数据： 1234567&lt;property name=&quot;array&quot;&gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 注入List类型数据： 1234567&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;zhongguo&lt;/value&gt; &lt;value&gt;shandong&lt;/value&gt; &lt;value&gt;qingdao&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 注入Set类型数据： 12345678&lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;zhongguo&lt;/value&gt; &lt;value&gt;shandong&lt;/value&gt; &lt;value&gt;qingdao&lt;/value&gt; &lt;value&gt;qingdao&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 注入Map类型数据： 1234567&lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;country&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;henan&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;kaifeng&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 注入Properties类型数据： 1234567&lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;country&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;henan&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;kaifeng&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写&lt;array&gt;、&lt;list&gt;、&lt;set&gt;、&lt;map&gt;、&lt;props&gt;标签 List的底层也是通过数组实现的，所以&lt;list&gt;和&lt;array&gt;标签是可以混用 集合中要添加引用类型，只需要把&lt;value&gt;标签改成&lt;ref&gt;标签，这种方式用的比较少 IOC/DI配置管理第三方bean前面的配置都是基于我们自己写的类，那么该如何管理第三方jar包中的类？ 数据源对象管理以后我们会用到很多第三方的bean，下面将使用数据源Druid和C3P0来学习配置。 实现Druid管理 导入最新版的Druid依赖坐标和mysql坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 在配置文件中配置第三方bean 12345678&lt;!-- 管理Druid对象 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- setter配置属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;12345&quot;/&gt; &lt;/bean&gt; Druid对象通过setter注入依赖，是因为在对象的上层类DruidDataSource中提供了属性的set方法。 从IOC容器中获取对应的bean对象(DruidDataSource) 实现C3P0管理 导入最新版的C3P0坐标和mysql坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt;&lt;/dependency&gt; 在配置文件中配置第三方bean 12345678&lt;!-- 管理c3p0对象 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;12345&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;1000&quot;/&gt; &lt;/bean&gt; Druid和C3P0在没有导入mysql驱动包的前提下虽然没有报错，说明在初始化的时候没有去加载驱动，但是在获取数据库连接的时候，也会报找不到驱动类的错误，所以在导入依赖坐标的时候除了导入数据库连接池的坐标外还要导入mysql的坐标。 加载properties文件这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护，需要将这些值提取到一个外部的properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。 resources下创建一个jdbc.properties文件（名字任意），并添加对应的属性键值对： 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/mybatisjdbc.username=rootjdbc.password=12345 开启 context 命名空间 直接copy配置文件中bean的命名空间并修改这5处为：context即可。 加载properties配置文件 12&lt;!-- 使用context命名空间下的标签来加载properties配置文件 --&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; 完成属性注入 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; &lt;context:property-placeholder/&gt;标签会加载系统的环境变量，而且环境变量的值会被优先加载，可以在该标签上增添属性system-properties-mode=&quot;NEVER&quot;避免加载系统环境变量。 加载多个properties文件 12345678&lt;!--方式一 --&gt;&lt;context:property-placeholder location=&quot;jdbc.properties,jdbc2.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;&lt;!--方式二--&gt;&lt;context:property-placeholder location=&quot;*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;&lt;!--方式三 --&gt;&lt;context:property-placeholder location=&quot;classpath:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;&lt;!--方式四--&gt;&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 方式三是标准的写法，classpath:代表的是从根路径下开始查找，但是只能查询当前项目的根路径；方式四不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件。 核心容器讲完bean与依赖注入，接下来我们主要学习的是IOC容器中的核心容器。 容器创建核心容器 类路径下的XML配置文件 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 文件系统下的XML配置文件（从项目路径下开始查找，不推荐使用） 1ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;applicationContext.xml的绝对路径&quot;); 获取Bean的三种方式 方式1：每次获取的时候都需要进行类型转换 1UserDao userDao = (UserDao) ctx.getBean(&quot;UserDao&quot;); 方式2：可以解决类型强转问题，但是加了一个参数 1UserDao userDao = ctx.getBean(&quot;UserDao&quot;，BookDao.class); 方式3：按class类型获取bean，必须要确保IOC容器中该类型对应的bean对象只能有一个 1BookDao bookDao = ctx.getBean(BookDao.class); BeanFactory容器的最上级的父接口为BeanFactory，可以使用BeanFactory来创建IOC容器。 BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建；ApplicationContext是立即加载，容器加载的时候就会创建bean对象。ApplicationContext要想成为延迟加载，只需要在配置文件中配置lazy-init=&quot;true&quot;。 核心容器总结容器 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载；ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载。 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类：ClassPathXmlApplicationContext bean 整个配置最常用的就两个属性：id和class。 依赖注入","tags":[]},{"title":"07-Filter_Listener_Ajax","date":"2023-04-01T10:30:31.000Z","path":"2023/04/01/07-Filter-Listener-Ajax/","text":"这块知识点比较杂，而且Ajax是代替jsp的前端技术，了解即可。 Filter&amp;Listener&amp;AjaxFilterFilter表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。Servlet 我们之前都已经学习过了，Filter和Listener我们今天都会进行学习。过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。 正常情况下浏览器可以访问服务器上的所有的资源，而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter： 过滤器一般完成一些通用的操作：比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。 我们之前做的品牌数据管理就已经做了登录的功能，但不登录的时候也可以通过首页的超链接访问到全部数据，这显然不符合我们的要求。我们希望如果登录过就跳转到品牌数据展示的页面，没有登录就跳转到登录界面，但如果要实现这个效果就要在每个资源中写上这段逻辑。像这种通用的操作，就可以用过滤器来实现，这就是过滤器的权限控制。 Filter快速开发 定义类，实现Filter接口，并重写其中的所有方法； 配置Filter拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源； 在doFilter方法中执行通用业务，并放行（chain.doFilter(req,resp); 就是放行，也就是让其访问本该访问的资源） 1234567891011@WebFilter(&quot;/*&quot;)public class FilterDemo01 implements Filter &#123; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;FilterDemo01...&quot;); filterChain.doFilter(servletRequest,servletResponse); // 放行 &#125; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; Filter执行流程 可以总结Filter的执行流程如下： 以后我们可以将对请求进行处理的代码在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行处理。 Filter拦截路径配置拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。 拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截； 目录拦截：/user/*：访问/user下的所有资源，都会被拦截； 后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截； 拦截所有：/*：访问所有资源，都会被拦截。 过滤器链指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。 在FilterDemo01中： 123System.out.println(&quot;1.FilterDemo...&quot;);filterChain.doFilter(servletRequest,servletResponse);System.out.println(&quot;5.FilterDemo...&quot;); 在FilterDemo2中： 123System.out.println(&quot;2.FilterDemo...&quot;); filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;4.FilterDemo...&quot;); 在服务器动态资源hello.jsp中： 123&lt;% System.out.println(&quot;3.hello jsp...&quot;);%&gt; 访问服务器中的jsp资源，可以根据打印的信息看到web请求和响应是如何通过过滤器链执行的： 但是为什么，我们配置的FilterDemo1和FilterDemo2的拦截路径是一致的，为什么会先执行1再执行2呢？使用的是注解配置Filter，这种配置方式的优先级是按照过滤器类名（字符串）的自然排序。 Filter应用——登录校验 这块应用在上一个projectJavaWeb_06_Cookie_Session里补充代码。在web目录下创建filter目录新建LoginFilter过滤器即可，通过判断session中是否有user对象就可以判断用户是否登录，代码很简单就不记录了。 但是我们看到的效果是这样的（先删除浏览器缓存的记录），这是为什么呢？因为登陆页面需要 css/login.css 文件进行样式渲染，但是这个文件在filter中被拦截了，导致没有加载到样式文件，为了解决这个问题，需要对所有的登陆相关的资源进行放行。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 过滤器LoginFilter的完整代码： 1234567891011121314151617181920212223242526272829303132@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 在数组中存储登陆和注册相关的资源路径，优先将他们放行 String[] urls = &#123;&quot;/login.jsp&quot;,&quot;/imgs/&quot;,&quot;/css/&quot;,&quot;/loginServlet&quot;,&quot;/register.jsp&quot;,&quot;/registerServlet&quot;,&quot;/checkCodeServlet&quot;&#125;; HttpServletRequest request = (HttpServletRequest) servletRequest; String requestURL = request.getRequestURL().toString(); for(String url: urls)&#123; if(requestURL.contains(url))&#123; // 需要放行的资源url filterChain.doFilter(servletRequest,servletResponse); return; &#125; &#125; // 放行前 -- 判断用户是否登录 HttpSession session = request.getSession(); Object user = session.getAttribute(&quot;user&quot;); if(user != null)&#123; // 已经登录过 -- 放行 filterChain.doFilter(servletRequest,servletResponse); &#125;else&#123; // 未登录 -- 跳转到登录界面 request.setAttribute(&quot;login_msg&quot;,&quot;未登录，请先登录！&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(servletRequest,servletResponse); &#125; &#125; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; ListenerListener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。监听器可以监听在 application，session，request 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。 request和session我们学习过。而 application 是 ServletContext 类型的对象（ServletContext 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象）。 分类JavaWeb 提供了8个监听器，只有 ServletContextListener 这个监听器后面会用到，ServletContextListener 是用来监听 ServletContext 对象的创建和销毁。 ServletContextListener 接口中有以下两个方法： void contextInitialized(ServletContextEvent sce)：ServletContext 对象被创建了会自动执行的方法； void contextDestroyed(ServletContextEvent sce)：ServletContext 对象被销毁时会自动执行的方法。 实现对于 ServletContextListener 监听器： 定义一个类，实现ServletContextListener 接口，重写所有的抽象方法 使用 @WebListener 进行配置 123456789101112@WebListenerpublic class ContextLoaderListener implements ServletContextListener&#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; //加载资源 System.out.println(&quot;ContextLoaderListener...&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; //释放资源 &#125;&#125; AJAXAJAX (Asynchronous JavaScript And XML)是异步的 JavaScript 和 XML。 AJAX概述AJAX作用1、与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。 之前我们是这样做功能： image-20230330213503973 Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL标签库 进行数据的展示。 而我们学习了AJAX 后，就可以使用AJAX和服务器进行通信，以达到使用 HTML+AJAX 来替换JSP页面了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。 image-20230330213640794 2、异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术（搜索联想、用户名是否可用校验）。 同步和异步 同步发送请求 浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。 异步发送请求过程如下 浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。 快速入门服务端实现 1234567891011@WebServlet(&quot;/ajaxServlet&quot;)public class AjaxServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(&quot;hello ajax~&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 客户端实现 12345678910111213141516171819&lt;script&gt; //1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest(); &#125; else &#123; // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2. 发送请求 xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/ajaxServlet&quot;); xhttp.send(); //3. 获取响应 xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; alert(this.responseText); &#125; &#125;;&lt;/script&gt; image-20230330220341705 查看异步请求： image-20230330220604851 Ajax应用需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在。 后端实现123456789@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 接收用户名数据 String username = request.getAttribute(&quot;username&quot;).toString(); // 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用 boolean flag = true; // 响应标记 response.getWriter().write(&quot;&quot; + flag);&#125; 前端实现123456789101112131415161718192021222324252627282930313233&lt;script&gt; //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(&quot;username&quot;).onblur = function () &#123; //2. 发送ajax请求 // 获取用户名的值 var username = this.value; //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest(); &#125; else &#123; // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.2. 发送请求 xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/selectUserServlet?username=&quot; + username); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //判断 if(this.responseText == &quot;true&quot;)&#123; //用户名存在，显示提示信息 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125;else &#123; //用户名不存在 ，清楚提示信息 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; &#125; &#125;; &#125;&lt;/script&gt; AxiosAxios 对原生的AJAX进行封装，简化书写。 Axios官网：https://www.axios-http.cn 基本使用 引入 axios 的 js 文件 1&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt; 使用axios发送请求，并获取响应结果 get请求 123456axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;&#125;).then(function (resp)&#123; alert(resp.data);&#125;) post请求 1234567axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;, data:&quot;username=zhangsan&quot;&#125;).then(function (resp) &#123; alert(resp.data);&#125;) JSONJSON概述JSON是JavaScript对象的表示法。 JavaScript对象的定义格式： 12345&#123; name:&quot;zhangsan&quot;, age:23, city:&quot;北京&quot;&#125; JSON格式 12345&#123; name:&quot;zhangsan&quot;, age:23, city:&quot;北京&quot;&#125; js对象中的属性名可以使用引号（单引号或双引号）；而json格式中的键要求必须使用双引号括起来，这是 json格式的规定。 作用：由于其语法格式简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。像通过response.getWriter()就是服务端给浏览器响应的数据，有些数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该怎么做呢？ 以前是通过xml进行数据传递： 12345&lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;city&gt;北京&lt;/city&gt;&lt;/student&gt; json描述（ 格式数据的简单、所占的字节数少）： 12345&#123; &quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:23, &quot;city&quot;:&quot;北京&quot;&#125; JSON基础语法定义格式JSON本质就是一个字符串，但是该字符串内容是有一定的格式要求的：键要求必须使用双引号括起来，而值根据要表示的类型确定。 1var 变量名 = &#x27;&#123;&quot;key&quot;:value,&quot;key&quot;:value,...&#125;&#x27;; value的数据类型如下：数字（整数或浮点数）、字符串（双引号）、逻辑值（true或false）、数组（在方括号中）、对象（在花括号中）、null。 如果需要获取到该 JSON串中的属性值，应该怎么处理呢？ 如果它是一个 js 对象，我们就可以通过 js对象.属性名 的方式来获取数据。JS 提供了一个对象JSON，该对象有如下两个方法： parse(str) ：将 JSON串转换为 js 对象。使用方式是：var jsObject = JSON.parse(jsonStr); stringify(obj) ：将 js 对象转换为 JSON 串。使用方式是：var jsonStr = JSON.stringify(jsObject) 代码演示： 123456789101112&lt;script&gt; //1. 定义JSON字符串 var jsonStr = &#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27; alert(jsonStr); //2. 将 JSON 字符串转为 JS 对象 let jsObject = JSON.parse(jsonStr); alert(jsObject) alert(jsObject.name) //3. 将 JS 对象转换为 JSON 字符串 let jsonStr2 = JSON.stringify(jsObject); alert(jsonStr2)&lt;/script&gt; 发送异步请求携带参数使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON格式进行传递。可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为JSON串，再将该 JSON串作为 axios 的 data 属性值进行请求参数的提交（axios会自动将 js 对象转换为JSON串进行提交）。 12345678var jsObject = &#123;name:&quot;张三&quot;&#125;;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/axiosServlet&quot;, data:jsObject //这里 axios 会将该js对象转换为 json 串的&#125;).then(function (resp) &#123; alert(resp.data);&#125;) 发送异步请求时，如果请求参数是JSON格式，那请求方式必须是POST。因为JSON串需要放在请求体中。 JSON串和Java对象的相互转换以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。 在后端我们就需要重点学习以下两部分操作： 请求数据：JSON字符串转为Java对象； 响应数据：Java对象转为JSON字符串； Fastjson 概述阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，可以实现 Java对象和 JSON字符串的相互转换。 基本使用 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.23&lt;/version&gt;&lt;/dependency&gt; JSON对象转换成Java对象 1User user = JSON.parseObject(jsonStr, User.class); Java对象转换成JSON对象 1String jsonStr = JSON.toJSONString(obj); JSON对象和Java对象的相互转换： 12345678910// 将Java对象转换成Json对象 User user = new User(); user.setId(1); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123&quot;); String jsonString = JSON.toJSONString(user); System.out.println(jsonString); // 将Json对象转换城Java对象 User u = JSON.parseObject(jsonString,User.class); System.out.println(u);","tags":[]},{"title":"06-会话技术","date":"2023-04-01T10:27:23.000Z","path":"2023/04/01/06-会话技术/","text":"会话跟踪是web程序中常用的技术，常用的会话跟踪技术是Cookie 和Session。 会话跟踪技术对于会话跟踪，首先要理解什么是会话，然后再去理解什么是会话跟踪： 会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。 从浏览器发出请求到服务端响应数据给前端之后，一次会话（在浏览器和服务器之间）就被建立了； 会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着； 浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称为会话。 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。 服务器会收到多个请求，这多个请求可能来自多个浏览器； 服务器需要识别请求是否来自同一个浏览器，这个过程就是会话跟踪； 服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据。 多次请求间的数据共享：购物网站的购物车结算；页面展示用户登录信息（发送多次请求都显示信息）；网站登录的”记住我“功能；登录页面的验证码功能（声明验证码和点击登录也是两次请求，需要进行比对才能登陆成功） 但是目前的浏览器和服务器之间不支持数据共享：浏览器和服务器之间使用的是HTTP请求来进行数据传输，而HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求（HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响），请求与请求之间独立后，就无法实现多次请求之间的数据共享。 会话跟踪分为客户端的会话跟踪和服务端的会话跟踪技术。 CookieCookie的基本使用Cookie是一种客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。 Cookie的工作流程 服务端提供了两个Servlet，分别是ServletA和ServletB； 浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理； 服务端ServletA在处理的过程中可以创建一个Cookie对象并将name=zs的数据存入Cookie； 服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器； 浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就建立了一次会话； 在同一次会话中浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据； ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享。 Cookie的基本使用1、发送Cookie 创建Cookie对象，并设置数据 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 发送Cookie到客户端：使用response对象 1response.addCookie(cookie); 通过Servlet向客户端发送一个Cookie： image-20230329181624169 2、获取Cookie 获取客户端携带的所有Cookie，使用request对象 1Cookie[] cookies = request.getCookies(); 遍历数组获取每一个Cookie对象，使用Cookie对象方法获取数据 1cookie.getName(); 1cookie.getValue(); 在访问AServlet后关闭浏览器，重启浏览器后访问BServlet就无法获取到Cookie中的数据，因为重启浏览器之后就不是一次会话了。 Cookie原理分析对于Cookie的实现原理是基于HTTP协议的，其中涉及到HTTP协议中的两个请求头信息：响应头 set-cookie、请求头 cookie 对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据；当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在响应头中添加一行数据Set-Cookie:username=zs； 浏览器获取到响应结果后，从响应头中就可以获取到Set-Cookie对应值username=zs,并将数据存储在浏览器的内存中； 浏览器再次发送请求给BServlet的时候，浏览器会自动在请求头中添加Cookie: username=zs发送给服务端BServlet； Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组，BServlet通过Request对象获取Cookie。 可以验证一下： image-20230329210416050 Cookie的使用细节Cookie的存活时间正像前面提到的，在访问AServlet后关闭浏览器，重启浏览器后访问BServlet就无法获取到Cookie中的数据。在默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁。那么如何将Cookie持久化存储？ 设置Cookie存活时间 1setMaxAge(int seconds) 参数为： 正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储，到时间自动删除； 负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁； 0：删除对应Cookie。 Cookie存储中文Cookie不能直接存储中文，当cookie里存储中文时访问服务器资源时会报错。所以我们可以用URL编解码的方式，在cookie中存字节数据。 SessionSession的基本使用Session是一种服务端会话跟踪技术，将数据保存到服务端。 Session是存储在服务端而Cookie是存储在客户端； 存储在客户端的数据容易被窃取和截获，存在很多不安全的因素存储在服务端的数据相比于客户端来说就更安全。 Session的工作流程 在服务端的AServlet获取一个Session对象，把数据存入其中； 在服务端的BServlet获取到相同的Session对象（如何保证使用的是同一个Session对象），从中取出数据； 就可以实现一次会话中多次请求之间的数据共享了。 Session的基本使用 获取Session对象，使用的是request对象 1HttpSession session = request.getSession(); Session对象提供的功能 存储数据到session域中 1void setAttribute(String name, Object o) 根据 key，获取值 1Object getAttribute(String name) // Session中是一个Object类型的数据，也就是说Session中可以存储任意数据类型 根据 key，删除该键值对 1void removeAttribute(String name) 可以自己写个Servlet就能看到Session是能够在一次会话中两次请求之间共享数据的。 Session的原理分析Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个；我们可以在Session 的两个Servlet中分别print出创建的Session对象： image-20230329214508736 那么如果关闭浏览器再重新打开呢？这时候就不是同一个session对象了，所以Session实现的也是一次会话中多次请求之间的数据共享。 image-20230329215505220 Session保证在一次会话中获取的Session对象是同一个（基于Cookie） image-20230329215911579 demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是id:10； demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器； Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识id:10当做一个cookie，添加Set-Cookie:JESSIONID=10到响应头中，并响应给浏览器； 浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中； 浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照Cookie: JESSIONID=10的格式添加到请求头中并发送给服务器Tomcat； demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找id:10的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象； 关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象。 可以看一下在同一会话的两次请求中的Cookie数据： image-20230329221834266 image-20230329221909633 Session的使用细节Session的钝化和活化服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中；当服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了。但是对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对——服务器就是通过Session的钝化和活化做到的。 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中 活化：再次启动服务器后，从文件中加载数据到Session中（数据加载到Session中后，路径中的文件会被删除掉） 小结： session数据存储在服务端，服务器重启后，session数据会被保存； 浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象； session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据；cookie是存储在客户端，可以长期保存。 Session销毁 默认情况下，无操作，30分钟自动销毁；对于这个失效时间，是可以通过在web.xml配置进行修改的。 1&lt;session-config&gt; 1&lt;session-timeout&gt;100&lt;/session-timeout&gt; &lt;!-- 单位是mins --&gt; 1&lt;/session-config&gt; 调用Session对象的invalidate()进行销毁 Cookie和Session小结Cookie 和 Session 都是来完成一次会话内多次请求间的数据共享。 区别： 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端； 安全性：Cookie不安全，Session安全； 数据大小：Cookie最大3KB，Session无大小限制； 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟； 服务器性能：Cookie不占服务器资源，Session占用服务器资源； 应用场景（不绝对）： 购物车：使用Cookie来存储； 以登录用户的名称展示：使用Session来存储； 记住我功能：使用Cookie来存储； 验证码：使用Session来存储； 会话跟踪在登陆注册中的应用登录功能登录功能做完了，很无语…本来几分钟就能搞定的事花了俩小时，一直识别不到xml映射文件，我反复检查namespace和核心配置文件无果，偶然发现我竟然将mapper下的xml映射文件放在了webapp目录而不是resource目录……欲哭无泪…… 登录功能的业务逻辑是：在登录时（第一次请求）将用户数据存入session中，并进行数据共享到登陆成功页面以及其他页面（第二次请求）。由于是一次会话的多次请求，所以共享session中的数据不能用请求转发只能用重定向，这里值得注意一下。 ”记住我“功能在服务器端创建Cookie对象分别存储username和password，add到客户端，这时候可以看到response的响应头中存在Set-Cookie： image-20230330111257163 下一步是在客户端页面获取Cookie，将数据设置到登陆页面的用户名和密码框中。在页面可以使用EL表达式获取Cookie： 在jsp页面中修改代码： 12&lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot; type=&quot;text&quot;&gt;&lt;/p&gt;&lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; value=&quot;$&#123;cookie.password.value&#125;&quot; type=&quot;password&quot;&gt;&lt;/p&gt; 用户注册功能业务逻辑是：前端通过表单将注册的用户名和密码传给RegisterServlet，调用Service层register，如果注册成功则跳转到登录界面并给提示；如果注册失败则重新跳转到注册界面并给提示。 验证码的生成和校验 验证码的作用：防止机器自动注册，攻击服务器 这段业务比较陌生是第一次见到，记录下详细的实现过程。 生成二维码 验证码的生成是通过工具类来实现的，具体的工具类参考CheckCodeUtil.java，编写main方法进行测试： 1234567public static void main(String[] args) throws IOException &#123; //生成验证码的图片位置 OutputStream fos = new FileOutputStream(&quot;d://a.jpg&quot;); //checkCode为最终验证码的数据 String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4); System.out.println(checkCode);&#125; 实现流程分析 测试类是通过OutputStream流将图片生成到磁盘，可以通过reponse对象的getOutputStream()字节输出流将图片响应给页面。 具体实现 （1）修改Register.jsp页面，将验证码图片从后台获取 123456&lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt; &lt;!-- 将验证码的图片从后台获取 --&gt; &lt;img id=&quot;checkCodeImg&quot; src=&quot;/JavaWeb_06_Cookie_Session/checkCodeServlet&quot;&gt; &lt;a href=&quot;&quot; id=&quot;changeImg&quot;&gt;看不清？&lt;/a&gt;&lt;/td&gt; （2）CheckCodeServlet用来接收请求生成验证码 12345678910111213@WebServlet(&quot;/checkCodeServlet&quot;)public class CheckCodeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 生成验证码 ServletOutputStream os = response.getOutputStream(); String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 校验二维码 判断生成的验证码和用户输入的验证码是否一样，如果不一样，则阻止注册。验证码图片访问和提交注册表单是两次请求，所以要将程序生成的验证码存入Session中。 实现流程分析 （1）在CheckCodeServlet中生成验证码的时候，将验证码数据存入Session对象； （2）前端将验证码和注册数据提交到后台，交给RegisterServlet类； （3）RegisterServlet类接收到请求和数据后，其中就有验证码，和Session中的验证码进行对比； （4）如果一致，则完成注册，如果不一致，则提示错误信息。 具体实现 （1）修改CheckCodeServlet类，将验证码存入Session对象 123// 将生成的验证码存入Session对象HttpSession session = request.getSession();session.setAttribute(&quot;checkCode&quot;,checkCode); （2）在RegisterServlet中，获取页面的和session对象中的验证码，进行对比 123456789101112// 获取用户输入的验证码String checkCode = request.getParameter(&quot;checkCode&quot;);// 获取Session中的验证码HttpSession session = request.getSession();Object s_checkCode = session.getAttribute(&quot;checkCode&quot;);// 将二者进行比对if(!s_checkCode.equals(checkCode))&#123; // 验证码错误，无法注册 -- 跳转到注册jsp并给予提示 request.setAttribute(&quot;register_msg&quot;,&quot;验证码错误，请重新输入！&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response); return ;&#125;","tags":[]},{"title":"05-JSP","date":"2023-04-01T10:21:03.000Z","path":"2023/04/01/05-JSP/","text":"JSP（全称：Java Server Pages），Java 服务端页面。是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容， JSP = HTML + Java。虽然说JSP技术早已过时了，但是在很多国企银行还在使用它，可以把JSP当作javaweb的发展史来学习一下。 JSPJSP到底是什么作用呢？在前面我们使用Servlet在网页端进行动态展示，当时使用了writer.write()向前端写html标签内容进行展示，这样我们的代码就显得很麻烦。在JSP中，用html展示静态页面，用java代码展示动态数据，从而简化开发，避免了在Servlet中直接输出HTML标签。 JSP快速入门123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;% System.out.println(&quot;Hello, JSP!&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; JSP原理JSP 本质上就是一个 Servlet，看一看访问JSP时的流程： （1）浏览器第一次访问 hello.jsp 页面 （2）tomcat 会将 hello.jsp 转换为名为 hello_jsp.java 的一个 Servlet （3）tomcat 再将转换的 servlet 编译成字节码文件 hello_jsp.class （4）tomcat 会执行该字节码文件，向外提供服务 在Servlet当中是需要我们编写代码将数据write到页面上去，但是在JSP中通过生成相应的Servlet，tomcat自动帮我们完成了这项工作。 JSP脚本分类： &lt;%…%&gt;：内容会直接放到_jspService()方法之中； &lt;%=…%&gt;：内容会放到out.print()中，作为out.print()的参数； &lt;%!…%&gt;：内容会放到_jspService()方法之外，被类直接包含 JSP缺点 书写麻烦：既要写 HTML 标签，还要写 Java 代码 前后端没有分离 调试困难：出错后，需要找到自动生成的.java文件进行调试 EL表达式EL（Expression Language ）表达式语言，用于简化 JSP 页面内的 Java 代码。 EL 表达式的主要作用是获取数据：就是从域对象中获取数据，然后将数据展示在页面上。而 EL 表达式的语法也比较简单，语法形式为：$&#123;expression&#125; 。例如：$&#123;brands&#125; 就是获取域中存储的 key 为 brands 的数据。 我们定义一个Servlet，在域对象中存储一些数据，然后通过数据共享（请求转发）的方式令JSP资源获取数据并展示。 12345678910@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;(); brands.add(new Brand(1,&quot;三只松鼠&quot;,&quot;三只松鼠&quot;,100,&quot;三只松鼠，好吃不上火&quot;,1)); brands.add(new Brand(2,&quot;优衣库&quot;,&quot;优衣库&quot;,200,&quot;优衣库，服适人生&quot;,0)); brands.add(new Brand(3,&quot;小米&quot;,&quot;小米科技有限公司&quot;,1000,&quot;为发烧而生&quot;,1)); req.setAttribute(&quot;brands&quot;,brands); req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req,resp); &#125; 在index.jsp资源中通过EL表达式获取数据到页面即可，但是要注意在标签中加入isELIgnored=&quot;false&quot;表示不忽略EL表达式。 域对象 JavaWeb中有四大域对象，分别是： page：当前页面有效 request：当前请求有效 session：当前会话有效 application：当前应用有效 例如$&#123;brands&#125;el 表达式获取数据，会先从page域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。 JSTL标签JSP标准标签库(Jsp Standarded Tag Library) ，使用标签取代JSP页面上的Java代码。 JSTL 使用也是比较简单的，分为如下步骤： 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 在JSP页面上引入JSTL标签库 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; if标签123456&lt;c:if test=&quot;$&#123;status == 1&#125;&quot;&gt; 启用 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;status == 0&#125;&quot;&gt; 禁用 &lt;/c:if&gt; foreach标签用法一： items：被遍历的容器 var：遍历产生的临时变量 varStatus：遍历状态对象 123456789&lt;c:forEach items=&quot;$&#123;brands&#125;&quot; var=&quot;brand&quot; varStatus=&quot;status&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 用法二 begin：开始数 end：结束数 step：步长 123&lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; step=&quot;1&quot; var=&quot;i&quot;&gt; $&#123;i&#125;&lt;/c:forEach&gt; MVC模式和三层架构MVC模式MVC 是一种分层开发的模式，其中： M：Model，业务模型，处理业务 V：View，视图，界面展示 C：Controller，控制器，处理请求，调用模型和视图 控制器（Serlvlet）用来接收浏览器发送过来的请求，控制器调用模型（JavaBean）来获取数据，比如从数据库查询数据；控制器获取到数据后再交由视图（JSP）进行数据展示。 MVC 好处： 有利于分工协作 有利于组件重用 三层架构三层架构是将我们的项目分成了三个层面：分别是表现层、业务逻辑层、数据访问层。 数据访问层：对数据库的CRUD基本操作； 业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如“注册业务功能” ，我们会先调用 数据访问层 的 selectByName() 方法判断该用户名是否存在，如果不存在再调用 数据访问层 的 insert() 方法进行数据的添加操作； 表现层：接收请求，封装数据，调用业务逻辑层，响应数据。 整个流程是，浏览器发送请求，表现层的Servlet接收请求并调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法调用数据访问层方法进行数据的操作，依次返回到Serlvet，然后Servlet将数据交由 JSP 进行展示。 三层架构的每一层都有特有的包名称： 表现层： com.Lijiacheng.controller 或者 com.Lijiacheng.web 业务逻辑层：com.Lijiacheng.service 数据访问层：com.Lijiacheng.dao 或者 com.Lijiacheng.mapper MVC和三层架构三层架构是对MVC 模式实现架构的思想。 那么我们以后按照要求将不同层的代码写在不同的包下，每一层里功能职责做到单一，将来如果将表现层的技术换掉，而业务逻辑层和数据访问层的代码不需要发生变化。 实现增删改查这里使用三层架构做增删改查的基础操作，开发流程总结为： 分析业务（最重要！） 写sql映射配置文件 声明与sql配置文件对应的mapper接口函数 编写service层代码，调用接口函数进行业务实现 编写Servlet代码，通常是接收数据并将其请求转发进行数据共享 1、查询全部数据 ​ 这个没什么好说的，在Servlet中将brands集合里的数据共享给相应展示的jsp页面即可。 2、增加数据 ​ 业务逻辑是：在查询全部数据页面中点击链接进入添加数据的jsp页面，将jsp页面的表单数据发送给相应的Servlet，在Servlet中接收数据并封装成brand对象，调用业务逻辑层和数据访问层函数将数据添加到数据库当中；最后不要忘记了请求转发回到”查询所有”的资源。 3、修改数据 ​ 业务逻辑是：①在查询全部数据页面中点击某行数据的链接，从数据库中根据id找到对应的数据信息将它们回显到修改数据的jsp页面上。回显的流程是，通过调用”根据用户查询“的函数，将数据封装在一个brand对象中，并请求转发给修改数据的jsp页面来接收。②在前端页面修改数据后，通过将form表单中的数据传递到修改数据的Servlet中，将封装了属性的对象作为参数调用业务逻辑层和数据访问层函数将数据在数据库中进行修改，最后仍然是回到”查询所有”的资源。 在”增加“业务和”修改“业务时，需要将表单的数据通过post请求方式传递给服务器，由于存在中文乱码问题，如果不在Servlet中首先通过setCharacterEncoding进行设置，就会出现get到的参数是乱码的问题，这里特别注意一下。 4、删除数据 ​ 根据id删除，跟上面的selectById业务基本一致，就不说了。","tags":[]},{"title":"04-Request_Response","date":"2023-04-01T10:14:47.000Z","path":"2023/04/01/04-Request-Response/","text":"request和response对象代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行；要向容器输出数据，只需要找response对象就行。 Resquest &amp; ResponseRequest和Response的概述Request是请求对象，Response是响应对象。这两个对象在我们使用Servlet的时候有看到： request：获取请求数据 浏览器会发送HTTP请求到后台服务器(Tomcat) HTTP的请求中会包含很多请求数据（请求行+请求头+请求体） 后台服务器(Tomcat)会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中 所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数 获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务 response：设置响应数据 业务处理完后，后台就需要给前端返回业务处理的结果即响应数据 把响应数据封装到response对象中 后台服务器(Tomcat)会解析response对象,按照（响应行+响应头+响应体）格式拼接结果 浏览器最终解析结果，把内容展示在浏览器给用户浏览 1234567891011121314@WebServlet(urlPatterns = &quot;/demo1&quot;)public class ServletDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 使用request对象，获取请求数据 String name = req.getParameter(&quot;name&quot;); // url?name=lijiacheng // 使用response对象，设置响应数据 resp.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); resp.getWriter().write(&quot;&lt;h1&gt;&quot; + name + &quot;，欢迎您！&lt;/h1&gt;&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; image-20230328142421229 request对象用来处理来自客户端的请求数据，比如接收请求参数等；responese对象根据接收的数据进一步设置发送给客户端的响应数据。 Request对象Request继承体系 ServletRequest和HttpServletRequest都是Java提供的接口，接口无法创建对象。 这个时候，我们就需要用到Request继承体系中的RequestFacade： 该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口； Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器([Tomcat)来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建。 Tomcat（RequestFacade实现类）需要解析请求数据，封装为request对象,并且创建request对象传递到service方法 Request获取请求数据获取请求行数据 获取请求方式: GET 1String getMethod() 获取虚拟目录(项目访问路径): /JavaWeb_04_Request_Response 1String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/JavaWeb_04_Request_Response/req1 1StringBuffer getRequestURL() 获取URI(统一资源标识符): /JavaWeb_04_Request_Response/req1 1String getRequestURI() 获取请求参数**(GET方式)**: username=zhangsan&amp;password=123 1String getQueryString() 由上到下依次获取的结果： 获取请求头数据根据请求头名称获取对应值的方法为： 1String getHeader(String key) 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下： 请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是： 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法： 1ServletInputStream getInputStream() 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法： 1BufferedReader getReader() 在req.html中创建form表单传递请求参数，获取字符输入流读取数据： 123456789@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取post的请求体数据 //1. 获取字符输入流 BufferedReader reader = req.getReader(); //2. 读取数据 String result = reader.readLine(); System.out.println(result);&#125; 获取到的POST方法的请求体数据： image-20230328145615868 获取请求参数的通用方式 请求数据则是包含请求行、请求头和请求体的所有数据。请求参数和请求数据的关系：请求参数是请求数据中的部分内容；如果是GET请求，请求参数在请求行中；如果是POST请求，请求参数一般在请求体中。 GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种统一获取请求参数的方式，从而统一doGet和doPost方法内的代码? request的方法中实现了如下操作： （1）根据不同的请求方式获取请求参数，获取的内容如下: image-20230328161112744 （2）把获取到的内容进行分割： （3）把分割后端数据，存入到一个Map集合中： 基于上述操作，request对象为我们提供了如下方法： 获取所有参数Map集合 1Map&lt;String,String[]&gt; getParameterMap() 根据名称获取参数值（数组） 1String[] getParameterValues(String name) 根据名称获取参数值（单个值）——使用频率比较高 1String getParameter(String name) 下面进行获取请求参数的演示（后续使用的方法）： （1）创建一个req.html的表单 1234567&lt;form action=&quot;/JavaWeb_04_Request_Response/req2&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 爬山 &lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; （2）在Servlet代码中获取页面传递请求的参数值 123456789101112131415161718192021@WebServlet(urlPatterns = &quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;get...&quot;); // 获取所有参数的map集合 Map&lt;String, String[]&gt; map = req.getParameterMap(); for (String key : map.keySet()) &#123; System.out.print(key + &quot;: &quot;); String[] values = map.get(key); for(String value : values)&#123; System.out.print(value + &quot; &quot;); &#125; System.out.println(); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;post...&quot;); &#125;&#125; GET方式传递请求参数： image-20230328163623631 后端接收到的GET方式的请求参数： image-20230328163711898 剩下两个getParameterValues()和getParameter()一个return类型是String[]，一个return类型是String，按需使用即可，这里就不展示了。 在传递POST请求的参数也如上述所示，只需要修改前端表单的请求类型为POST即可，在Servlet类的doPost()里只需要： 1this.doGet(req,resp); 请求参数中文乱码问题不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。 POST请求解决方案 分析出现中文乱码的原因： POST的请求参数是通过request的getReader()来获取流中的数据 TOMCAT在获取流的时候采用的编码是ISO-8859-1 ISO-8859-1编码是不支持中文的，所以会出现乱码 解决方案： 1request.setCharacterEncoding(&quot;UTF-8&quot;); 但这种方式不适用于GET请求。 GET请求解决方案request.setCharacterEncoding(&quot;utf-8&quot;)是设置request处理流的编码，但是GET获取请求参数的方式是request.getQueryString()，它并没有通过流的方式获取参数。 先分析一下GET请求出现乱码的原因： (1)浏览器通过HTTP协议发送请求和数据给后台服务器(Tomcat) (2)浏览器在发送HTTP的过程中会对中文数据进行URL编码 (3)在进行URL编码的时候会采用页面&lt;meta&gt;标签指定的UTF-8的方式进行编码，“张三”编码后的结果为”%E5%BC%A0%E4%B8%89“ (4)后台服务器(Tomcat)接收到%E5%BC%A0%E4%B8%89后会默认按照ISO-8859-1进行URL解码 (5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。 关于URL编解码，Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码： 1java.net.URLEncoder.encode(&quot;需要被编码的内容&quot;,&quot;字符集(UTF-8)&quot;) // encode 1java.net.URLDecoder.decode(&quot;需要被解码的内容&quot;,&quot;字符集(UTF-8)&quot;) // decode 我们可以发现：在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的%E5%BC%A0%E4%B8%89是一致的，所以具体的解决方案为：① 按照ISO-8859-1编码获取乱码å¼ ä¸对应的字节数组；② 按照UTF-8编码获取字节数组对应的字符串。 Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8。 Request请求转发请求转发(forward)是一种在服务器内部的资源跳转方式。 (1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求； (2)资源A处理完请求后将请求发给资源B； (3)资源B处理完后将结果响应给浏览器； (4)请求从资源A到资源B的过程就叫请求转发。 请求转发的实现方式 1req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp); 请求转发资源间共享数据 需要使用request对象提供的三个方法： 存储数据到request域[范围,数据是存储在request对象]中 1void setAttribute(String name,Object o); 根据key获取值 1Object getAttribute(String name); 根据key删除该键值对 1void removeAttribute(String name); 请求转发的特点 浏览器地址栏路径不发生变化：虽然后台从/req3转发到/req4,但是浏览器的地址一直是/req4，未发生变化 只能转发到当前服务器的内部资源：不能从一个服务器通过转发访问另一台服务器 一次请求，可以在转发资源间使用request共享数据：虽然后台从/req3转发到/req4`，但是这个只有一次请求 Response对象Response继承体系 Response设置响应数据 响应行 对于响应头，比较常用的就是设置响应状态码： 1void setStatus(int sc); 响应头 设置响应头键值对： 1void setHeader(String name,String value); 响应体 对于响应体，是通过字符、字节输出流的方式往浏览器写。 获取字符输出流： 1PrintWriter getWriter(); 获取字节输出流： 1ServletOutputStream getOutputStream(); Response请求重定向Response重定向(redirect)是另一种资源跳转方式。 (1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求； (2)资源A现在无法处理该请求，就会给浏览器响应一个302状态码和location一个访问资源B的路径； (3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B； (4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向。 重定向实现方式 12resposne.setStatus(302);resposne.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;); // &quot;/JavaWeb_04_Request_Response/resp2&quot; 或者用简化后的一行代码： 1resposne.sendRedirect(&quot;/JavaWeb_04_Request_Response/resp2&quot;) 重定向的特点 浏览器地址栏路径发送变化：当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化； 可以重定向到任何位置的资源（服务内容、外部均可）：因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源； 两次请求，不能在多个资源使用request共享数据：因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据。 请求转发和重定向的比较： image-20230328201650015 什么时候用项目访问路径，什么时候不需要？ 判断的依据很简单，只需要记住下面的规则即可: 浏览器使用：需要加虚拟目录(项目访问路径) 服务端使用：不需要加虚拟目录 对于请求转发来说，因为是在服务端进行的，所以不需要加虚拟目录；对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。同时，由于虚拟目录的项目路径是硬编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改。可以在使用虚拟目录时动态配置，降低代码的耦合度： 12String contextPath = request.getContextPath(); response.sendRedirect(contextPath+&quot;/resp2&quot;); // 重定向 Response响应字符数据要想将字符数据写回到浏览器，我们需要两个步骤： 通过Response对象获取字符输出流： 1PrintWriter writer = resp.getWriter(); 通过字符输出流写数据： 1writer.write(&quot;aaa&quot;); 在之前要记得设置服务器发送给浏览器的数据类型和数据编码格式： 1response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); 等于 response.setHeader(&quot;content-type&quot;, &quot;text/html&quot;); 和response.setCharacterEncoding(&quot;utf-8&quot;); 两句。 一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。 Response响应字节数据要想将字节数据写回到浏览器，我们需要两个步骤： 通过Response对象获取字节输出流： 1ServletOutputStream outputStream = resp.getOutputStream(); 通过字节输出流写数据： 1outputStream.write(字节数据); 实现方式1 1234567891011121314@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1、读取文件 FileInputStream fis = new FileInputStream(&quot;src/main/webapp/picture.jpg&quot;); // 2、获取response字节流 ServletOutputStream outputStream = response.getOutputStream(); // 3、完成流的copy byte[] buff = new byte[1024]; int len = 0; while ((len = fis.read(buff))!= -1)&#123; outputStream.write(buff,0,len); &#125; fis.close(); &#125; 实现方式2 我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是： （1）pom.xml添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt; （2）调用工具类方法 1IOUtils.copy(fis,os); // fis:输入流 os:输出流 优化后的实现方式： 12345678910@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1、读取文件 FileInputStream fis = new FileInputStream(&quot;src/main/webapp/picture.jpg&quot;); // 2、获取response字节流 ServletOutputStream outputStream = response.getOutputStream(); // 3、完成流的copy IOUtils.copy(fis,outputStream); fis.close(); &#125;","tags":[]},{"title":"03_Servlet","date":"2023-03-28T02:14:31.000Z","path":"2023/03/28/03-Servlet/","text":"Servlet是JavaWeb最为核心的内容，它是Java提供的一门动态web资源开发技术。 Servlet 使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容 Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet Servlet快速入门1、导入Servlet依赖坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;!-- provided指的是在编译和测试过程中有效,最后生成的war包时不会加入 因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错 --&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2、定义一个类，实现Servlet接口，并重写接口中所有方法 3、在类上使用@WebServlet注解，配置该Servlet的访问路径 1@WebServlet(&quot;/demo1&quot;) Servlet执行流程 浏览器发出http://localhost:8080/JavaWeb_03_Servlet/demo1请求，从请求中可以解析出三部分内容，分别是localhost:8080、JavaWeb_03_Servlet、demo1 根据localhost:8080可以找到要访问的Tomcat Web服务器 根据JavaWeb_03_Servlet可以找到部署在Tomcat服务器上的JavaWeb_03_Servlet项目 根据demo1可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配 找到ServletDemo_01这个类后，Tomcat Web服务器就会为ServletDemo_01这个类创建一个对象，然后调用对象中的service方法 ServletDemo_01实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用 service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互 生命周期生命周期：指一个对象从被创建到被销毁的整个过程 Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段： 加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象 默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建？ 1234@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)/* loadOnstartup的取值有两类情况 （1）负整数:第一次访问时创建Servlet对象 （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高 */ 初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作，该方法只调用一次 请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理 服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收。 Servlet体系结构 我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会通过继承HttpServlet的方式代替实现接口。 123456789101112@WebServlet(urlPatterns = &quot;/demo2&quot;)public class ServletDemo_02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;get...&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;post...&quot;); &#125;&#125; 发送GET请求就不说了，发送POST请求需要在html页面中创建一个表单传递请求参数，举个例子： 12345&lt;body&gt; &lt;form action=&quot;/JavaWeb_03_Servlet/demo2&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;/&gt;&lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;/body&gt; 为什么HttpServlet中要根据请求方式的不同，调用不同的方法？ 前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理。 urlPattern配置Servlet类编写好后，要想被访问到，就需要配置其访问路径。 urlPattern配置规则： 精确匹配 12//配置路径@WebServlet(&quot;/user/select&quot;) 访问路径为 http://localhost:8080/JavaWeb_03_Servlet/user/select 目录匹配 12//配置路径@WebServlet(&quot;/user/*&quot;) 访问路径 http://localhost:8080/JavaWeb_03_Servlet/user/aaa 、http://localhost:8080/JavaWeb_03_Servlet/user/bbb 等等 扩展名匹配 12//配置路径@WebServlet(&quot;*.do&quot;) 访问路径为 http://localhost:8080/JavaWeb_03_Servlet/任意.do 如果路径配置的不是扩展名，那么在路径的前面就必须要加/否则会报错； 如果路径配置的是*.do,那么在*.do的前面不能加/,否则会报错！ 任意匹配 12//配置路径@WebServlet(&quot;/&quot;) 访问路径为 http://localhost:8080/JavaWeb_03_Servlet/任意 当我们的项目中的Servlet配置了 “/“,会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet。DefaultServlet是用来处理静态资源，如果配置了”/“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问。 上面这段话如何理解呢？我们在访问静态资源例如html静态页面时，http://localhost:8080/JavaWeb_03_Servlet/a.html，但是由于进行了任意匹配覆盖了DefaultServlet，在访问该路径时就会走这个任意匹配的Servlet，而a.html就访问不到啦。 XML配置前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。这里只需要了解一下即可，现在几乎不会在web.xml中进行配置了。 123456789101112131415161718192021&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Servlet 全类名 --&gt; &lt;servlet&gt; &lt;!-- servlet的名称，名字任意--&gt; &lt;servlet-name&gt;demo2&lt;/servlet-name&gt; &lt;!--servlet的类全名--&gt; &lt;servlet-class&gt;com.Lijiacheng.web.ServletDemo_02&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- Servlet 访问路径 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的名称，要和上面的名称一致--&gt; &lt;servlet-name&gt;demo2&lt;/servlet-name&gt; &lt;!-- servlet的访问路径--&gt; &lt;url-pattern&gt;/demo2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;","tags":[]},{"title":"03_HTTP&Tomcat","date":"2023-03-28T02:10:41.000Z","path":"2023/03/28/03-HTTP-Tomcat/","text":"今天记录一下HTTP协议和一种目前使用最广泛的轻量级web服务器——Tomcat！ JavaWeb什么是Web Web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。 JavaWebB/S架构Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。 B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 静态资源静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 动态资源在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容。动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理；动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 数据库数据库(DB)主要负责存储数据。 整个web访问过程如下图所示： (1) 浏览器发送一个请求到服务端，去请求所需要的相关资源;(2) 资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;(3) 在Java代码可以进行业务处理也可以从数据库中读取数据;(4) 拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;(5) 服务端将静态资源响应给浏览器;(6) 浏览器将这些资源进行解析;(7) 解析后将效果展示在浏览器，用户就可以看到最终的结果。 HTTP协议超文本传输协议（HTTP）是一个用于传输超媒体文档（例如HTML）的应用层协议。 它是为Web 浏览器与Web 服务器之间的通信而设计的，但也可以用于其他目的。 HTTP 遵循经典的客户端—服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。 Web服务器浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器。后续我们使用一款轻量级最popular的Tomcat服务器。 HTTPHTTP简介HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。 如果想知道具体的格式，可以打开浏览器，打开开发者工具，点击Network来查看某一次请求的请求数据和响应数据具体的格式内容： HTTP协议特点 HTTP协议有它自己的一些特点，分别是: 基于TCP协议: 面向连接，安全 TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。 基于请求-响应模型的:一次请求对应一次响应 请求和响应是一一对应关系 HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的 无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点： 缺点:多次请求间不能共享数据 优点:速度快 请求之间无法共享数据会引发的问题，如: 京东购物，加入购物车和去购物车结算是两次请求， HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据 请求数据格式 请求行：请求方式 请求头：key-value格式 服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求 请求体：POST请求的最后一部分，存储请求参数 GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中 GET请求请求参数大小有限制，POST没有 响应数据格式 响应行：状态码、状态码描述 响应头：key-value 响应体：存放响应数据 200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 TomcatWeb服务器Web服务器是一个应用程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。 Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器中的页面就可以直接通过浏览器来访问了。 Web浏览器的作用：①封装HTTP协议操作，简化开发；②可以将Web项目部署到服务器中，对外提供网上浏览服务。 因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。Tomcat的官网: https://tomcat.apache.org/ 基本使用（这边暂时先省略不掌握） Maven创建Web项目新创建好的Web项目结构如下： 要注意pom.xml中的打包方式为&lt;packaging&gt;war&lt;/packaging&gt;，默认为jar。 IDEA使用TomcatMaven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可，但是这种方式非常不方便。 集成本地Tomcat配置Tomcat属性 xxx.war和 xxx.war exploded这两种部署项目模式的区别：war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容；war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署。建议使用war模式进行部署。 Tomcat插件集成还有一种更简单的方式，那就是直接使用Maven中的Tomcat插件来部署项目： 1、在pom.xml中添加Tomcat插件 12345678910&lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 集成 Tomcat7--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven –&gt; tomcat7:run","tags":[]},{"title":"02_Mybatis练习","date":"2023-03-28T02:05:29.000Z","path":"2023/03/28/02-Mybatis练习/","text":"前面记录了mybatis，它是一种简化jdbc开发操作关系型数据库的持久层框架。下面我们用mybatis进行一些简单的业务来操作mysql数据库。基础的操作和代码我就不完整的展示了，我就记录一下比较容易出错的地方和需要注意的细节了。 Mybatis CRUD查询全部selectAll操作很简单，但是我们发现有些数据没有被封装成功，仍然是null： image-20230326151900257 这是为什么呢，原因还要从mapper代理开发的过程来说起。因为在代理开发中通过接口代理对象调用接口中的函数，再在相应的sql映射文件中找sql语句： 1select * from tb_brand; 找到的sql语句没问题，而它在编译的时候是变成了： 1select id,brand_name,company_name,ordered,description,status from tb_brand; sql语句执行后会从数据库中select出满足条件的数据，将其封装成定义的Brand类的对象并通过List集合的形式返回。但是在mapper代理开发的过程中封装成Brand对象的过程是自动进行的，那么mybatis并不知道brand_name数据应该被set成Brand对象中的brandName属性，这就是问题的关键。 要解决这个问题的思路就是将二者形成映射关系，让mybatis在封装的时候能将其对应上。目前在mybatis上有两种解决的方案： 给字段起别名 直接在sql语句中用AS起别名即可，但是这样操作非常麻烦！ 还有一种方法，mybatis提供了sql片段可以提高sql语句的复用性，但仍然非常麻烦而且不灵活：将需要复用的sql片段抽取到标签中，在sql语句中使用引用即可。 使用resultMap映射 在sql映射配置文件中使用resultMap定义属性和字段的映射关系： 123456789101112&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; 标签的id属性，要在下面sql映射文件的sql语句标签中引用，表示在这段sql代码中使用了如上的resultMap映射关系以自动封装数据；而type属性则和sql语句中的type一致即可，都指向pojo中的某个实体类。 123&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand; &lt;/select&gt; 现在再看从封装到Brand对象中的数据就没问题了： image-20230326154957319 按照id查询在这里记录一下如何在映射配置文件的sql语句中使用参数占位符。 这是在映射文件中的sql语句： 123&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot; resultType=&quot;brand&quot;&gt; select * from tb_brand where id = #&#123;id&#125;; &lt;/select&gt; mybatis中提供了两种参数占位符： #{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值，可以看出使用#{} 底层使用的是 PreparedStatement ${} ：拼接SQL。底层使用的是 Statement，会存在SQL注入问题，所以不使用它。 对于有参数的mapper接口方法，我们在sql映射配置文件中应该配置 ParameterType 来指定参数类型。只不过该属性都可以省略。 还需要注意的一点是可能会在sql映射文件中的sql语句中用到一些特殊字符，比方说： xml文件会将sql中的”&lt;”、”&gt;”识别成标签符号，所以需要用相应的转义字符替代，这个用到的时候网上一搜就行了。 多条件查询如何编写接口方法： 使用 @Param(&quot;参数名称&quot;) 标记每一个参数，在映射配置文件中就需要使用 #&#123;参数名称&#125; 进行占位 1List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName,@Param(&quot;brandName&quot;) String brandName); 将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和实体类属性名保持一致。 1List&lt;Brand&gt; selectByCondition(Brand brand); 将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和map集合中Key的名称一致。 1List&lt;Brand&gt; selectByCondition(Map map); 如何使用动态SQL：用户在输入条件时，肯定不会所有的条件都填写 1234567891011121314&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125;; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 单个条件的动态sql： 用里面标签，相当于switch和case。 添加 注意1：如果要通过add、update等对数据库里的数据进行改动，那需要在测试类中手动使用sqlSession.commit()提交事务。 注意2：主键返回——在数据添加成功后，有时候需要获取插入数据库数据的主键。 useGeneratedKeys：是够获取自动增长的主键值。true表示获取 keyProperty ：指定将获取到的主键值封装到哪儿个属性里 1&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 修改修改肯定不会修改数据所有的属性，&lt;*set*&gt; 标签可以用于动态包含需要更新的列，忽略其它不更新的列。 批量删除编写SQL时需要遍历数组来拼接SQL语句，Mybatis 提供了 foreach 标签供我们使用。 foreach 标签 用来迭代任何可迭代的对象（如数组，集合）。 collection 属性： mybatis会将数组参数，封装为一个Map集合。 默认：array = 数组 使用@Param注解改变map集合的默认key的名称 item 属性：本次迭代获取到的元素。 separator 属性：集合项迭代之间的分隔符。foreach 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。 open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次 close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次 12345678&lt;!-- 批量删除 --&gt; &lt;delete id=&quot;deleteByIds&quot;&gt; delete from tb_brand where id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; ; &lt;/delete&gt; 接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。 1User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); 注解开发CRUD使用注解开发会比使用sql配置文件开发更加方便，使用了注解，就不需要再映射配置文件中书写对应的 statement。 官方文档是这么说的： image-20230327154233410 所以给出的结论是：简单sql用注解开发，复杂sql仍然用sql映射配置文件。 举个例子： 12345/** * 删除 * */@Delete(&quot;delete from tb_brand where id = #&#123;id&#125;;&quot;)public void deleteById(int id);","tags":[]},{"title":"02_Mybatis","date":"2023-03-28T02:02:05.000Z","path":"2023/03/28/02-Mybatis/","text":"Mybatis是一款很重要的开发框架！ MybatisMybatis概述​ MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。 持久层：负责将数据到保存到数据库的那一层代码。开发中我们会将操作数据库的Java代码作为持久层，而Mybatis就是对jdbc代码进行了封装。（JavaEE三层架构：表现层、业务层、持久层） JDBC缺点 硬编码 注册驱动、获取连接 上图①的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。 SQL语句 上图②的代码。如果表结构发生变化，SQL语句就要进行更改，这也不方便后期的维护。 操作繁琐 手动设置参数 手动封装结果集 上图④的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。 Mybatis的优化 硬编码可以配置到配置文件 操作繁琐的地方mybatis都自动完成 Mybatis快速入门1、在pom.xml中导入依赖坐标 至少需要：Mybatis、Mysql依赖 直接去找：https://mvnrepository.com/ 2、编写Mybatis核心配置文件 在模块下的 resources 目录下创建mybatis的配置文件 mybatis-config.xml，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.Lijiacheng.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;12345&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;12345&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3、编写sql映射文件（统一管理sql语句，解决硬编码问题） 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;usermapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.Lijiacheng.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 4、编码 在pojo包下创建User的javaBean类。 创建测试类，内容如下： 12345678910111213141516public class MybatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取sqlSession对象，用来执行sql语句 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;usermapper.selectAll&quot;); //该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; Mybatis的硬编码配置都可以在官方文档中找到：https://mybatis.org/mybatis-3/zh/getting-started.html Mybatis代理开发代理开发概述之前使用Mybatis的时候也存在硬编码问题： image-20230325192705282 这里调用 selectList() 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式则不存在硬编码问题： 通过上面的描述可以看出 Mapper 代理方式的目的： 解决原生方式中的硬编码 简化后期执行SQL 使用Mapper代理开发 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下 设置SQL映射文件的namespace属性为Mapper接口全限定名 1&lt;mapper namespace=&quot;com.Lijiacheng.mapper.UserMapper&quot;&gt; 在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 ​ 在接口声明相应函数后，点击左侧mapper小图标可以跳转到xml映射文件相应id的sql语句上。 测试类中内容： 12345678910111213141516public class MybatisDemo_Mapper &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取sqlSession对象，用来执行sql语句 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取接口代理对象 UserMapper usermapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = usermapper.selectAll(); System.out.println(users); //4.释放资源 sqlSession.close(); &#125;&#125; 另外，使用Mapper代理的方法，在mapper接口和sql映射文件同名的前提下，可以在mybatis核心配置文件中通过包扫描的方式简化sql映射文件的加载。 123456 &lt;mappers&gt; &lt;!--加载sql映射文件--&gt;&lt;!-- &lt;mapper resource=&quot;com/Lijiacheng/mapper/UserMapper.xml&quot;/&gt; --&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.Lijiacheng.mapper&quot;/&gt; &lt;/mappers&gt; 核心配置文件类型别名 在sql映射配置文件中的 resultType 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 类型别名(typeAliases) 可以简化这部分的书写。 首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下： 1234&lt;typeAliases&gt; &lt;!--name属性的值是实体类所在包--&gt; &lt;package name=&quot;com.Lijiacheng.pojo&quot;/&gt; &lt;/typeAliases&gt; 通过上述的配置，我们就可以简化映射配置文件中 resultType 属性值的编写： 12345&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; &lt;!-- 如果没配置&lt;typeAliases&gt;的话，必须是类的全限定名 --&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 小结最后我们总结一下Mybatis进行代理开发的流程： 1、首先和入门的开发流程相同，需要进行核心配置文件的配置、以及在resource目录下创建sql映射文件。 核心配置文件可以从mybatis官网上直接copy：https://mybatis.org/mybatis-3/zh/（我居然在谷歌搜索引擎上找不到，这里记录一下） 配置文件需要注意的两个点，如下图： image-20230326142309667 配置类型别名，简化sql映射文件 123&lt;typeAliases&gt; &lt;package name=&quot;com.Lijiacheng.pojo&quot;/&gt; &lt;/typeAliases&gt; 加载sql映射配置时进行包扫描（特别是在以后开发中有多个sql映射文件时） 1234&lt;mappers&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.Lijiacheng.mapper&quot;/&gt; &lt;/mappers&gt; sql映射文件需要注意的几个点： image-20230326143114568 namespace属性对应的是mapper目录下的mapper接口 id属性对应的是接口中声明的方法，这里的id属性要和接口方法名一致！ resultType属性可以直接使用别名，习惯上直接用实体类名即可（前提要配置类型别名） 2、在mapper目录下创建和sql映射文件同名的mapper接口，声明方法 3、实体类一定要有啊，这个不用说了 4、测试类前面也是一样的，唯一不同的就是需要获取一个接口代理对象： 1UserMapper usermapper = sqlSession.getMapper(UserMapper.class); 通过这个对象可以调用接口中声明的函数，接口中的函数和sql映射文件中的id值相同，这样就找到了需要执行的sql语句，这样就可以操作数据库了，并通过你调用的函数返回结果。 还有一个比较重要的点： 当你Bean类中的成员变量和操作数据库的数据名不同时，如何产生映射关系。这个放在后面的帖子里记录会比较容易懂。","tags":[]},{"title":"02_Maven","date":"2023-03-28T01:53:53.000Z","path":"2023/03/28/02-Maven/","text":"Maven是专门用于管理和构建Java项目的工具。 Maven他的主要功能有： 提供一套标准化的项目结构： ​ 所有的IDE使用Maven构建的项目完全一样，IDE创建的Maven项目可以通用。如下图就是Maven构建的项目结构： 标准化的构建流程： ​ 代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 依赖管理： ​ 依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。 ​ 而Maven使用标准的 坐标 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。 Maven简介Maven模型 ​ 紫色框框起来的部分，他就是用来完成标准化构建流程 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。 ​ ​ 上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标。依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包。 仓库​ 我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。 仓库分类： 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 地址： https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 ​ 我们在使用坐标指定项目依赖时，如果是之前使用过的依赖，那么它在本地仓库中（你电脑上设置的maven本地仓库目录）就存在，直接从本地拿；如果是第一次导入该依赖，会先从远程仓库中找，再从中央仓库中找，把相应的jar包下载到本地仓库中，再导入maven项目中。 Maven配置1、配置本地仓库 ​ 修改 conf/settings.xml 中的 为一个指定目录作为本地仓库，用来存储jar包。 2、配置私服 中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 修改 conf/settings.xml 中的 标签。 Maven生命周期Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。 Maven 对项目构建的生命周期划分为3套，默认(default)生命周期如下： 同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。 Maven使用Maven坐标坐标是Maven项目资源的唯一标识，用坐标来定义项目或引入项目中需要的依赖。 Maven坐标组成： groupId：定义当前Maven项目隶属组织名称（通常是域名反写） artifactId：定义当前Maven项目名称 version：定义当前项目版本号 上述的资源坐标可以指项目、依赖、插件。当我们的项目被作为其他项目的依赖时，也是需要坐标来导入的。 依赖管理在项目的 pom.xml 中编写 标签，在子标签 中定义坐标的 groupId，artifactId，version。具体的坐标可以在https://mvnrepository.com/上查找。 快捷方式：Alt+Fn+Insert导入常用依赖。 ​ （我的评价是不如Springboot！！！） 依赖范围： 通过设置坐标的依赖范围，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile Y Y Y logback test - Y - Junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 system Y Y - 存储在本地的jar包 如果引入坐标不指定 scope 标签时，默认就是 compile 值。以后大部分jar包都是使用默认值。","tags":[]},{"title":"01_JDBC","date":"2023-03-28T01:44:15.000Z","path":"2023/03/28/01-JDBC/","text":"​ 现在企业早就不使用这种繁琐的技术了，但是学过了JDBC才能更好的理解后面的开发框架。 JDBC​ JDBC是一款使用 Java语言赖操作关系型数据库的一套API；它为不同的关系型数据库提供了一套标准的API接口。 JDBC快速入门（1）导入驱动包：操作哪个关系型数据库就需要导入该数据库的驱动包。将mysql驱动包放在模块的lib目录下，并添加为库文件； mysql驱动jar包下载地址：https://dev.mysql.com/downloads/connector/j/ （2）代码步骤： 12345678910111213141516171819202122public class JDBCDemo &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 注册驱动(可省略) Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 获取链接 String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;; String username = &quot;xxxxx&quot;; String password = &quot;xxxxx&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 定义mysql语句 String sql = &quot;update tb_user set password = &#x27;20221&#x27; where username=&#x27;ljc&#x27;;&quot;; // 获取执行sql对象Statement Statement statement = conn.createStatement(); // statement执行sql语句 int count = statement.executeUpdate(sql); // 数据库增删改操作返回的都是受影响的行数，int类型 // 返回处理结果 System.out.println(count); // 释放资源 statement.close(); conn.close(); &#125;&#125; JDBC API1、DriverManager驱动管理类 注册驱动 （mysql5自动注册） 获取数据库的连接 1Connection conn = DriverManager.getConnection(url, username, password); 2、Connection数据库连接对象 获取执行sql的statement对象 普通执行 1Statement statement = conn.createStatement(); 预编译执行 – 防止sql注入 1PreparedStatement statement = conn.prepareStatement(sql); // 预编译直接将sql语句传进来 事务管理 Mysql事务管理(mysql中默认自动提交): ①开启事务：Begin; 或 Transaction; ②提交事务：Commit; ③回滚事务：Rollback; Connection中定义了3个对应的方法： 开启事务：true表示自动提交事务，false表示手动提交事务，而开启事务需要将该参数设为为false。 1conn.setAutoCommit(false); 提交事务 1conn.commit(); 回滚事务 1conn.rollback(); 事务管理的意义： 123456789101112131415161718192021try &#123; // ============开启事务========== conn.setAutoCommit(false); //5. 执行sql int count1 = stmt.executeUpdate(sql1); //6. 处理结果 System.out.println(count1); int i = 3/0; //5. 执行sql int count2 = stmt.executeUpdate(sql2); //6. 处理结果 System.out.println(count2); // ============提交事务========== //程序运行到此处，说明没有出现任何问题，则需求提交事务 conn.commit();&#125; catch (Exception e) &#123; // ============回滚事务========== //程序在出现异常时会执行到这个地方，此时就需要回滚事务 conn.rollback(); e.printStackTrace();&#125; 3、Statement对象 ​ 用来执行sql代码。 执行数据增删改以及数据库、表、列的定义： 1int count = statement.excuteUpdate(sql); 表中查询 1ResultSet rs = statement.executeQuery(sql); 4、ResultSet结果集对象 ​ 封装了sql查询语句的结果。 ​ 遍历查询结果中所有数据： 12345678910// 1 光标向下移动一行，并且判断当前行是否有数据 while (rs.next())&#123; // 2 获取数据 getXxx() int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); double money = rs.getDouble(&quot;money&quot;); System.out.println(id); System.out.println(name); System.out.println(money); &#125; 5、PreparedStatement对象 ​ 预编译sql语句并执行，防止sql注入。 sql注入：通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。 模拟sql注入 123String name = &quot;xxxxxx&quot;; String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;; String sql = &quot;select * from tb_user where username = &#x27;&quot; + name + &quot;&#x27; and password = &#x27;&quot; + pwd + &quot;&#x27;&quot;; 上面的sql代码是将name和pwd拼接而成的，拼接后的sql代码为： 1select * from tb_user where username = &#x27;xxxxxx&#x27; and password = &#x27;&#x27; or &#x27;1&#x27; = &#x27;1&#x27; PreparedStatement 先前使用Statement对象执行sql代码的步骤： ① 定义参数以及sql语句 ② statement.executeUpdate(sql)执行 使用PreparedStatement预编译执行步骤： ① 定义sql语句，占位符用 ‘?’代替 ② pstmt对象设置 ‘?’ 参数指代的值： pstmt.setString(index,参数); ③ pstmt.executeUpdate();执行，这里注意不需要传入sql语句了，因为在定义pstmt对象的时候已经传入sql语句进行预编译了 1234567891011121314151617181920212223242526272829public class textPreparedStatement &#123; public static void main(String[] args) throws Exception &#123; // 注册驱动(可省略) Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 获取链接 String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;; String username = &quot;xxxxx&quot;; String password = &quot;xxxxx&quot;; Connection conn = DriverManager.getConnection(url, username, password); String sql = &quot;select * from tb_user where username = ? and password = ?&quot;; PreparedStatement pstmt = conn.prepareStatement(sql); String name = &quot;zhangsan&quot;; String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;; pstmt.setString(1,name); pstmt.setString(2,pwd); ResultSet resultSet = pstmt.executeQuery(); if(resultSet.next())&#123; System.out.println(&quot;登陆成功!&quot;); &#125;else&#123; System.out.println(&quot;登陆失败!&quot;); &#125; resultSet.close(); pstmt.close(); conn.close(); &#125;&#125; 6、PreparedStatement原理 ​ 开启预编译：在url中加入参数：useServerPrepStmts=true; ​ 好处：① 预编译，性能更高； ② 防止sql注入 ​ 在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查、编译（这些步骤很耗时），执行时就不用再进行这些步骤了，速度更快。 数据库连接池​ 数据库连接池（Connection Pool）是一种复用 Connection 的组件，它可以避免反复创建新连接，提高JDBC代码的运行效率。 ​ 在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池复用已经创建好的连接。 ​ 数据库连接池的实现​ 标准接口：DataSource 1DataSource datasource = Connection getConnection(); ​ 不需要通过 DriverManager 对象获取 Connection 对象，而是通过连接池（DataSource）获取 Connection 对象。 Druid数据连接池 – alibaba 导入jar包：下载地址 https://repo1.maven.org/maven2/com/alibaba/druid/ 编写配置文件druid.properties 测试代码 12345678910111213141516public class testDruid &#123; public static void main(String[] args) throws Exception &#123; //定义配置文件 //加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(&quot;src/druid.properties&quot;)); //获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //获取数据库连接 Connection Connection connection = dataSource.getConnection(); System.out.println(connection); //获取到了连接后就可以继续做其他操作了 //System.out.println(System.getProperty(&quot;user.dir&quot;)); &#125;&#125; Druid连接池配置成功：","tags":[]},{"title":"Android平台JNI开发保姆级教程","date":"2023-03-12T13:41:38.000Z","path":"2023/03/12/Android-jni/","text":"​ 最近项目中在Android移动端需要用到音视频处理的部分，这离不开FFmpeg工具。但是FFmpeg源码是C语言，想要在Android java中调用FFmpeg工具，这就需要Android NDK登场了。 Android平台JNI开发保姆级教程前提条件​ FFmpeg源码：可以在官网下载，目前我是用的是最新版的6.0版本（只下载源代码即可，不要下载已经编译好的在不同平台可以运行的安装包）。 image-20230312105234096 ​ Android NDK：可以在官网下载，但更推荐在Android Studio中的Setting中可以直接下载NDK对应版本，我这里使用的是22.1.7171670版本的NDK（建议不要使用太新的NDK，否则可能会出现一些BUG）。 ​ 安装msys2：由于我是在Windows下对FFmpeg源码进行交叉编译，所以需要一个类Unix环境；或者你可以直接使用linux操作系统。 ​ 由于第一次接触Android开发，对Android程序调用类库的流程不清楚，导致走了很多弯路。其实总结下来也很简单，我这里引用了雷神的流程图： img 在FFmpeg的最新版本6.0中，已经不需要在源码中修改configure设置了（我记得貌似从4.0版本之后就不需要修改了，记不太清了）。 背景知识Android NDK​ NDK 主要提供了一些库和工具，包括交叉编译器、调试器、库文件等，开发者可以使用这些工具将原生代码编译为针对不同 CPU 架构的本地库，然后在 Android 应用中通过 Java Native Interface（JNI）来调用这些本地库，以实现一些高性能、低级别的操作，例如图形处理、音频处理、加密、数据处理等。 ​ Android NDK 是一个允许使用 C、C++ 等本地语言编写 Android 应用的工具包，可以提高应用的运行效率和系统性能。 JNI​ JNI（Java Native Interface）是Java平台提供的一种机制，用于在Java虚拟机中运行本地代码。它允许Java应用程序通过调用本地语言编写的函数来使用底层操作系统和硬件资源，从而实现高性能的计算和底层操作。简单来说，JNI提供了一种在Java程序中调用本地代码的方式，可以扩展Java程序的功能和性能。 .so库​ 在Android中，C语言代码需要被编译为.so库的形式才能被Android应用程序调用。这是因为Android系统是基于Linux内核的，而Linux系统下的.so库是一种常见的代码共享形式，可以被多个进程动态链接使用，避免了代码的重复编写和内存占用。通过将C语言代码编译为.so库的形式，Android应用程序可以在运行时动态加载和链接所需的库，从而实现对底层系统和硬件资源的访问和控制。 ​ 通过.so库的形式调用C语言代码，可以让Android应用程序更高效地使用底层系统和硬件资源，从而提高程序的性能和可靠性。同时，.so库也方便了代码的管理和维护，可以将公共的代码打包成库，供多个应用程序共享使用。 开发流程（敲黑板！）编译FFmpeg库​ 首先要把NDK安装好，路径是在你SDK路径下的NDK目录中，最好把你要用到的版本加入到环境变量当中。 ​ 在任意目录中新建一个脚本build_ffmpeg.sh，添加内容： 123456789101112131415161718192021222324252627282930313233#!/bin/bashset -eSRC_DIR=D:\\Android-Studio\\ffmpeg-6.0DST_DIR=D:\\Android-Studio\\ffmpeg_build_outNDK=D:/Android/Sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/windows-x86_64API=23 cd $SRC_DIR function build_onearch&#123; echo &quot;&gt;&gt; configure $CPU&quot; ./configure --enable-cross-compile --target-os=android \\ --prefix=$DST_DIR/$ANDROID_ABI --cross-prefix=$CROSS_PREFIX \\ --cc=$CLANG_PREFIX --cxx=$CLANG_PREFIX++ \\ --arch=$ARCH --cpu=$CPU --sysroot=$NDK/sysroot \\ --enable-shared --disable-static \\ --enable-small --disable-programs --disable-doc \\ --enable-asm --enable-neon \\ --enable-jni --enable-mediacodec echo &quot;&lt;&lt; configure $CPU&quot; make clean make make install&#125; ANDROID_ABI=arm64-v8aARCH=arm64CPU=armv8-aCROSS_PREFIX=$NDK/bin/aarch64-linux-android-CLANG_PREFIX=$NDK/bin/aarch64-linux-android$API-clangbuild_onearch ​ 前面几行要根据自己的电脑路径进行配置，切莫照搬全抄！这里的API的版本是最低版本，注意不要大于自己设备的Android API版本。网上有很多类似的配置脚本，可以对configure响应的修改进行功能增减。 ​ 我这里只编译了arm64-v8a的.so库，通常来说64位的CPU架构是对先前的CPU架构是兼容的。 ​ 将脚本保存后关闭，然后打开安装好的msys2，在脚本目录下运行脚本： 1./build_ffmpeg.sh ​ 整个编译过程大概有二十多分钟吧，编译好后的动态库会生成在你前面设置的DST_DIR路径下。 image-20230312111053279 ​ include目录下是一些头文件，lib目录下就是相应的.so库了。 JNI调用C程序使用JNI调用C语言代码需要做以下几步： 编写带有native方法的Java类和声明要加载的类库 使用javah命令生成.h头文件（也可以用JNI_OnLoad动态注册函数，就不用生成.h头文件了） 编写C代码实现头文件中的方法 编写Java端代码​ 用官方文档中的hello_jni例程修改的。 1234567891011121314151617181920212223242526package com.example.hellojni;import android.app.Activity;import android.widget.TextView;import android.os.Bundle;public class HelloJni extends Activity&#123; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText( stringFromJNI() ); setContentView(tv); &#125; public native String stringFromJNI(); public native String unimplementedStringFromJNI(); static &#123; System.loadLibrary(&quot;hellojni&quot;); &#125;&#125; 编写C端代码1、获取C语言的接口函数声明 ​ 根据Java对于C语言接口的定义，生成相应的接口函数声明。说通俗点就是Java层只是用native关键词声明了一个C语言的函数，要在Java层的函数和C语言层的函数之间形成一个映射关系，这一步需要用到JDK中的“javac -h”命令。 ​ 尴尬的是在生成头文件的时候出现了程序包XX.XX不存在的BUG，网上找了一会发现并没有卵用，于是乎就直接定义JNI_Onload方法形成动态函数映射。（跳过第一步生成.h头文件的步骤即可） 下面的第三步就讲讲如何用JNI_Onload： 传统java JNI方式： 编写带有native方法的Java类 → 使用javah命令生成.h头文件 → 编写代码实现头文件中的方法 但是上述每次都需要通过javah依据java类的全类名生成对应的native函数全名称，其实我们可以使用RegisterNatives方法把c/c++中的方法隐射到Java中的native方法，这样就可以随意定义你的函数名而不用写那么长的又看不懂的全名类啦！ 2、编写C语言代码 在项目根目录下创建jni目录：jni目录中新建hellojni.c文件，代码如下： 12345678910#include &lt;string.h&gt;#include &lt;jni.h&gt;#include &quot;libavcodec/avcodec.h&quot;// 用的雷佬的代码 -- 该函数调用了libavcodec的avcodec_configuration()方法，用于获取FFmpeg的配置信息。jstring stringFromJNI( JNIEnv* env,jobject thiz )&#123; char info[10000] = &#123; 0 &#125;; sprintf(info, &quot;%s\\n&quot;, avcodec_configuration()); return (*env)-&gt;NewStringUTF(env, info);&#125; 3、定义函数JNI_OnLoad动态注册函数 1234567891011121314jint JNI_OnLoad(JavaVM* pVm, void* reserved) &#123; JNIEnv* env; if ((*pVm)-&gt;GetEnv(pVm, (void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; return -1; &#125; JNINativeMethod nm[1]; nm[0].name = &quot;stringFromJNI&quot;; nm[0].signature = &quot;()Ljava/lang/String;&quot;; nm[0].fnPtr = (void*)stringFromJNI; jclass cls = (*env)-&gt;FindClass(env, &quot;com/example/hellojni/HelloJni&quot;); (*env)-&gt;RegisterNatives(env, cls, nm, 1); return JNI_VERSION_1_6;&#125; ​ 前后都是固定的模板，不需要修改，只需要更改JNINativeMethod中的字段信息，关于JNI编程的简单语法都很简单，去了解一下就可，不在这里说了。其实就是用这个RegisterNatives注册方法，C语言本地的函数与Java层的类和函数进行动态绑定。 JNINativeMethod结构体的字段信息： 12345typedef struct &#123; const char* name; // java层对应的方法名称 const char* signature;// 该方法的返回值类型和参数类型 void* fnPtr; // native中对应的函数指针 &#125; JNINativeMethod; 3、Android.mk和 Application.mk编写 ​ 在JNI目录下创建Android.mk和 Application.mk文件。这是NDK官方推荐的ndk-build（是一个命令行工具，它用于构建使用C/C++编写的Android Native库）构建方式的脚本文件（不过yysy现在用的更多的是cmake了，反正ndk-build很好用，管他的呢）。 Android.mk的编写规范可以看NDK的官方文档，Android.mk添加如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546LOCAL_PATH := $(call my-dir)# FFmpeg libraryinclude $(CLEAR_VARS)LOCAL_MODULE := avcodecLOCAL_SRC_FILES := lib/libavcodec.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avdeviceLOCAL_SRC_FILES := lib/libavdevice.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avfilterLOCAL_SRC_FILES := lib/libavfilter.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avformatLOCAL_SRC_FILES := lib/libavformat.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutilLOCAL_SRC_FILES := lib/libavutil.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresampleLOCAL_SRC_FILES := lib/libswresample.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscaleLOCAL_SRC_FILES := lib/libswscale.soinclude $(PREBUILT_SHARED_LIBRARY)# Programinclude $(CLEAR_VARS)LOCAL_MODULE := hellojniLOCAL_SRC_FILES := hellojni.cLOCAL_C_INCLUDES += $(LOCAL_PATH)/includeLOCAL_LDLIBS := -llog -lzLOCAL_SHARED_LIBRARIES := avcodec avdevice avfilter avformat avutil swresample swscaleinclude $(BUILD_SHARED_LIBRARY) Application.mk代码如下： 12APP_ABI := arm64-v8aAPP_PLATFORM := android-23 # minAPI APP_ABI 指定了设备CPU的架构。因为前面编译FFmpeg的时候我只编译了64位版本的，这里就对应上。 4、NDK-BUILD编译 ​ 将先前编译的FFmpeg的include和lib目录复制到jni目录当中来，现在看jni目录结构应该是这样的： ​ 命令行cd到这一层目录下，执行ndk-build命令即可。 ​ 然后你还会发现项目的根目录下生成了这两个目录。 image-20230312172123920 ​ libs里面就是根据android.mk脚本编译的.so库了，obj没什么用，里面就是一些编译的过程文件。将libs目录中的内容（应该是cpu架构文件夹，下层目录才是.so库）copy到app/src/main目录的jniLibs目录当中（项目运行时默认就是在jniLibs中寻找加载相应的第三方.so库）。 ​ 接下来就可以在手机上对项目进行测试啦！因为我使用的是arm64-v8acpu架构，这种架构好像不支持在虚拟机上测试（虚拟机架构是x86和x86_64，但可不可以我也没试过）。 ​ 下面是测试的结果啦：","tags":[{"name":"Android","slug":"Android","permalink":"https://kicheng.github.io/tags/Android/"},{"name":"JNI开发","slug":"JNI开发","permalink":"https://kicheng.github.io/tags/JNI%E5%BC%80%E5%8F%91/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kicheng.github.io/tags/FFmpeg/"}]},{"title":"OpenCV特征检测","date":"2023-03-10T07:54:34.000Z","path":"2023/03/10/opencv01/","text":"​ 前段时间在研究Android开发，以及对第三方库的JNI编程和交叉编译，本想把FFmpeg和JNI先整理成博客发出来，奈何实在太懒了，可能还要过一段时间才能整理完了。正好这几天项目里用到了OpenCV里Detection的一些算法，就去学习了一下。 [OpenCV]Canny边缘检测、HoughLinesP直线检测边缘检测Edge detection​ 边缘检测算法是指利用灰度值的不连续性质，以灰度突变为基础分割出目标区域。大概原理是计算图像中每个像素点的梯度值和梯度方向。使用边缘检测算子计算图像在x和y方向上的一阶导数，然后计算每个像素点的梯度幅值和梯度方向；再利用NMS和阈值检测将边缘点标记和连接。 ​ 最后的输出一定是一个二值图像，其中白色像素表示边缘，黑色像素表示非边缘。 ​ Canny边缘检测算法的优点是能够检测到比较细的边缘，且对噪声比较鲁棒。 1234567Canny算法参数： InputArray image, //输入图像，要求为灰度图 OutputArray edges, //canny检测后的输出图像 double threshold1, //阈值1,低阈值 double threshold2, //阈值2，高阈值，低/高=比值1:2~1:3尤佳 int apertureSize = 3, //Sobel算子的孔径大小 bool L2gradient = false //计算梯度幅度值的标识，默认为false ​ 实验代码，参数可以自行调整。 1234567891011121314#include&lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;using namespace cv;int main() &#123; Mat src, dst; src = imread(&quot;../../pictureRepo/people.jpg&quot;); Canny(src, dst, 50, 200, 3); namedWindow(&quot;Orgin&quot;, 1); imshow(&quot;Orgin&quot;, src); namedWindow(&quot;Canny&quot;, 1); imshow(&quot;Canny&quot;, dst); waitKey(0);&#125; ​ 网上随便找了一张图，实验结果是这样的。值得注意的是：Canny算法的output是二值图像，其中白色像素表示边缘，黑色像素表示非边缘。 直线检测Line detection​ 霍夫变换直线检测是最基本的算法，也是今天学习和使用到的。他有HoughLines和HoughLinesP两种，后者是前者的优化，但并不意味着HoughLines完全被取代，他们适用于不同的场景，大家可以根据实际需要自行选择。 ​ 需要我们注意的是霍夫直线检测是从二值图像中检测直线(线段)，所以在调用HoughLines或HoughLinesP算法前，要先将图像转换成二值图像，通常在之前先使用Canny将其简化成只有边缘特征的二值图像。 ​ 这里我使用了OpenCV官方文档提供的示例代码进行测试。 12345678HoughLinesP算法参数： InputArray image, // 8位的单通道二值图像。对于其他类型，在进行霍夫变换之前，需要将其修改为这个指定的格式 OutputArray lines, // 输出的直线集合 double rho, // 以像素为单位的距离 r 的精度。一般情况下，使用的精度是 1 double theta, // 角度 θ 的精度。一般情况下，使用的精度是 pi/180，表示要搜索可能的角度 int threshold, // 阈值。该值越小，判定出的直线越多；值越大，判定出的直线就越少 double minLineLength = 0, // 控制「接受直线的最小长度」的值，默认值为 0 double maxLineGap = 0 // 控制接受共线线段之间的最小间隔，默认值为 0 ​ 实验代码，参数可以自行调整。 1234567891011121314151617181920212223242526#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;using namespace cv;using namespace std;int main() &#123; Mat src, dst, color_dst; src = imread(&quot;../../pictureRepo/building.jpg&quot;); Canny(src, dst, 50, 200, 3); cvtColor(dst, color_dst, COLOR_GRAY2BGR); /* COLOR_GRAY2BGR参数表示将灰度图像转换为3通道的BGR彩色图像。 经过该转换后，color_dst中每个像素的R、G、B三个分量的值都相同，即为该像素的灰度值。 */ vector&lt;Vec4i&gt; lines; HoughLinesP(dst, lines, 1, CV_PI / 180, 200, 30, 10); for (size_t i = 0; i &lt; lines.size(); i++) &#123; line(color_dst, Point(lines[i][0], lines[i][1]), Point(lines[i][2], lines[i][3]), Scalar(0, 0, 255), 3, 8); &#125; namedWindow(&quot;Orgin&quot;, 1); imshow(&quot;Orgin&quot;, src); namedWindow(&quot;HoughLinesP&quot;, 1); imshow(&quot;HoughLinesP&quot;, color_dst); waitKey(0);&#125; ​ 实验结果如下。 ​ 这是一个OpenCV官方文档提供的示例图片: ​ 这是上述程序在概率霍夫变换后的输出： ​ 这是用 HoughLinesP的结果，使用HoughLines进行检测出现比较严重的误判。我猜想的原因是这样的：根据官方文档的描述， HoughLinesP检测出来的是一条条可以控制长短的线段，而 HoughLines只能检测出完整的直线。所以除了一些特殊的情景外，使用 HoughLinesP的检测结果会更精确。","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://kicheng.github.io/tags/OpenCV/"}]},{"title":"algorithm03 链表","date":"2023-02-03T09:53:36.000Z","path":"2023/02/03/algorithm03/","text":"说在前面：之前刷题都没有按照知识点分类整理过，最近在网上看到推荐代码随想录的算法讲义，就想按照他的推荐系统的把算法这一块拾起来，在自己的博客里做一个记录，也当做日后自己复习的笔记了。 链表基础知识链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 如图所示： 链表类型单链表单链表中的指针域只能指向节点的下一个节点。上面说的就是单链表。 双链表双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 循环链表循环链表，顾名思义，就是链表首尾相连。（解决约瑟夫环问题） 链表存储方式数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 链表定义下面我给出java定义链表节点的方式： 1234567public class ListNode &#123; int val; // 节点上存储的元素 ListNode next; // 指向下一个节点的指针 ListNode() &#123;&#125; // 节点的构造函数 ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 链表基本操作删除节点删除D节点，只要将C节点的next指针指向E结点就可以了。Java语言有自己的内存回收机制，就不用像C++那样手动释放D结点了。 添加节点链表的增添和删除都是O(1)操作，也不会影响到其他结点。 性能分析 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。 链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。 相关题目203. 移除链表元素 image-20230530230242484 这里以链表1-&gt;4-&gt;2-&gt;4，删除元素4为例来说明： 在这种情况下，只需要记录被删除结点的前一个结点p，将p的next结点设为p的next的next结点。 1p.next = p.next.next; 如果删除的是头结点呢？ 我们可以对原链表直接操作，但写代码的时候会发现，需要单独写一段逻辑来处理移除头结点的情况。更好的方式是设置一个虚拟的头结点再进行删除操作，以一种统一的逻辑来移除链表的结点： 但是别忘记在算法最后返回链表结果的时候，返回的头结点是dummyNode-&gt;next。 123456789101112131415class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(0,head); ListNode p = dummy; while(p.next!=null)&#123; if(p.next.val==val)&#123; // 删除操作，记录待删除结点的前一个节点 p.next=p.next.next; &#125;else&#123; p=p.next; &#125; &#125; return dummy.next; &#125;&#125; 707. 设计链表 image-20230601192641111 思路：这道题涵盖了链表的几大基础操作：增、删、查，很基础，很重要。链表操作有两种方式：一种是直接使用原有的链表进行操作，另一种方式是设置一个哑结点再进行操作，我们对链表来操作通常都是通过第二种方式。 定义结点类的代码就不再解释了： 123456789101112class ListNode&#123; int val; ListNode next; public ListNode()&#123;&#125; public ListNode(int val)&#123; this.val=val; &#125; public ListNode(int val, ListNode next)&#123; this.next=next; this.val=val; &#125;&#125; 下面我直接展示题目的代码，结合代码在注释中梳理思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class MyLinkedList &#123; int size; ListNode dummy; // 初始化链表 public MyLinkedList() &#123; size = 0; dummy = new ListNode(0); // 这里定义的头结点，是一个虚拟的哑结点，需要注意哑结点通常用dummy变量或dummyNode变量表示 &#125; // 获取到第index个节点数值:如果index是非法数值直接返回-1，注意index是从0开始的，index=0的结点实际是dummy.next结点 public int get(int index) &#123; if(index &gt;= size || index &lt; 0)&#123; return -1; &#125; ListNode p = dummy.next; int cur = 0; while(cur&lt;index)&#123; p = p.next; cur++; &#125; return p.val; &#125; // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 public void addAtHead(int val) &#123; addAtIndex(0, val); &#125; // 在链表最后面添加一个节点 public void addAtTail(int val) &#123; addAtIndex(size, val); &#125; // 在第index个结点之前插入一个新结点 // 如果index等于链表的长度，则说明是新插入的结点为链表的尾结点 // 如果index大于链表的长度，则返回空 // 如果index小于0，则在头部插入结点 public void addAtIndex(int index, int val) &#123; if(index&gt;size)&#123; return; &#125; ListNode node = new ListNode(val); ListNode p = dummy; index = Math.max(0,index); for(int i=0;i&lt;index;i++)&#123; p = p.next; &#125; node.next = p.next; p.next = node; size++; &#125; // 删除第index个结点，如果index非法，则返回空 public void deleteAtIndex(int index) &#123; if(index&lt;0 || index&gt;=size)&#123; return; &#125; ListNode p = dummy; for(int i=0;i&lt;index;i++)&#123; p = p.next; &#125; p.next = p.next.next; size--; &#125;&#125;class ListNode&#123; int val; ListNode next; public ListNode()&#123;&#125; public ListNode(int val)&#123; this.val=val; &#125; public ListNode(int val, ListNode next)&#123; this.next=next; this.val=val; &#125;&#125; 操作总结： 增添一个结点——在C结点之后、D结点之前添加一个结点F： 12F.next = C.next;C.next = F; 由此我们可以发现，如果要在index结点前插入一个新结点，需要关注的是index-1个结点的位置。 删除一个结点——删除结点D 1C.next = C.next.next; 由此我们可以发现，如果要删除index结点，需要关注的还是index-1个结点的位置。 206. 反转链表 思路1：迭代方法 在遍历链表时，将当前结点curr的next指针改为指向前一个结点，由于结点没有引用其前一个结点，因此必须事先存储其前一个结点prev。在更改引用之前，还需要存储后一个节点next。最后返回新的头引用。 123456789101112131415class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while(curr != null)&#123; // 要记录当前结点的next位置，因为一旦当前结点翻转后，就无法引用next位置的结点了 ListNode next = curr.next; curr.next = prev; // 当前结点的next指针改为指向前一个结点 // 为下一次循环更新prev和curr的位置：后移一位 prev = curr; curr = next; &#125; return prev; //返回的是翻转后的头结点 &#125;&#125; 思路2：递归方法（空间复杂度O(n)） 12345678910111213141516171819202122232425262728293031323334// 递归方法class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; // newHead存储的是反转后的头结点 ListNode newHead = reverseList(head.next); /* 第一轮出栈，head为5，head.next为空，返回5 第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4， 把当前节点的子节点的子节点指向当前节点 此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null 此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5 返回节点5 第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3， 此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null 此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5 返回节点5 第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2， 此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null 此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5 返回节点5 第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1， 此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null 此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5 返回节点5 出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1 */ head.next.next = head; head.next = null; // 断开双向指针 return newHead; &#125;&#125; 24. 两两交换链表中的节点 image-20230601203345561 题目的本质和上一题翻转链表是一样的，核心就是记录temp、start、end三个结点，交换start和end结点的位置： 1234temp.next = end; start.next = end.next; end.next = start; temp = start; 程序如下： 123456789101112131415class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(0, head); ListNode temp = dummy; while(temp.next != null &amp;&amp; temp.next.next != null) &#123; ListNode start = temp.next; ListNode end = temp.next.next; temp.next = end; start.next = end.next; end.next = start; temp = start; &#125; return dummy.next; &#125;&#125; 19. 删除链表的倒数第 N 个结点 image-20230601205710711 思路1：计算链表的长度 最容易想到的方法就是计算链表的长度，随后我们再从头结点开始对链表进行一次遍历，当遍历到第Length−n+1个节点时，它就是我们需要删除的节点。 计算单链表的长度： 123456789int getLength(ListNode head)&#123; int count = 0; ListNode p = head; while(p != null)&#123; count++; p = p.next; &#125; return count; &#125; 易得代码： 1234567891011121314151617181920212223class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; int length = getLength(head); int num = length-n+1; ListNode dummy = new ListNode(0,head); ListNode p = dummy; for(int i=0;i&lt;num-1;i++)&#123; p = p.next; &#125; // p为待删除结点的前一个结点 p.next = p.next.next; return dummy.next; &#125; int getLength(ListNode head)&#123; int count = 0; ListNode p = head; while(p != null)&#123; count++; p = p.next; &#125; return count; &#125;&#125; 思路2：双指针法 由于我们需要找到倒数第n个节点，因此我们可以使用两个指针first和second同时对链表进行遍历，并且 first比second超前n个节点 。当first遍历到链表的末尾时，second就恰好处于倒数第n个节点。 1234567891011121314151617class Solution &#123; // 双指针法first second public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0,head); ListNode first = dummy, second = dummy; for(int i=0;i&lt;n;i++)&#123; first = first.next; &#125; while(first.next != null)&#123; first = first.next; second = second.next; &#125; // 待删除的结点是second的next结点 second.next = second.next.next; return dummy.next; &#125;&#125; 160. 相交链表 image-20230601211248800 思路1：哈希Set，这个属于是比较容易想到的笨办法 1234567891011121314151617181920public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // 简单方法 -- 哈希表 ListNode pA = headA; ListNode pB = headB; HashSet&lt;ListNode&gt; nodes = new HashSet&lt;&gt;(); while(pA != null)&#123; nodes.add(pA); pA = pA.next; &#125; while(pB != null)&#123; if(nodes.contains(pB))&#123; // 题意告诉我们：当前的结点重复时，后面的所有结点都是重复的 return pB; &#125; pB = pB.next; &#125; return null; &#125;&#125; 思路2：思维性比较高，注重理解 pA走过的路径为A链+B链；pB走过的路径为B链+A链；pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。 我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。 1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; while(headA == null || headB == null)&#123; return null; &#125; ListNode pA = headA; ListNode pB = headB; while(pA != pB)&#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 142. 环形链表 II image-20230601220031508 思路1：哈希Set 1234567891011121314public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode p = head; HashSet&lt;ListNode&gt; nodes = new HashSet&lt;ListNode&gt;(); while(p != null)&#123; if(nodes.contains(p))&#123; return p; &#125; nodes.add(p); p = p.next; &#125; return null; &#125;&#125; 思路2：双指针法 我们主要判断两个问题：① 判断链表是否有环；② 如果有环，如何找到这个环的入口； ① 判断链表是否有环：可以使用快慢指针法，分别定义fast和slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果fast和 slow指针在途中相遇 ，说明这个链表有环。 为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢？因为无论怎么追赶最后都会是下图这种情况： image-20230601222337720 ② 如果有环，如何找到这个环的入口： 假设从头结点到环形入口节点 的节点数为x。 环形入口节点到fast指针与slow指针相遇节点 节点数为y。 从相遇节点再到环形入口节点节点数为 z。 那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数： x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。 因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：(x + y) * 2 = x + y + n (y + z). 因为要找环形的入口，那么要求的是x，因为x表示头结点到环形入口节点的距离：x = (n - 1)(y + z) + z, n&gt;=1. 当n为1的时候，公式就化解为 x = z，这就意味着，从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点。也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是环形入口的节点。 68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3134322e2545372538452541462545352542442541322545392539332542452545382541312541384949254546254243253838254536254231253832254535253835254135254535253846254133 n如果大于1时，一样可以通过这个方法找到环形的入口节点，只不过，index1 指针在环里多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。 123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123;// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) &#123; index1 = index1.next; index2 = index2.next; &#125; return index1; &#125; &#125; return null; &#125;&#125;","tags":[]},{"title":"algorithm02 哈希表","date":"2022-12-21T07:54:34.000Z","path":"2022/12/21/algorithm02/","text":"说在前面：之前刷题都没有按照知识点分类整理过，最近在网上看到推荐代码随想录的算法讲义，就想按照他的推荐系统的把算法这一块拾起来，在自己的博客里做一个记录，也当做日后自己复习的笔记了。 哈希表基础知识哈希表哈希表（或散列表），是根据关键码的值而直接进行访问的数据结构。 那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。 例如要查询一个名字是否在这所学校里：要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。 我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。 将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。 哈希函数哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。 哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。 如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？ 此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。 此时问题又来了，哈希表我们刚刚说过，就是一个数组。 如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。 哈希碰撞对不同的关键字可能得到同一哈希地址，即key1≠key2，而h(key1)=h(key2) ，这种现象称为冲突（collision）。 如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。 解决哈希碰撞的方案有很多，常用的有两种——拉链法和线性探测法。 拉链法发生冲突的元素都被存储在链表中。 要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 线性探测法使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。 Set和List的区别 1、Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 2、Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 3、List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 遍历ArrayList： 1234567891011121314151617181920212223242526272829import java.util.*;public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;HAHAHAHA&quot;); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) &#123; //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式 System.out.println(str); &#125; //第二种遍历，把List变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 &#123; System.out.println(ite.next()); &#125; &#125;&#125; 三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。 遍历HashMap： 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Test&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;, &quot;value2&quot;); map.put(&quot;3&quot;, &quot;value3&quot;); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value：&quot;); for (String key : map.keySet()) &#123; System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key)); &#125; //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第四种 System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) &#123; System.out.println(&quot;value= &quot; + v); &#125; &#125;&#125; 相关题目242.有效的字母异位词 image-20230115210900748 思路1、利用数组的特性排序 12345678910111213141516class Solution &#123; public boolean isAnagram(String s, String t) &#123; char[] char_s = stringToChar(s); char[] char_t = stringToChar(t); if(Arrays.equals(char_s,char_t))&#123; return true; &#125;else&#123; return false; &#125; &#125; public char[] stringToChar(String str)&#123; char[] CharStr = str.toCharArray(); Arrays.sort(CharStr); return CharStr; &#125;&#125; 知识点： 1、String.toCharArray()可以将String类型转换成char数组，此操作通常用用来对String字符串中每个字符进行排序操作。 2、Arrays.equals(a,b)用来比较两个数组的元素是否完全对应相同。 2、哈希表解法 （1）数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。 定义一个数组叫做record用来上记录字符串s里字符出现的次数。 需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。 再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做 +1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。 那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做 -1 的操作。 那么最后检查一下，record数组如果有的元素不为0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false；如果元素全部为0，则return true。 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] record = new int[26]; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); record[c-&#x27;a&#x27;]++; &#125; for(int j=0;j&lt;t.length();j++)&#123; char c = t.charAt(j); record[c-&#x27;a&#x27;]--; &#125; for(int k=0;k&lt;26;k++)&#123; if(record[k]!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; 时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。 （2）HashMap 1234567891011121314151617181920212223242526class Solution &#123; public boolean isAnagram(String s, String t) &#123; HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; String s_str = String.valueOf(s.charAt(i)); map.put(s_str,map.getOrDefault(s_str,0)+1); &#125; for(int j=0;j&lt;t.length();j++)&#123; String t_str = String.valueOf(t.charAt(j)); if(!map.containsKey(t_str))&#123; return false; &#125;else&#123; int value = map.get(t_str); value--; map.replace(t_str,value); &#125; &#125; // 最后map的所有value应该都是0 for(String key:map.keySet())&#123; if(map.get(key)!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; String.valueOf(char)将char字符类型转换成String类型，这个操作通常在哈希中比较常见，因为char类型不能作为HashMap、HashSet的泛型数据类型。 熟悉一下HashMap的主要函数： (1) 查找是否存在key关键字：map.containsKey(key) (2) 查找是否存在value键值对的值：map.containsValue(value) (3) 获取key对应的value值：map.get(key) (4) get函数进阶版，如果map中没有key关键字，就添加key关键字并赋值value：map.getOrDefault(key,value) (5) 替换map中的value：map.replace(key,value) 1002. 查找常用字符给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。 示例 1： 12输入：words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 示例 2： 12输入：words = [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;] 思路为 words 里每一个字符串创建一个长度为26的数组作为哈希表，所以我们new一个大小为 [words.length][26]的二维数组。 找出所有字符串的共用字符，即交集，只需要找出二维数组每一列（代表26个字母）的最小值即可，用一个长度为26的一维数组储存结果。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;String&gt; commonChars(String[] words) &#123; int len=words.length; ArrayList&lt;String&gt; res=new ArrayList&lt;&gt;(); int[][] index = new int[len][26]; int[] character = new int[26]; for(int i=0;i&lt;len;i++)&#123; String word=words[i]; for(int j=0;j&lt;word.length();j++)&#123; char c = word.charAt(j); index[i][c-&#x27;a&#x27;]++; &#125; &#125; for(int i=0;i&lt;26;i++)&#123; int min = Integer.MAX_VALUE; // 每一列找最小的值 for(int j=0;j&lt;len;j++)&#123; min=min&lt;index[j][i]?min:index[j][i]; &#125; character[i]=min; &#125; for(int i=0;i&lt;26;i++)&#123; while(character[i]&gt;0)&#123; String str = String.valueOf((char)(i+&#x27;a&#x27;)); res.add(str); character[i]--; &#125; &#125; return res; &#125;&#125; Java 里面int类型的范围为：-2^31 ~ 2^31-1，表示为—— Integer.MIN_VALUE、Integer.MAX_VALUE. 349.两个数组的交集 image-20230112195548480 思路1、双指针的排序思想 ​ 因为是求交集，所以while循环的终止条件是两个指针任一个到达最后。因为题目要求答案中的元素是唯一的，所以在两指针指向的元素相同时还要进行一个唯一性判断，也就是说如果这个元素在答案数组中没有出现才能加入进去。 唯一性判断：if(index==0 || nums1[i]!=res[index-1]) 1234567891011121314151617181920212223class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; int[] res = new int[nums1.length+nums2.length]; int index=0; Arrays.sort(nums1); Arrays.sort(nums2); int i=0,j=0; while(i&lt;=nums1.length-1 &amp;&amp; j&lt;=nums2.length-1)&#123; if(nums1[i]&lt;nums2[j])&#123; i++; &#125;else if(nums1[i]&gt;nums2[j])&#123; j++; &#125;else&#123; if(index==0 || nums1[i]!=res[index-1])&#123; res[index++]=nums1[i]; &#125; i++; j++; &#125; &#125; return Arrays.copyOfRange(res,0,index); &#125;&#125; Arrays.copyOfRange(array,begin,end)：拷贝一个新数组，存储array数组从begin索引到end索引的元素。 2、用HashSet作为哈希结构 ​ 题目要求答案中的每个元素都是唯一的，所以考虑到HashSet的不重复性，利用HashSet中的contains()，将符合的集合元素add到答案集合当中，最后再创建答案集合size大小的数组进行存储并输出。 要注意的是，数组在初始化时要么静态初始化指定每个元素的初始值，系统决定数组的长度；要么动态初始化，指定数组的大小。所以数组不像ArrayList那样可以随着元素的增多而扩充大小。 1234567891011121314151617181920212223242526class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = intToSet(nums1); Set&lt;Integer&gt; set2 = intToSet(nums2); Set&lt;Integer&gt; interset = new HashSet&lt;&gt;(); for(int num:set1)&#123; if(set2.contains(num))&#123; interset.add(num); &#125; &#125; int[] res = new int[interset.size()]; int index=0; for(int num:interset)&#123; res[index++]=num; &#125; return res; &#125; public Set&lt;Integer&gt; intToSet(int[] nums)&#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num:nums)&#123; set.add(num); &#125; return set; &#125;&#125; 3、用HashMap作为哈希结构 ​ key为元素，value为元素出现的次数，遍历nums1存储nums1的元素以及出现的次数；再遍历nums2，如果遍历到的元素在HashMap中存在且value大于0，则value-1，并把该元素加入到答案数组当中。 12345678910111213141516171819202122232425class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums1.length;i++)&#123; map.put(nums1[i],map.getOrDefault(nums1[i],0)+1); &#125; for(int j=0;j&lt;nums2.length;j++)&#123; int num = nums2[j]; if(map.containsKey(num) &amp;&amp; map.get(num)&gt;0)&#123; int count = map.get(num); count--; map.replace(num,count); // 将num元素放到输出的答案数组当中 -- 此时数组的大小不确定，不能直接创建 -- 用set set.add(num); &#125; &#125; int[] ans = new int[set.size()]; int index=0; for(int num:set)&#123; ans[index++] = num; &#125; return ans; &#125;&#125; 202. 快乐数 image-20230112213141536 思路当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。 所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isHappy(int n) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); while(true)&#123; int sum = sum(n); if(sum == 1)&#123; return true; &#125;else if(set.contains(sum))&#123; return false; // 说明无限循环了 &#125;else&#123; set.add(sum); n = sum; &#125; &#125; &#125; public int sum(int num)&#123; int sum = 0; while(num != 0)&#123; int n = num % 10; n *= n; sum += n; num /= 10; &#125; return sum; &#125;&#125; 1. 两数之和 image-20230113225349418 思路1、暴力法 时间复杂度O(n^2) 2、HashMap：考虑到nums中的两数之和等于target，我们可以遍历一次nums，在哈希结构中查找target - num1，如果存在num2那么就输出num1和num2的数组索引下标。考虑到需要输出数组的索引下标，所以在哈希要存储元素以及对应的数组下标，就用到了HashMap。 我们用key存储元素还是存储数组下标呢？我们总结一下如何应用HashMap：遍历nums中的元素，每次在HashMap中进行查找，查找到就返回数组下标，没有查找到就将该元素put到HashMap当中；因为根据元素查找成功后，要通过元素找到对应的数组下标进行返回，而HashMap的Key和Value只有单向映射关系，所以key为元素，value为数组下标。 1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int[] res = new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; // 查找成功，返回结果 res[0] = i; res[1] = map.get(num); &#125;else&#123; map.put(nums[i],i); &#125; &#125; return res; &#125;&#125; HashMap将查找的时间复杂度从O(n)降低到O(1)，相较于暴力法，使用哈希查找的算法时间复杂度下降到O(n)。 454. 四数相加 II image-20230115110922496 思路因为只需要输出结果数，不用具体列举每个结果。 ①首先定义 一个HashMap，key放a和b两数之和，value 放a和b两数之和出现的次数。 ②遍历A和B数组，统计两个数组元素之和，和出现的次数，放到map中。 ③定义int变量count，用来统计 a+b+c+d = 0 出现的次数。 ④在遍历C和D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 ⑤最后返回统计值 count 就可以了。 12345678910111213141516171819202122class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int count=0; // 统计出现的次数 for(int i=0;i&lt;nums1.length;i++)&#123; for(int j=0;j&lt;nums2.length;j++)&#123; int sum1 = nums1[i]+nums2[j]; map.put(sum1,map.getOrDefault(sum1,0)+1); &#125; &#125; for(int i=0;i&lt;nums3.length;i++)&#123; for(int j=0;j&lt;nums4.length;j++)&#123; int sum2 = nums3[i] + nums4[j]; int key = 0 - sum2; if(map.containsKey(key))&#123; count+=map.get(key); // 可以重复 &#125; &#125; &#125; return count; &#125;&#125; 383. 赎金信 image-20230115130717327 思路换言之就是判断magazine是否包含ransomNote。因为每个字符只能使用一次，所以在哈希结构中除了要统计字符之外，还要统计该字符出现的次数，使用HashMap。 判断是否包含的条件：如果在HashMap当中没有该key值或key对应的value值为0，则不包含。 12345678910111213141516171819class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;magazine.length();i++)&#123; String str = String.valueOf(magazine.charAt(i)); map.put(str,map.getOrDefault(str,0)+1); &#125; for(int i=0;i&lt;ransomNote.length();i++)&#123; String s = String.valueOf(ransomNote.charAt(i)); if(!map.containsKey(s) || map.get(s)==0)&#123; return false; &#125; int count = map.get(s); count--; map.put(s,count); &#125; return true; &#125;&#125; 15. 三数之和 image-20230115131814327 思路1、哈希解法 ​ 两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组，去重很复杂！ 2、双指针解法 15.三数之和 ​ 双指针解法首先将数组进行排序。求三数之和：外层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。 ​ 定义的左右指针，当nums[i]+nums[left]+nums[right]&gt;0时，三数之和需要减小，故right--;当nums[i]+nums[left]+nums[right]&lt;0时，三数之和需要增大，故left++;当nums[i]+nums[left]+nums[right]==0时，找到答案，left++同时right--。 ​ 要注意去重逻辑：答案要求不能包含重复的三元组。 ​ 其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]。 ​ 去重①：a 如果重复了怎么办，a 是nums里遍历的元素，那么应该直接跳过去。但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。这两种写法是否都正确呢？ 如果我们的写法是： 123if (nums[i] == nums[i + 1]) &#123; // 去重操作 continue;&#125; 那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。 我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！ 所以应该这样写： 123if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue;&#125; ​ 去重②：如果b和c重复了怎么办，b和c是设定的左右双指针，去重逻辑应该放在找到一个三元组答案后。在a确定的前提下，b或者c有一个出现重复，则最终得到的三元组也是重复的需要被舍弃的，故直接跳过。同时为了防止数组越界，加入限定条件left&lt;right（如果left&gt;=right，那这一轮双指针循环就已经结束了），这里要多加思考。 123456while(left&lt;right &amp;&amp; nums[left]==nums[left-1])&#123; left++;&#125;while(left&lt;right &amp;&amp; nums[right]==nums[right+1])&#123; right--;&#125; ​ 完整代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); if(nums[0]&gt;0 || nums[nums.length-1]&lt;0)&#123; return list; &#125; for(int i=0;i&lt;nums.length-2;i++)&#123; // 去重① if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])&#123; continue; &#125; int left=i+1,right=nums.length-1; while(left&lt;right)&#123; // 不能 &#x27;&lt;=&#x27; List&lt;Integer&gt; NumList = new ArrayList&lt;&gt;(); int num = nums[left] + nums[right] + nums[i]; if(num&lt;0)&#123; left++; &#125;else if(num&gt;0)&#123; right--; &#125;else&#123; NumList.add(nums[left]); NumList.add(nums[i]); NumList.add(nums[right]); list.add(NumList); right--; left++; // 去重② while(left&lt;right &amp;&amp; nums[left]==nums[left-1])&#123; left++; &#125; while(left&lt;right &amp;&amp; nums[right]==nums[right+1])&#123; right--; &#125; &#125; &#125; &#125; return list; &#125;&#125; 添加答案可以使用Arrays.asList()函数精简成：result.add(Arrays.asList(nums[i], nums[left], nums[right])); 注意：双指针的while循环条件是left&lt;right，而不是left&lt;=right。 双指针法的时间复杂度O(n^2). 18. 四数之和 image-20230115173231917 思路和三数之和思路相同，要多一层for循环。去重逻辑仍然是对a、b、c、d四个数分别考虑去重，逻辑比较简单这里就不一一赘述了。 注意这里的一步剪枝操作（本题用例中不剪枝会造成无法通过全部用例）：如果nums中可遍历的最小元素大于0且大于target值，那么无论如何都不会出现四数之和等于target了，所以直接返回结果即可。（nums[i]&gt;0是否多余？– 如果nums[i]是负数且大于target呢，可以直接剪枝吗？） 123if(nums[i]&gt;0 &amp;&amp; nums[i]&gt;target)&#123; return AnsList;&#125; 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; AnsList = new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-3;i++)&#123; if(nums[i]&gt;0 &amp;&amp; nums[i]&gt;target)&#123; // 剪枝操作 return AnsList; &#125; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])&#123; continue; &#125; for(int j=i+1;j&lt;nums.length-2;j++)&#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1])&#123; continue; &#125; int left=j+1,right=nums.length-1; while(left&lt;right)&#123; int sum = nums[j] + nums[i] + nums[left] + nums[right]; if(sum&lt;target)&#123; left++; &#125;else if(sum&gt;target)&#123; right--; &#125;else&#123; AnsList.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); left++; right--; while(left&lt;right &amp;&amp; nums[left]==nums[left-1])&#123; left++; &#125; while(left&lt;right &amp;&amp; nums[right]==nums[right+1])&#123; right--; &#125; &#125; &#125; &#125; &#125; return AnsList; &#125;&#125; 【比较】我们可以思考一下，同样是求四个数的和，454. 四数相加 II为什么可以使用哈希法解题，而本题更适合用双指针解法呢？其实在上题中已经说过了，就是重复的问题。454题是4个独立的数组，从每一个数组中找出一个元素，答案可以包含所有重复的四元组；本题是在一个数组中，要求四元组不重复，且构成四元组的a、b、c、d互不相同，可想而知使用哈希进行查找得到的答案进行去重会比较繁琐。 哈希表总结数组在242.有效的字母异位词中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！ 这道题目包含小写字母，那么使用数组来做哈希最合适不过。 在383.赎金信中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！ 383题和242题很像，242.有效的字母异位词是求 字符串a 和 字符串b 是否可以相互组成，在383.赎金信中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。 一些同学可能想，用数组干啥，都用map不就完事了。 上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！ HashSet在349. 两个数组的交集中我们给出了什么时候用数组就不行了，需要用set。 这道题目没有限制数值的大小，就无法使用数组来做哈希表了。 主要因为如下两点： 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。 所以此时一样的做映射的话，就可以使用set了。 在202.快乐数中，我们再次使用了HashSet来判断一个数是否重复出现过。 HashMap 可参考 Java 8系列之重新认识HashMap 在1.两数之和中map正式登场。 来说一说：使用数组和set来做哈希法的局限。 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 map是一种&lt;key, value&gt;的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。 在454.四数相加中我们提到了其实需要哈希的地方都能找到map的身影。 一看好像和18. 四数之和，15.三数之和差不多，其实差很多！ 关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而18. 四数之和，15.三数之和是一个数组（集合）里找到和为0的组合，可就难很多了！ 用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。 在15.三数之和中我给出了哈希法和双指针两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。 所以18. 四数之和，15.三数之和都推荐使用双指针法！","tags":[]},{"title":"Algorithm01 数组","date":"2022-12-18T02:10:51.000Z","path":"2022/12/18/algorithm01/","text":"说在前面：之前刷题都没有按照知识点分类整理过，最近在网上看到推荐代码随想录的算法讲义，就想按照他的推荐系统的把算法这一块拾起来，在自己的博客里做一个记录，也当做日后自己复习的笔记了。 数组理论基础数组是非常基础的数据结构。 一维数组首先要知道数组在内存中的存储方式：数组是存放在连续内存空间上的相同类型数据的集合。 数组可以方便的通过下标索引的方式获取到下标下对应的数据，举一个字符数组的例子，如图所示： 需要两点注意的是： 数组下标都是从0开始的 数组内存空间的地址是连续的 正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。 数组的元素是不能删的，只能覆盖。例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示： 二维数组 Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。 在 Java 当中，二维数组的存储空间实际上并不是连续的，而是这样的： img 一维数组在堆上连续的内存空间直接存储值，二维数组在连续的地址上存储一维数组的引用地址，一维数组与一维数组并不一定靠在一起，但是这些一维数组内部的值是在连续地址上的。更高维的数组继续以此类推，只有最后一维数组在连续地址上保存值，其他纬度均在连续地址上保存下一维度的引用地址。 可以通过代码验证一下： 1234567public static void test_arr() &#123; int[][] arr = &#123;&#123;1, 2, 3&#125;, &#123;2, 3, 4&#125;, &#123;3, 4, 5&#125;, &#123;5, 6, 7&#125;&#125;; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]);&#125; 输出的地址为： 1234[I@36baf30c[I@7a81197d[I@5ca881b5[I@24d46ca6 这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。 相关题目704、二分查找题目链接 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。 二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 while(left &lt; right) 还是 while(left &lt;= right)，到底是right = middle呢，还是要right = middle - 1呢？ 我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要） while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 代码如下： 12345678910111213141516class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length-1; while(left &lt;= right)&#123; int mid = (left + right)&gt;&gt;1; if(nums[mid] &gt; target)&#123; right = mid - 1; &#125;else if(nums[mid] &lt; target)&#123; left = mid + 1; &#125;else if(nums[mid] == target)&#123; return mid; &#125; &#125; return -1; &#125;&#125; 相关题目推荐 35.搜索插入位置 34.在排序数组中查找元素的第一个和最后一个位置 12345678910111213141516171819202122232425262728293031323334353637383940414243 class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] ans = new int[2]; // 寻找左边界 ans[0] = findLeftIndex(nums,target); // 寻找右边界 ans[1] = findRightIndex(nums,target); return ans; &#125; public int findLeftIndex(int[] nums,int target)&#123; int left=0,right=nums.length-1; int ans=-1; while(left&lt;=right)&#123; int mid=(left+right)&gt;&gt;1; if(nums[mid]&gt;target)&#123; right=mid-1; &#125;else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; right=mid-1; ans=mid; &#125; &#125; return ans; &#125; public int findRightIndex(int[] nums,int target)&#123; int left=0,right=nums.length-1; int ans=-1; while(left&lt;=right)&#123; int mid = (left+right)&gt;&gt;1; if(nums[mid]&gt;target)&#123; right=mid-1; &#125;else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; left=mid+1; ans=mid; &#125; &#125; return ans; &#125;&#125; 69.x 的平方根 367.有效的完全平方数 27、移除元素（双指针）题目链接 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2: 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 思路要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。 思路1： 因为数组中的元素大小都在0~50之间，而且不计返回新数组的元素顺序，可以把数组中元素等于val的值设为一个大于50的值，然后对原数组sort操作。 1234567891011121314151617class Solution &#123; public int removeElement(int[] nums, int val) &#123; int len = nums.length; int count = 0; // 与val相同的元素数 if(val &gt; 50)&#123; return len; &#125; for(int i=0;i&lt;len;i++)&#123; if(nums[i] == val)&#123; nums[i] = 100; // 一个不可能在nums中出现的数 count++; &#125; &#125; Arrays.sort(nums); return len-count; &#125;&#125; 思路2： 两个for循环的暴力法——第一个for遍历每个元素，第二个for将数组中元素等于val的值之后的元素前移一位。 27.移除元素-暴力解法 123456789101112131415class Solution &#123; public int removeElement(int[] nums, int val) &#123; int len = nums.length; for(int i=0;i&lt;len;i++)&#123; if(nums[i] == val)&#123; len--; for(int j=i;j&lt;len;j++)&#123; nums[j] = nums[j+1]; &#125; i--; // 因为i以及之后的元素都向前移动了一位 &#125; &#125; return len; &#125;&#125; 思路3： 快慢指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新新数组下标的位置 27.移除元素-双指针法 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int leftIndex=0; for(int rightIndex=0;rightIndex&lt;nums.length;rightIndex++)&#123; if(nums[rightIndex]==val)&#123; continue; &#125; nums[leftIndex++]=nums[rightIndex]; &#125; return leftIndex; // 新数组的长度 &#125;&#125; 总结：第一种思路改变了元素的相对位置，而暴力法和快慢指针法并没有改变新数组元素之间的相对位置。 相关题目推荐双指针有两种，一种是同侧的快慢指针，一种是异侧的双指针，要注意使用的情景。使用双指针往往能将暴力法O(n^2)的时间复杂度降到O(n)。 26.删除排序数组中的重复项 283.移动零 844.比较含退格的字符串 977.有序数组的平方 977、有序数组的平方题目链接 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 思路思路1：排序 123456789class Solution &#123; public int[] sortedSquares(int[] nums) &#123; for(int i=0;i&lt;nums.length;i++)&#123; nums[i] *= nums[i]; &#125; Arrays.sort(nums); return nums; &#125;&#125; 时间复杂度O(nlogn) 思路2：双指针 12345678910111213141516class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left=0,right=nums.length-1; int[] ans = new int[nums.length]; for(int i=ans.length-1;i&gt;=0;i--)&#123; if(nums[left]*nums[left] &gt;= nums[right]*nums[right])&#123; ans[i] = nums[left]*nums[left]; left++; &#125;else&#123; ans[i] = nums[right]*nums[right]; right--; &#125; &#125; return ans; &#125;&#125; 时间复杂度O(n) 209、长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例2： 12输入：target = 4, nums = [1,4,4]输出：1 示例3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 思路思路1：暴力解法 – 据说后面更新了题目数据用例，暴力解法已经超时了 1234567891011121314151617181920class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int len = nums.length; int MinCount = Integer.MAX_VALUE; for(int i=0;i&lt;len;i++)&#123; int sum=0; int count=0; for(int j=i;j&lt;len;j++)&#123; sum += nums[j]; count++; if(sum &gt;= target)&#123; MinCount = MinCount&gt;count ? count : MinCount; break; &#125; &#125; &#125; MinCount = MinCount==Integer.MAX_VALUE ? 0 : MinCount; return MinCount; &#125;&#125; 思路2：滑动窗口 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。 那么滑动窗口如何用一个for循环来完成这个操作呢？ 首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。在快慢指针中，我们用for循环记录快指针的索引，其实滑动窗口本质上也是一种双指针，只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。 所以我们用一个for循环，那么应该表示 滑动窗口的终止位置。 窗口就是： 满足其和 ≥ s 的长度最小的 连续 子数组。 窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。 解题的关键在于 窗口的起始位置 如何移动，如图所示： 1234567891011121314151617class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int len = nums.length; int slowIndex=0,fastIndex; int result = Integer.MAX_VALUE; int sum=0; for(fastIndex=0;fastIndex&lt;len;fastIndex++)&#123; sum += nums[fastIndex]; while(sum &gt;= target)&#123; result = result &lt; fastIndex-slowIndex+1 ? result : fastIndex-slowIndex+1; sum -= nums[slowIndex]; slowIndex++; &#125; &#125; return result = result==Integer.MAX_VALUE ? 0 : result; &#125;&#125; 关于时间复杂度是O(n)的一些疑问—— 不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。 相关题目推荐 904.水果成篮 12345678910111213141516171819202122// 超时？class Solution &#123; public int totalFruit(int[] fruits) &#123; int MaxCount = 0; int leftIndex=0; HashSet&lt;Integer&gt; kind = new HashSet&lt;&gt;(); for(int rightIndex=0;rightIndex&lt;fruits.length;rightIndex++)&#123; int count=0; kind.clear(); for(int i=leftIndex;i&lt;=rightIndex;i++)&#123; if(kind.size()&gt;2)&#123; leftIndex++; break; &#125; kind.add(fruits[i]); count++; &#125; MaxCount = MaxCount&lt;count ? count : MaxCount; &#125; return MaxCount; &#125;&#125; 123456789101112131415161718192021// Right Answerclass Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n = fruits.length; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;Integer, Integer&gt;(); int left = 0, ans = 0; for (int right = 0; right &lt; n; ++right) &#123; cnt.put(fruits[right], cnt.getOrDefault(fruits[right], 0) + 1); while (cnt.size() &gt; 2) &#123; cnt.put(fruits[left], cnt.get(fruits[left]) - 1); if (cnt.get(fruits[left]) == 0) &#123; cnt.remove(fruits[left]); &#125; ++left; &#125; ans = Math.max(ans, right - left + 1); &#125; return ans; &#125;&#125; 76.最小覆盖子串 Java中String和char的相互转换： String转换成char： 使用String.charAt(index)（返回值为char）可以得到String中某一指定位置的char。 使用String.toCharArray()（返回值为char[]）可以得到将包含整个String的char数组。这样我们就能够使用从0开始的位置索引来访问string中的任意位置的元素。 char转换成String： 1234567891011121314151617181. String s = String.valueOf(&#x27;c&#x27;); //效率最高的方法2. String s = String.valueOf(new char[]&#123;&#x27;c&#x27;&#125;); //将一个char数组转换成String3. String s = Character.toString(&#x27;c&#x27;);// Character.toString(char)方法实际上直接返回String.valueOf(char)4. String s = new Character(&#x27;c&#x27;).toString();5. String s = &quot;&quot; + &#x27;c&#x27;;// 虽然这个方法很简单，但这是效率最低的方法// Java中的String Object的值实际上是不可变的，是一个final的变量。// 所以我们每次对String做出任何改变，都是初始化了一个全新的String Object并将原来的变量指向了这个新String。// 而Java对使用+运算符处理String相加进行了方法重载。// 字符串直接相加连接实际上调用了如下方法：// new StringBuilder().append(&quot;&quot;).append(&#x27;c&#x27;).toString();6. String s = new String(new char[]&#123;&#x27;c&#x27;&#125;); 59.螺旋矩阵II（模拟）题目链接 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例1： 1242D48E-772B-4C40-BE9E-CB05A136147C 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例2： 12输入：n = 1输出：[[1]] 思路模拟顺时针画矩阵的过程: ① 填充上行从左到右 ② 填充右列从上到 ③ 填充下行从右到左 ④ 填充左列从下到上 一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开的原则，这样这一圈才能按照统一的规则画下来。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int loop = 0; // 控制循环次数 int count = 1; // 填充的数字 int start = 0; // 每一轮循环开始的位置 int i,j; while(loop++ &lt; n/2)&#123; // 模拟从左到右 for(j=start;j&lt;n-loop;j++)&#123; ans[start][j]=count; count++; &#125; // 模拟从上到下 for(i=start;i&lt;n-loop;i++)&#123; ans[i][j]=count; count++; &#125; // 模拟从右到左 for(;j&gt;=loop;j--)&#123; ans[i][j]=count; count++; &#125; // 模拟从下到上 for(;i&gt;=loop;i--)&#123; ans[i][start]=count; count++; &#125; start++; &#125; if(n%2==1)&#123; // n是奇数 -- 中间置位 ans[n/2][n/2]=count; &#125; return ans; &#125;&#125; 相关题目推荐 54.螺旋矩阵 剑指Offer 29.顺时针打印矩阵 数组总结回顾一下数组的四种经典题型，每一种题型都对应着一种思想。 数组必会知识1、在《Java核心技术》中对数组的定义是：一种可以用来存储同一类型值的集合。 2、数组的内存空间分配： 一维数组：存放在连续内存空间上 二维（高维）数组：最后一个维度的元素存放在连续的内存空间上 3、数组不能删除单一元素，只能覆盖。 二分法考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。 可以使用暴力解法，如果追求更优的算法，建议试一试用二分法，来解决这道题目。 暴力解法时间复杂度：O(n) 二分法时间复杂度：O(logn) 二分法是算法面试中的常考题，建议吃透上面列举的二分题目，锻炼自己手撕二分的能力。 双指针法双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 暴力解法时间复杂度：O(n^2) 双指针时间复杂度：O(n) 这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点： 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放。 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。 滑动窗口本题介绍了数组操作中的另一个重要思想：滑动窗口。 暴力解法时间复杂度：O(n^2) 滑动窗口时间复杂度：O(n) 本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。 如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。 模拟行为模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。 相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的，大家可以在这道题目中体会到这一点。","tags":[]}]